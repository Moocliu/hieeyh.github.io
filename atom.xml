<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hieeyh&#39;s blog</title>
  <subtitle>一只前端小菜鸟的成长日记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuhan.com/"/>
  <updated>2017-08-14T13:15:14.000Z</updated>
  <id>http://yuhan.com/</id>
  
  <author>
    <name>hieeyh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flex布局小结</title>
    <link href="http://yuhan.com/2017/08/14/css-flex/"/>
    <id>http://yuhan.com/2017/08/14/css-flex/</id>
    <published>2017-08-14T13:13:54.000Z</published>
    <updated>2017-08-14T13:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端面试中css部分经常会被问到flex布局，我之前对于flex布局只是大概知道怎么用，但是对于里面的一些属性还不太熟悉，这里总结一下以加深记忆。</p>
<h1 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局"></a>什么是flex布局</h1><p>flex布局的官方说法是CSS3弹性盒子(Flexible Box 或 Flexbox)，很适合在页面布局必须适应不同屏幕尺寸和不同显示设备时进行使用。而且flex布局的元素可以在各个方向上进行布局，不使用浮动等，对以往的块模型进行了改进。</p>
<h2 id="弹性容器"><a href="#弹性容器" class="headerlink" title="弹性容器"></a>弹性容器</h2><p>采用flex布局的元素称为弹性容器，通过设置元素的display属性值为flex或inline-flex来定义弹性容器，它的子元素就自动成为容器成员。值 flex 使弹性容器成为块级元素。值 inline-flex 使弹性容器成为单个不可分的行内级元素。</p>
<h2 id="弹性成员"><a href="#弹性成员" class="headerlink" title="弹性成员"></a>弹性成员</h2><p>弹性容器的每个子元素都称为弹性成员。</p>
<h2 id="轴"><a href="#轴" class="headerlink" title="轴"></a>轴</h2><p>每一个弹性布局容器都包含两个轴，弹性成员沿其排列的轴称为主轴，和主轴垂直的轴称为侧轴。</p>
<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>方向是弹性成员依次排列的方向，比如从左到右，或者从上到下。</p>
<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>弹性项目可以排列在单个行或者多个行中。</p>
<h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>以下几个属性可以用在容器上，来设置相应的布局规则。</p>
<h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p>该属性用来确定主轴，即弹性成员排列的方向是水平从左往右还是从右往左，还是垂直从上往下还是从下往上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  flex-direction: row | row-reverse | column | column-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>flex-warp属性设置弹性项目是排布在单行还是多个行中，该属性可以控制侧轴的方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>nowrap是默认的，表示弹性成员不换行</li>
<li>wrap表示换行，侧轴是默认方向</li>
<li>wrap-reverse表示换行，侧轴是默认方向的反方向</li>
</ol>
<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>flex-flow是flex-direction和flex-wrap属性的简写，决定弹性项目如何排布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  flex-flow: (flex-direction) (flex-wrap)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>该属性定义了项目在主轴上的对齐方式，常用的属性如下：</p>
<ol>
<li>flex-start，主轴起点对齐</li>
<li>flex-end，主轴终点对齐</li>
<li>center，主轴居中对齐</li>
<li>space-between，两端对齐，项目之间间隔相同。</li>
<li>space-around，在主轴上均匀分配弹性元素，相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。</li>
</ol>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>该属性定义项目在侧轴上如何对齐，常用的属性如下：</p>
<ol>
<li>flex-start：侧轴的起点对齐。</li>
<li>flex-end：侧轴终点对齐。</li>
<li>center：侧轴的居中对齐。</li>
<li>baseline: 项目第一行文字的基线对齐。</li>
</ol>
<h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>该属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用，主要取值如下：</p>
<ol>
<li>flex-start：与侧轴的起点对齐。</li>
<li>flex-end：与侧轴的终点对齐。</li>
<li>center：与侧轴的中点对齐。</li>
<li>space-between：与侧轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：在侧轴上均匀分配弹性元素。相邻行元素间距离相同，第一行元素到边框的距离和最后一行元素到行尾的距离是相邻行元素之间距离的一半。</li>
</ol>
<h1 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h1><p>项目元素也可以设置相应属性。</p>
<h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>该属性将元素与序号关联起来，以此决定哪些元素先出现，即数值越小排列越靠前，默认为0。</p>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>该属性定义项目的拉伸因子，即放大比例。默认为0，负值无效。</p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>该属性定义项目的收缩规则，flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据flex-shrink的值。负值无效。</p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>该属性定义项目元素在主轴方向上的初始大小。如果不使用box-sizing来改变盒模型的话，那么这个属性就决定了flex元素的内容盒（content-box）的宽或者高的大小。</p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex属性是flex-grow, flex-shrink和flex-basis的简写，默认值为0 1 auto。</p>
<h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>该属性定义单个项目的对齐方式，并覆盖align-items的值。 如果任何flex元素的侧轴方向margin值设置为auto，则会忽略align-self。该属性的取值可参考align-items属性。</p>
<h1 id="不影响flex布局的属性"><a href="#不影响flex布局的属性" class="headerlink" title="不影响flex布局的属性"></a>不影响flex布局的属性</h1><p>由于弹性盒子使用了不同的布局算法，某些属性用在弹性容器上没有效果：</p>
<ol>
<li>多栏布局的column-* 属性对弹性项目无效。</li>
<li>float与clear对弹性项目无效。使用float将使元素的display属性计为block。</li>
<li>vertical-align对弹性项目的对齐无效。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端面试中css部分经常会被问到flex布局，我之前对于flex布局只是大概知道怎么用，但是对于里面的一些属性还不太熟悉，这里总结一下以加深记忆。&lt;/p&gt;
&lt;h1 id=&quot;什么是flex布局&quot;&gt;&lt;a href=&quot;#什么是flex布局&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="css" scheme="http://yuhan.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yuhan.com/tags/css/"/>
    
      <category term="flex" scheme="http://yuhan.com/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之CSS3新特性</title>
    <link href="http://yuhan.com/2017/07/06/css3-of-interview/"/>
    <id>http://yuhan.com/2017/07/06/css3-of-interview/</id>
    <published>2017-07-06T08:32:46.000Z</published>
    <updated>2017-07-08T02:08:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>除了html5的新特性，CSS3的新特性也是面试中经常被问到的。</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>CSS3中新添加了很多选择器，解决了很多之前需要用javascript才能解决的布局问题。</p>
<ol>
<li>element1~element2: 选择前面有element1元素的每个element2元素。</li>
<li>[attribute^=value]: 选择某元素attribute属性是以value开头的。</li>
<li>[attribute$=value]: 选择某元素attribute属性是以value结尾的。</li>
<li>[attribute*=value]: 选择某元素attribute属性包含value字符串的。</li>
<li>E:first-of-type: 选择属于其父元素的首个E元素的每个E元素。</li>
<li>E:last-of-type: 选择属于其父元素的最后E元素的每个E元素。</li>
<li>E:only-of-type: 选择属于其父元素唯一的E元素的每个E元素。</li>
<li>E:only-child: 选择属于其父元素的唯一子元素的每个E元素。</li>
<li>E:nth-child(n): 选择属于其父元素的第n个子元素的每个E元素。</li>
<li>E:nth-last-child(n): 选择属于其父元素的倒数第n个子元素的每个E元素。</li>
<li>E:nth-of-type(n): 选择属于其父元素第n个E元素的每个E元素。</li>
<li>E:nth-last-of-type(n): 选择属于其父元素倒数第n个E元素的每个E元素。</li>
<li>E:last-child: 选择属于其父元素最后一个子元素每个E元素。</li>
<li>:root: 选择文档的根元素。</li>
<li>E:empty: 选择没有子元素的每个E元素（包括文本节点)。</li>
<li>E:target: 选择当前活动的E元素。</li>
<li>E:enabled: 选择每个启用的E元素。</li>
<li>E:disabled: 选择每个禁用的E元素。</li>
<li>E:checked: 选择每个被选中的E元素。</li>
<li>E:not(selector): 选择非selector元素的每个元素。</li>
<li>E::selection: 选择被用户选取的元素部分。</li>
</ol>
<h1 id="Transition-Transform和Animation"><a href="#Transition-Transform和Animation" class="headerlink" title="Transition,Transform和Animation"></a>Transition,Transform和Animation</h1><p>这三个特性是CSS3新增的和动画相关的特性。</p>
<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><p>Transition可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用Flash动画或JavaScript。<br>Transition有如下属性：</p>
<ol>
<li>transition-property: 规定应用过渡的CSS属性的名称。</li>
<li>transition-duration: 规定完成过渡效果需要多长时间。</li>
<li>transition-delay: 规定过渡效果何时开始，默认是0。</li>
<li>transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有linear、ease-in、ease-out、ease-in-out和cubic-bezier等过渡类型。</li>
<li>transition: 简写属性，用于在一个属性中设置四个过渡属性。</li>
</ol>
<p>在一个例子中使用所有过渡属性如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">transition-property</span>: width;</div><div class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</div><div class="line">    <span class="attribute">transition-timing-function</span>: linear;</div><div class="line">    <span class="attribute">transition-delay</span>: <span class="number">2s</span>;</div><div class="line">    <span class="comment">/* Firefox 4 */</span></div><div class="line">    <span class="attribute">-moz-transition-property</span>:width;</div><div class="line">    <span class="attribute">-moz-transition-duration</span>:<span class="number">1s</span>;</div><div class="line">    <span class="attribute">-moz-transition-timing-function</span>:linear;</div><div class="line">    <span class="attribute">-moz-transition-delay</span>:<span class="number">2s</span>;</div><div class="line">    <span class="comment">/* Safari 和 Chrome */</span></div><div class="line">    <span class="attribute">-webkit-transition-property</span>:width;</div><div class="line">    <span class="attribute">-webkit-transition-duration</span>:<span class="number">1s</span>;</div><div class="line">    <span class="attribute">-webkit-transition-timing-function</span>:linear;</div><div class="line">    <span class="attribute">-webkit-transition-delay</span>:<span class="number">2s</span>;</div><div class="line">    <span class="comment">/* Opera */</span></div><div class="line">    <span class="attribute">-o-transition-property</span>:width;</div><div class="line">    <span class="attribute">-o-transition-duration</span>:<span class="number">1s</span>;</div><div class="line">    <span class="attribute">-o-transition-timing-function</span>:linear;</div><div class="line">    <span class="attribute">-o-transition-delay</span>:<span class="number">2s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用transition属性简写如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">2s</span>;</div><div class="line">    <span class="comment">/* Firefox 4 */</span></div><div class="line">    <span class="attribute">-moz-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</div><div class="line">    <span class="comment">/* Safari and Chrome */</span></div><div class="line">    <span class="attribute">-webkit-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</div><div class="line">    <span class="comment">/* Opera */</span></div><div class="line">    <span class="attribute">-o-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>Transform用来向元素应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。使用方式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(7deg);</div><div class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">rotate</span>(7deg);     <span class="comment">/* IE 9 */</span></div><div class="line">    <span class="attribute">-moz-transform</span>:<span class="built_in">rotate</span>(7deg);    <span class="comment">/* Firefox */</span></div><div class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(7deg); <span class="comment">/* Safari 和 Chrome */</span></div><div class="line">    <span class="attribute">-o-transform</span>:<span class="built_in">rotate</span>(7deg);  <span class="comment">/* Opera */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变换类型"><a href="#变换类型" class="headerlink" title="变换类型"></a>变换类型</h3><p>transform可以有各种变换类型，即属性值：</p>
<ol>
<li>none: 定义不进行转换。</li>
<li>matrix(n,n,n,n,n,n): 定义2D转换，使用六个值的矩阵。</li>
<li>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义3D转换，使用16个值的4x4矩阵。</li>
<li>translate(x,y): 定义2D位移转换。</li>
<li>translate3d(x,y,z): 定义3D位移转换。</li>
<li>translateX(x): 定义位移转换，只是用X轴的值。</li>
<li>translateY(y): 定义位移转换，只是用Y轴的值。</li>
<li>translateZ(z): 定义3D位移转换，只是用Z轴的值。 </li>
<li>scale(x,y): 定义2D缩放转换。 </li>
<li>scale3d(x,y,z): 定义3D缩放转换。 </li>
<li>scaleX(x): 通过设置X轴的值来定义缩放转换。</li>
<li>scaleY(y): 通过设置Y轴的值来定义缩放转换。</li>
<li>scaleZ(z): 通过设置Z轴的值来定义3D缩放转换。</li>
<li>rotate(angle): 定义2D旋转，在参数中规定角度。</li>
<li>rotate3d(x,y,z,angle): 定义3D旋转。</li>
<li>rotateX(angle): 定义沿着X轴的3D旋转。</li>
<li>rotateY(angle): 定义沿着Y轴的3D旋转。</li>
<li>rotateZ(angle): 定义沿着Z轴的3D旋转。</li>
<li>skew(x-angle,y-angle): 定义沿着X和Y轴的2D倾斜转换。</li>
<li>skewX(angle): 定义沿着X轴的2D倾斜转换。</li>
<li>skewY(angle): 定义沿着Y轴的2D倾斜转换。</li>
<li>perspective(n): 为3D转换元素定义透视视图。</li>
</ol>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Internet Explorer 10、Firefox、Opera 支持 transform 属性。<br>Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。<br>Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。<br>Opera 只支持 2D 转换。      </p>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>Animation让CSS拥有了可以制作动画的功能。使用CSS3的Animation制作动画我们可以省去复杂的js代码。使用方法大概如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> anim1 &#123; </div><div class="line">   0% &#123; </div><div class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>; </div><div class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>; </div><div class="line">   &#125; </div><div class="line">   100% &#123; </div><div class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>; </div><div class="line">        <span class="attribute">font-size</span>: <span class="number">24px</span>; </div><div class="line">   &#125; </div><div class="line">&#125; </div><div class="line"><span class="selector-class">.anim1Div</span> &#123; </div><div class="line">   <span class="attribute">-webkit-animation-name</span>: anim1 ; </div><div class="line">   <span class="attribute">-webkit-animation-duration</span>: <span class="number">1.5s</span>; </div><div class="line">   <span class="attribute">-webkit-animation-iteration-count</span>: <span class="number">4</span>; </div><div class="line">   <span class="attribute">-webkit-animation-direction</span>: alternate; </div><div class="line">   <span class="attribute">-webkit-animation-timing-function</span>: ease-in-out; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体用法可以参考教程：<a href="http://www.w3cplus.com/content/css3-animation" target="_blank" rel="external">CSS3 Animation</a>。</p>
<h1 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h1><p>CSS3新增了三个边框属性，分别是border-radius、box-shadow和border-image。border-radius可以创建圆角边框，box-shadow可以为元素添加阴影，border-image可以使用图片来绘制边框。IE9+支持border-radius和box-shadow属性。Firefox、Chrome以及Safari支持所有新的边框属性。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>CSS3新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break。</p>
<h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>background-clip属性用于确定背景画区，有以下几种可能的属性：</p>
<ul>
<li>background-clip: border-box; 背景从border开始显示</li>
<li>background-clip: padding-box; 背景从padding开始显示</li>
<li>background-clip: content-box; 背景显content区域开始显示</li>
<li>background-clip: no-clip; 默认属性，等同于border-box</li>
</ul>
<p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。</p>
<h2 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h2><p>background-clip属性用于确定背景的位置，它通常与background-position联合使用，可以从 border、padding、content来计算background-position（就像background-clip）。</p>
<ul>
<li>background-origin: border-box; 从border开始计算background-position</li>
<li>background-origin: padding-box; 从padding开始计算background-position</li>
<li>background-origin: content-box; 从content开始计算background-position</li>
</ul>
<h2 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h2><p>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>
<ul>
<li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li>
<li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li>
<li>background-size: 100px 100px; 缩小图片至指定的大小</li>
<li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li>
</ul>
<h2 id="background-break"><a href="#background-break" class="headerlink" title="background-break"></a>background-break</h2><p>CSS3中，元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。</p>
<ul>
<li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li>
<li>background-break: bounding-box; 把盒之间的距离计算在内；</li>
<li>background-break: each-box; 为每个盒子单独重绘背景。</li>
</ul>
<h1 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h1><h2 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h2><p>CSS3中，word-wrap属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">word-wrap</span>:break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h2><p>它与word-wrap是协同工作的，word-wrap设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。</p>
<h2 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h2><p>CSS3中，text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">    <span class="attribute">text-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#FF0000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h2><p>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>
<ol>
<li>text-fill-color: 设置文字内部填充颜色</li>
<li>text-stroke-color: 设置文字边界填充颜色</li>
<li>text-stroke-width: 设置文字边界宽度</li>
</ol>
<h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p>CSS3新增了渐变效果，包括linear-gradient(线性渐变)和radial-gradient(径向渐变)。具体用法参考教程：<a href="http://www.w3cplus.com/content/css3-gradient" target="_blank" rel="external">CSS3 Gradient</a></p>
<h1 id="font-face特性"><a href="#font-face特性" class="headerlink" title="@font-face特性"></a>@font-face特性</h1><p>在CSS3之前，web设计师必须使用已在用户计算机上安装好的字体。通过CSS3，web设计师可以使用他们喜欢的任意字体。当您您找到或购买到希望使用的字体时，可将该字体文件存放到web服务器上，它会在需要时被自动下载到用户的计算机上。字体是在 CSS3 @font-face 规则中定义的。Firefox、Chrome、Safari以及Opera支持 .ttf(True Type Fonts)和 .otf(OpenType Fonts)类型的字体。IE9+ 支持新的@font-face规则，但是仅支持 .eot类型的字体(Embedded OpenType)。</p>
<p>在新的@font-face规则中，必须首先定义字体的名称（比如myFont），然后指向该字体文件。<br>如需为HTML元素使用字体，请通过font-family属性来引用字体的名称 (myFont)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line">    <span class="attribute">font-family</span>: myFirstFont;</div><div class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'Sansation_Light.ttf'</span>),</div><div class="line">         <span class="built_in">url</span>(<span class="string">'Sansation_Light.eot'</span>); <span class="comment">/* IE9+ */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">font-family</span>:myFirstFont;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h1><p>通过CSS3，能够创建多个列来对文本进行布局，IE10和Opera支持多列属性。Firefox 需要前缀-moz-，Chrome和Safari需要前缀-webkit-。主要有如下三个属性：</p>
<ol>
<li>column-count: 规定元素应该被分隔的列数。</li>
<li>column-gap: 规定列之间的间隔。</li>
<li>column-rule: 设置列之间的宽度、样式和颜色规则</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">-moz-column-count</span>:<span class="number">3</span>;    <span class="comment">/* Firefox */</span></div><div class="line">    <span class="attribute">-webkit-column-count</span>:<span class="number">3</span>; <span class="comment">/* Safari 和 Chrome */</span></div><div class="line">    <span class="attribute">column-count</span>:<span class="number">3</span>;</div><div class="line">    <span class="attribute">-moz-column-gap</span>:<span class="number">40px</span>;       <span class="comment">/* Firefox */</span></div><div class="line">    <span class="attribute">-webkit-column-gap</span>:<span class="number">40px</span>;    <span class="comment">/* Safari 和 Chrome */</span></div><div class="line">    <span class="attribute">column-gap</span>:<span class="number">40px</span>;</div><div class="line">    <span class="attribute">-moz-column-rule</span>:<span class="number">3px</span> outset <span class="number">#ff0000</span>;    <span class="comment">/* Firefox */</span></div><div class="line">    <span class="attribute">-webkit-column-rule</span>:<span class="number">3px</span> outset <span class="number">#ff0000</span>; <span class="comment">/* Safari and Chrome */</span></div><div class="line">    <span class="attribute">column-rule</span>:<span class="number">3px</span> outset <span class="number">#ff0000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h1><p>CSS3中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。Firefox、Chrome以及Safari 支持resize属性。IE、Chrome、Safari以及Opera支持box-sizing属性。Firefox需要前缀-moz-。<br>所有主流浏览器都支持outline-offset属性，除了IE。</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>resize 属性规定是否可由用户调整元素尺寸。如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">resize</span>:both; <span class="comment">/* none|both|horizontal|vertical; */</span></div><div class="line">    <span class="attribute">overflow</span>:auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>box-sizing属性可设置的值有content-box、border-box和inherit。</p>
<ol>
<li>content-box: padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。</li>
<li>border-box: padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。</li>
</ol>
<h2 id="outline-offset"><a href="#outline-offset" class="headerlink" title="outline-offset"></a>outline-offset</h2><p>outline-offset属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了html5的新特性，CSS3的新特性也是面试中经常被问到的。&lt;/p&gt;
&lt;h1 id=&quot;选择器&quot;&gt;&lt;a href=&quot;#选择器&quot; class=&quot;headerlink&quot; title=&quot;选择器&quot;&gt;&lt;/a&gt;选择器&lt;/h1&gt;&lt;p&gt;CSS3中新添加了很多选择器，解决了很多之前需要用j
    
    </summary>
    
      <category term="面试" scheme="http://yuhan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="css" scheme="http://yuhan.com/tags/css/"/>
    
      <category term="面试" scheme="http://yuhan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之html5新特性</title>
    <link href="http://yuhan.com/2017/07/06/html5-of-interview/"/>
    <id>http://yuhan.com/2017/07/06/html5-of-interview/</id>
    <published>2017-07-06T02:13:14.000Z</published>
    <updated>2017-07-16T11:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来谈谈前端面试中基本上每次一面的时候都会被问到的一个问题，那就是html5的新特性。这个是学习前端必须掌握的基础知识。</p>
<h1 id="新增的元素"><a href="#新增的元素" class="headerlink" title="新增的元素"></a>新增的元素</h1><p>html5新增了一些语义化更好的标签元素。</p>
<h2 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h2><ol>
<li>article元素，表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章。</li>
<li>aside元素，表示article内容之外的内容，辅助信息。</li>
<li>header元素，表示页面中一个内容区块或整个页面的页眉。</li>
<li>hgroup元素，用于对页面中一个区块或整个页面的标题进行组合。</li>
<li>footer元素，表示页面中一个内容区块或整个页面的页脚。</li>
<li>figure元素，表示媒介内容的分组，以及它们的标题。</li>
<li>section元素，表示页面中一个内容区块，比如章节。</li>
<li>nav元素，表示页面中的导航链接。</li>
</ol>
<h2 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h2><ol>
<li>video元素，用来定义视频。</li>
<li>audio元素，用来定义音频。</li>
<li>canvas元素，用来展示图形，该元素本身没有行为，仅提供一块画布。</li>
<li>embed元素，用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。</li>
<li>mark元素，用来展示高亮的文字。</li>
<li>progress元素，用来展示任何类型的任务的进度。</li>
<li>meter元素，表示度量衡，定义预定义范围内的度量。</li>
<li>time元素，用来展示日期或者时间。</li>
<li>command元素，表示命令按钮。</li>
<li>details元素，用来展示用户要求得到并且可以得到的细节信息。</li>
<li>summary元素，用来为details元素定义可见的标题。</li>
<li>datalist元素，用来展示可选的数据列表，与input元素配合使用，可以制作出输入值的下拉列表。</li>
<li>datagrid元素，也用来展示可选的数据列表，以树形列表的形式来显示。</li>
<li>keygen元素，表示生成密匙。</li>
<li>output元素，表示不同类型的输出。</li>
<li>source元素，为媒介元素定义媒介资源。</li>
<li>menu元素，表示菜单列表。</li>
<li>ruby元素，表示ruby注释， rt元素表示字符的解释或发音。    rp元素在ruby注释中使用，以定义不支持ruby元素的浏览器所显示的内容。</li>
<li>wbr元素，表示软换行。与br元素的区别是：br元素表示此处必须换行，而wbr元素的意思是浏览器窗口或父级元素的宽度够宽时。不进行换行，而当宽度不够时，主动在此处进行换行。</li>
<li>bdi元素，定义文本的文本方向，使其脱离其周围文本的方向设置。</li>
<li>dialog元素，表示对话框或窗口。</li>
</ol>
<h1 id="废除的元素"><a href="#废除的元素" class="headerlink" title="废除的元素"></a>废除的元素</h1><p>html5中废除了一些纯表现的元素，只有部分浏览器支持的元素还有一些会对可用性产生负面影响的元素。</p>
<h2 id="纯表现元素"><a href="#纯表现元素" class="headerlink" title="纯表现元素"></a>纯表现元素</h2><p>纯表现的元素就是那些可以用css替代的元素。basefont、big、center、font、s、strike、tt、u这些元素，他们的功能都是纯粹为页面展示服务的，html5提倡把页面展示性功能放在css样式表中统一处理，所以将这些元素废除，用css样式进行替代。</p>
<h2 id="对可用性产生负面影响的元素"><a href="#对可用性产生负面影响的元素" class="headerlink" title="对可用性产生负面影响的元素"></a>对可用性产生负面影响的元素</h2><p>对于frameset元素、frame元素与noframes元素，由于frame框架对网页可用性存在负面影响，在html5中已不支持frame框架，只支持iframe框架，html5中同时将frameset、frame和noframes这三个元素废除。</p>
<h2 id="只有部分浏览器支持的元素"><a href="#只有部分浏览器支持的元素" class="headerlink" title="只有部分浏览器支持的元素"></a>只有部分浏览器支持的元素</h2><p>对于applet、bgsound、blink、marquee等元素，由于只有部分浏览器支持，特别是bgsound元素以及marquee元素，只被IE支持，所以在html5中被废除。其中applet元素可由embed元素或object元素替代，bgsound元素可由audio元素替代，marquee可以由javascript编程的方式替代。</p>
<h1 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h1><h2 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h2><p>上文提到的canvas元素可以为页面提供一块画布来展示图形。结合Canvas API，就可以在这块画布上动态生成和展示各种图形、图表、图像以及动画了。Canvas本质上是位图画布，不可缩放，绘制出来的对象不属于页面DOM结构或者任何命名空间。不需要将每个图元当做对象存储，执行性能非常好。</p>
<p>利用Canvas API进行绘图，首先要获取canvas元素的上下文，然后用该上下文中封装的各种绘图功能进行绘图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;canvas&quot;&gt;替代内容&lt;/canvas&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var canvas = document.getElementById(&apos;canvas&apos;);</div><div class="line">    var context =canvas.getContext(&quot;2d&quot;); // 获取上下文</div><div class="line">    //设置纯色</div><div class="line">    context.fillStyle = &quot;red&quot;;</div><div class="line">    context.strokeStyle = &quot;blue&quot;;</div><div class="line">    // 实践表明在不设置fillStyle下的默认fillStyle为black</div><div class="line">    context.fillRect(0, 0, 100, 100);</div><div class="line">    // 实践表明在不设置strokeStyle下的默认strokeStyle为black</div><div class="line">    context.strokeRect(120, 0, 100, 100);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG是html5的另一项图形功能，它是一种标准的矢量图形，是一种文件格式，有自己的API。html5引入了内联SVG，使得SVG元素可以直接出现在html标记中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;svg height=100 width=100&gt;&lt;circle cx=50 cy=50 r=50 /&gt;&lt;/svg&gt;</div></pre></td></tr></table></figure></p>
<h2 id="音频和视频"><a href="#音频和视频" class="headerlink" title="音频和视频"></a>音频和视频</h2><p>audio和video元素的出现让html5的媒体应用多了新选择，开发人员不必使用插件就能播放音频和视频。对于这两个元素，html5规范提供了通用、完整、可脚本化控制的API。<br>html5规范出来之前，在页面中播放视频的典型方式是使用Flash、QuickTime或者Windows Media插件往html中嵌入音频视频，相对这种方式，使用html5的媒体标签有两大好处。</p>
<ol>
<li>作为浏览器原生支持的功能，新的audio和video元素无需安装。</li>
<li>媒体元素想Web页面提供了通用、集成和可脚本化控制的API。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;video src=&quot;video.webm&quot; controls&gt;</div><div class="line">    &lt;object data=&quot;videoplayer.swf&quot; type=&quot;application/x-shockwave-flash&quot;&gt;</div><div class="line">        &lt;param name=&quot;movie&quot; value=&quot;video.swf&quot; /&gt;</div><div class="line">    &lt;/object&gt;</div><div class="line">    Your browser does not support HTML5 video.</div><div class="line">&lt;/video&gt;</div></pre></td></tr></table></figure>
<h3 id="浏览器支持性检测"><a href="#浏览器支持性检测" class="headerlink" title="浏览器支持性检测"></a>浏览器支持性检测</h3><p>浏览器检测是否支持audio元素或者video元素最简单的方式是用脚本动态创建它，然后检测特定函数是否存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hasVideo = !!(<span class="built_in">document</span>.createElement(<span class="string">'video'</span>).canPlayType);</div></pre></td></tr></table></figure></p>
<h2 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h2><p>html5的Geolocation API（地理定位API），可以请求用户共享他们的位置。使用方法非常简单，如果用户同意，浏览器就会返回位置信息，该位置信息是通过支持html5地理定位功能的底层设备（如笔记本电脑或手机）提供给浏览器的。位置信息由纬度、经度坐标和一些其他元数据组成。</p>
<h3 id="位置信息从何而来"><a href="#位置信息从何而来" class="headerlink" title="位置信息从何而来"></a>位置信息从何而来</h3><p>Geolocation API不指定设备使用哪种底层技术来定位应用程序的用户。相反，它只是用于检索位置信息的API，而且通过该API检索到的数据只具有某种程度的准确性，并不能保证设备返回的位置是精确的。设备可以使用下列数据源：</p>
<ol>
<li>IP地址</li>
<li>三维坐标<ol>
<li>GPS</li>
<li>从RFID、WiFi和蓝牙到WiFi的MAC地址</li>
<li>GSM或CDMA手机的ID</li>
</ol>
</li>
<li>用户自定义数据</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一次更新</span></div><div class="line">navigator.geolocation.getCurrentPosition(updateLocation, handleLocationEror);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLocation</span>(<span class="params">position</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> latitude = position.coords.latitude;     <span class="comment">// 纬度</span></div><div class="line">    <span class="keyword">var</span> longitude = position.coords.longitude;   <span class="comment">// 经度</span></div><div class="line">    <span class="keyword">var</span> accuracy = position.coords.accuracy;     <span class="comment">// 准确度</span></div><div class="line">    <span class="keyword">var</span> timestamp = position.coords.timestamp;   <span class="comment">// 时间戳</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 错误处理函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLocationEror</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    ....</div><div class="line">&#125;</div><div class="line"><span class="comment">// 重复更新</span></div><div class="line">navigator.geolocation.watchPosition(updateLocation, handleLocationEror);</div><div class="line"><span class="comment">// 不再接受位置更新</span></div><div class="line">navigator.geolocation.clearWatch(watchId);</div></pre></td></tr></table></figure>
<h2 id="Communication-API"><a href="#Communication-API" class="headerlink" title="Communication API"></a>Communication API</h2><h3 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h3><p>出于安全方面的考虑，运行在同一浏览器中的框架、标签页、窗口间的通信一直都受到了严格的限制。然而，现实中存在一些合理的让不同站点的内容能在浏览器内进行交互的需求。这种情形下，如果浏览器内部能提供直接的通信机制，就能更好地组织这些应用。<br>html5中引入了一种新功能，跨文档消息通信，可以确保iframe、标签页、窗口间安全地进行跨源通信。postMessage API为发送消息的标准方式，发送消息非常简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.postMessage(<span class="string">'Hello, world'</span>, <span class="string">'http://www.example.com/'</span>);</div></pre></td></tr></table></figure></p>
<p>接收消息时，仅需在页面中增加一个事件处理函数。当某个消息到达时，通过检查消息的来源来决定是否对这条消息进行处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, messageHandler, <span class="literal">true</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(e.origin) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"friend.example.com"</span>:</div><div class="line">        <span class="comment">// 处理消息</span></div><div class="line">        processMessage(e.data);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: </div><div class="line">        <span class="comment">// 消息来源无法识别</span></div><div class="line">        <span class="comment">// 消息被忽略</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消息事件是一个拥有data(数据)和origin(源)属性的DOM事件。data属性是发送方传递的实际消息，而origin属性是发送来源。</p>
<h3 id="XMLHttpRequest-Level2"><a href="#XMLHttpRequest-Level2" class="headerlink" title="XMLHttpRequest Level2"></a>XMLHttpRequest Level2</h3><p>XMLHttpRequest API使得Ajax技术成为可能，作为XMLHttpRequest的改进版，XMLHttpRequest Level2在功能上有了很大的改进。主要两个方面：</p>
<ol>
<li>跨源XMLHttpRequest</li>
<li>进度事件</li>
</ol>
<h4 id="跨源XMLHttpRequest"><a href="#跨源XMLHttpRequest" class="headerlink" title="跨源XMLHttpRequest"></a>跨源XMLHttpRequest</h4><p>过去，XMLHttpRequest仅限于同源通信，XMLHttpRequest Level2通过CORS实现了跨源XMLHttpRequest。跨源HTTP请求包含一个Origin头部，它为服务器提供HTTP请求的源信息。</p>
<h2 id="WebSockets-API"><a href="#WebSockets-API" class="headerlink" title="WebSockets API"></a>WebSockets API</h2><p>WebSockets是html5中最强大的通信功能，它定义了一个全双工通信信道，仅通过Web上的一个Socket即可进行通信。</p>
<h3 id="WebSockets握手"><a href="#WebSockets握手" class="headerlink" title="WebSockets握手"></a>WebSockets握手</h3><p>为了建立WebSockets通信，客户端和服务器在初始握手时，将HTTP协议升级到WebSocket协议。一旦连接建立成功，就可以在全双工模式下在客户端和服务器之间来回传递WebSocket消息。</p>
<h3 id="WebSockets接口"><a href="#WebSockets接口" class="headerlink" title="WebSockets接口"></a>WebSockets接口</h3><p>除了对WebSockets协议定义外，该规范还同时定义了用于JavaScript应用程序的WebSocket接口。WebSockets接口的使用很简单。要连接远程主机，只需要新建一个WebSocket实例，提供希望连接的对端URL。</p>
<h2 id="Forms-API"><a href="#Forms-API" class="headerlink" title="Forms API"></a>Forms API</h2><h3 id="新表单元素"><a href="#新表单元素" class="headerlink" title="新表单元素"></a>新表单元素</h3><ol>
<li>tel元素，表示电话号码。</li>
<li>email元素，表示电子邮件地址文本框。</li>
<li>url元素，表示网页的url。</li>
<li>search元素，用于搜索引擎，比如在站点顶部显示的搜索框。</li>
<li>range元素，特定值范围内的数值选择器，典型的显示方式是滑动条。</li>
<li>number元素，只包含数值的字段。</li>
</ol>
<h3 id="未来的表单元素"><a href="#未来的表单元素" class="headerlink" title="未来的表单元素"></a>未来的表单元素</h3><ol>
<li>color元素，颜色选择器，基于调色盘或者取色板进行选择。</li>
<li>datetime元素，显示完整的日期和时间，包括时区。</li>
<li>datetime-local，显示日期和时间。</li>
<li>time元素，不含时区的时间选择器和指示器。</li>
<li>date元素，日期选择器。</li>
<li>week元素，某年中的周选择器。</li>
<li>month元素，某年中的月选择器。</li>
</ol>
<h3 id="新的表单特性和函数"><a href="#新的表单特性和函数" class="headerlink" title="新的表单特性和函数"></a>新的表单特性和函数</h3><h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>当用户还没输入值的时候，输入型控件可以通过placeholder特性向用户显示描述性说明或者提示信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input name=&quot;name&quot; placeholder=&quot;First and last name&quot;&gt;</div></pre></td></tr></table></figure></p>
<h4 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a>autocomplete</h4><p>浏览器通过autocomplete特性能够知晓是否应该保存输入值以备将来使用。</p>
<h4 id="autofocus"><a href="#autofocus" class="headerlink" title="autofocus"></a>autofocus</h4><p>通过autofocus特性可以指定某个表单元素获得输入焦点，每个页面上只允许出现一个autofocus特性，如果设置了多个，则相当于未指定此行为。</p>
<h4 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a>spellcheck</h4><p>可对带有文本内容的输入控件和textarea空间控制spellcheck属性。设置完后，会询问浏览器是否应该给出拼写检查结果反馈。spellcheck属性需要赋值。</p>
<h4 id="list特性和datalist元素"><a href="#list特性和datalist元素" class="headerlink" title="list特性和datalist元素"></a>list特性和datalist元素</h4><p>通过组合使用list特性和datalist元素，开发人员能够为某个输入型控件构造一张选值列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;datalist id=&quot;contactList&quot;&gt;</div><div class="line">    &lt;option value=&quot;a@qq.com&quot;&gt;&lt;/option&gt;</div><div class="line">    &lt;option value=&quot;b@qq.com&quot;&gt;&lt;/option&gt;</div><div class="line">&lt;/datalist&gt;</div><div class="line">&lt;input type=&quot;email&quot; id=&quot;contatcs&quot; list=&quot;contactList&quot;&gt;</div></pre></td></tr></table></figure></p>
<h4 id="min和max"><a href="#min和max" class="headerlink" title="min和max"></a>min和max</h4><p>通过设置min和max特性，可以将range输入框的数值输入范围限定在最低值和最高值之间。可以只设置一个，也可以两个都设置，也可以都不设置。</p>
<h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>对于输入型控件，设置其step特性能够指定输入值递增或者递减的粒度。</p>
<h4 id="required"><a href="#required" class="headerlink" title="required"></a>required</h4><p>一旦为某输入型控件设置了required特性，那么此项必填，否则无法提交表单。</p>
<h2 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h2><h3 id="draggable属性"><a href="#draggable属性" class="headerlink" title="draggable属性"></a>draggable属性</h3><p>如果网页元素的draggable元素为true，这个元素就是可以拖动的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div draggable=&quot;true&quot;&gt;Draggable Div&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><p>拖动过程会触发很多事件，主要有下面这些：</p>
<ol>
<li>dragstart：网页元素开始拖动时触发。</li>
<li>drag：被拖动的元素在拖动过程中持续触发。</li>
<li>dragenter：被拖动的元素进入目标元素时触发，应在目标元素监听该事件。</li>
<li>dragleave：被拖动的元素离开目标元素时触发，应在目标元素监听该事件。</li>
<li>dragover：被拖动元素停留在目标元素之中时持续触发，应在目标元素监听该事件。</li>
<li>drap：被拖动元素或从文件系统选中的文件，拖放落下时触发。</li>
<li>dragend：网页元素拖动结束时触发。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">draggableElement.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'拖动开始！'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="dataTransfer对象"><a href="#dataTransfer对象" class="headerlink" title="dataTransfer对象"></a>dataTransfer对象</h3><p>拖动过程中，回调函数接受的事件参数，有一个dataTransfer属性，指向一个对象，包含与拖动相关的各种信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">draggableElement.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    event.dataTransfer.setData(<span class="string">'text'</span>, <span class="string">'Hello World!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>dataTransfer对象的属性有：</p>
<ol>
<li>dropEffect：拖放的操作类型，决定了浏览器如何显示鼠标形状，可能的值为copy、move、link和none。</li>
<li>effectAllowed：指定所允许的操作，可能的值为copy、move、link、copyLink、copyMove、linkMove、all、none和uninitialized（默认值，等同于all，即允许一切操作）。</li>
<li>files：包含一个FileList对象，表示拖放所涉及的文件，主要用于处理从文件系统拖入浏览器的文件。</li>
<li>types：储存在DataTransfer对象的数据的类型。</li>
</ol>
<p>dataTransfer对象的方法有：</p>
<ol>
<li>setData(format, data)：在dataTransfer对象上储存数据。第一个参数format用来指定储存的数据类型，比如text、url、text/html等。</li>
<li>getData(format)：从dataTransfer对象取出数据。</li>
<li>clearData(format)：清除dataTransfer对象所储存的数据。如果指定了format参数，则只清除该格式的数据，否则清除所有数据。</li>
<li>setDragImage(imgElement, x, y)：指定拖动过程中显示的图像。默认情况下，许多浏览器显示一个被拖动元素的半透明版本。参数imgElement必须是一个图像元素，而不是指向图像的路径，参数x和y表示图像相对于鼠标的位置。</li>
</ol>
<h2 id="Web-Workers-API"><a href="#Web-Workers-API" class="headerlink" title="Web Workers API"></a>Web Workers API</h2><p>Javascript是单线程的。因此，持续时间较长的计算，回阻塞UI线程，进而导致无法在文本框中填入文本，单击按钮等，并且在大多数浏览器中，除非控制权返回，否则无法打开新的标签页。该问题的解决方案是Web Workers，可以让Web应用程序具备后台处理能力，对多线程的支持性非常好。</p>
<p>但是在Web Workers中执行的脚本不能访问该页面的window对象，也就是Web Workers不能直接访问Web页面和DOM API。虽然Web Workers不会导致浏览器UI停止响应，但是仍然会消耗CPU周期，导致系统反应速度变慢。</p>
<h2 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h2><p>Web Storage是html5引入的一个非常重要的功能，可以在客户端本地存储数据，类似html4的cookie，但可实现功能要比cookie强大的多。 </p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>sessionStorage将数据保存在session中，浏览器关闭数据就消失。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage则一直将数据保存在客户端本地，除非手动删除，否则一直保存。<br>不管是sessionStorage，还是localStorage，可使用的API相同，常用的有如下几个（以localStorage为例）：</p>
<ol>
<li>保存数据：localStorage.setItem(key,value);</li>
<li>读取数据：localStorage.getItem(key);</li>
<li>删除单个数据：localStorage.removeItem(key);</li>
<li>删除所有数据：localStorage.clear();</li>
<li>得到某个索引的key：localStorage.key(index);</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来谈谈前端面试中基本上每次一面的时候都会被问到的一个问题，那就是html5的新特性。这个是学习前端必须掌握的基础知识。&lt;/p&gt;
&lt;h1 id=&quot;新增的元素&quot;&gt;&lt;a href=&quot;#新增的元素&quot; class=&quot;headerlink&quot; title=&quot;新增的元素&quot;&gt;&lt;/a&gt;新增
    
    </summary>
    
      <category term="面试" scheme="http://yuhan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yuhan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="html5" scheme="http://yuhan.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之同源与跨域</title>
    <link href="http://yuhan.com/2017/07/02/cross-domain/"/>
    <id>http://yuhan.com/2017/07/02/cross-domain/</id>
    <published>2017-07-02T06:02:07.000Z</published>
    <updated>2017-07-06T02:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的同源策略及跨域的方法在前端面试中也是出场率极高的问题。</p>
<h1 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h1><p>同源策略是用来限制从一个源加载的文档或者脚本如何与来自另一个源的资源进行交互，是一种用于隔离潜在的恶意文件的关键的安全机制。</p>
<h2 id="何谓同源"><a href="#何谓同源" class="headerlink" title="何谓同源"></a>何谓同源</h2><p>如果协议、域名和端口对于两个页面来说是相同的，则这两个页面就是同源的。比如：<a href="http://www.hyuhan.com/index.html" target="_blank" rel="external">http://www.hyuhan.com/index.html</a> 这个网站，协议是http，域名是www.hyuhan.com，端口是80(默认端口)，它的同源情况如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http://www.hyuhan.com/other.html：同源</div><div class="line">http://hyuhan.com/other.html：不同源（域名不同）</div><div class="line">https://www.hyuhan.com/other.html：不同源（协议不同）</div><div class="line">http://www.hyuhan.com:81/other.html：不同源（端口不同）</div></pre></td></tr></table></figure></p>
<p>同源策略是为了保护用户信息的安全，受到同源策略限制的主要有以下几种行为：</p>
<ol>
<li>Cookie、LocalStorage和IndexDB无法读取</li>
<li>DOM无法操作</li>
<li>AJAX请求不能发送</li>
</ol>
<h1 id="如何进行跨域访问"><a href="#如何进行跨域访问" class="headerlink" title="如何进行跨域访问"></a>如何进行跨域访问</h1><h2 id="怎么跨域进行AJAX请求"><a href="#怎么跨域进行AJAX请求" class="headerlink" title="怎么跨域进行AJAX请求"></a>怎么跨域进行AJAX请求</h2><p>主要由三种方法可以绕过同源策略的限制，来进行跨域的AJAX请求。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是客户端与服务端跨域通信的常用的方法。利用可以跨域的&lt;script&bt;元素，向服务器请求json数据，服务端收到请求后，将数据放在一个回调函数中传回来。实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">    script.src = <span class="string">"http://example.com/callback=test"</span>;</div><div class="line">    <span class="built_in">document</span>.appendChild(script);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(res);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>src的callback参数是用来设置后端需要调用的回调函数的名字的，服务器返回的数据如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">test(&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"小明"</span>,</div><div class="line">    <span class="string">"age"</span>: <span class="number">24</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>这样，前端就能跨域读取后端的数据了。但是jsopn只能发生get请求，不能发送post请求。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是一种基于TCP的新的网络协议，它不实行同源策略，只要服务器支持，就可以进行跨域访问。而且WebSocket并不限于以Ajax方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是Access-Control-Allow-Origin（跨域资源共享）的缩写，它是一个W3C的标准。CORS需要浏览器和服务器同时支持，目前基本所有的浏览器都支持该功能。服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>Cookie是服务器写入浏览器的信息，安全起见，只有同源的网页才能共享。但是，如果两个网页的一级域名相同，但是耳机域名不同的话，可以通过设置document.domain来共享Cookie。</p>
<p>比如，一个网页域名是<a href="http://w1.example.com/a.html" target="_blank" rel="external">http://w1.example.com/a.html</a> ，另一个网页域名是<a href="http://w2.example.com/b.html" target="_blank" rel="external">http://w2.example.com/b.html</a> ，只要给们设置相同的document.domain，这两个网页就可以共享Cookie。</p>
<h2 id="postMessage-API"><a href="#postMessage-API" class="headerlink" title="postMessage API"></a>postMessage API</h2><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文档、多窗口、跨域消息传递。用postMessage()函数传递消息，目标页面监听window的message事件接收消息。利用postMessage，我们可以跨域读取LocalStorage和IndexDB还有DOM数据。</p>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>浏览器窗口有window.name的属性，该属性规定无论是否同源，只要在一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取它。即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。显然，这是可以实现跨域访问的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的同源策略及跨域的方法在前端面试中也是出场率极高的问题。&lt;/p&gt;
&lt;h1 id=&quot;什么是同源策略&quot;&gt;&lt;a href=&quot;#什么是同源策略&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略&quot;&gt;&lt;/a&gt;什么是同源策略&lt;/h1&gt;&lt;p&gt;同源策略是用来限制从一
    
    </summary>
    
      <category term="面试" scheme="http://yuhan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yuhan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="跨域" scheme="http://yuhan.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之点击劫持</title>
    <link href="http://yuhan.com/2017/07/02/web-security-clickjacking/"/>
    <id>http://yuhan.com/2017/07/02/web-security-clickjacking/</id>
    <published>2017-07-02T05:35:16.000Z</published>
    <updated>2017-07-02T06:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来聊聊前端应用安全问题中的最后一种，点击劫持(ClickJacking)。</p>
<h1 id="什么是点击劫持"><a href="#什么是点击劫持" class="headerlink" title="什么是点击劫持"></a>什么是点击劫持</h1><p>点击劫持是一种视觉上的欺骗手段，攻击者使用一个透明的、不可见的iframe元素，覆盖在一个网页上，然后诱使用户在该网页上进行操作，用户就可能在不知情的情况下点击透明的iframe，通过css改变iframe位置，可以让用户点击在iframe上的某些特定按钮上。</p>
<p>点击劫持和CSRF一样，都是在用户不知情的情况下诱使用户完成一些操作。但是在CSRF攻击过程中，如果有需要用户进行交互的页面，比如输入验证码等，则攻击可能无法顺利完成。与之相反的是，点击劫持没有这个顾虑，它利用的就是用户与页面产生的交互。</p>
<h1 id="Flash点击劫持"><a href="#Flash点击劫持" class="headerlink" title="Flash点击劫持"></a>Flash点击劫持</h1><p>通过Flash进行点击劫持攻击可能会更严重，攻击者最终可以控制电脑的摄像头。</p>
<p>首先，攻击者制作一个Flash游戏，并诱使用户玩这个游戏。游戏很简单，就是让用户去点击按钮，每次点击之后这个按钮的位置都会发送变化。在页面上覆盖了一层iframe。攻击通过诱使用户鼠标点击的位置，能够完成一系列的步骤，最终可以打开用户的摄像头。 </p>
<h1 id="图片覆盖攻击"><a href="#图片覆盖攻击" class="headerlink" title="图片覆盖攻击"></a>图片覆盖攻击</h1><p>同样的思路，可以用图片覆盖某个网站的logo，并指向一个钓鱼网站。网站的logo的点击率是相对较高的，如果用户点击了这个被覆盖的logo，进入钓鱼网站，那么就很可能会被骗。主要还是通过css来改变图片的位置，使它刚好覆盖网站上的某些图片。</p>
<h1 id="拖拽劫持和数据窃取"><a href="#拖拽劫持和数据窃取" class="headerlink" title="拖拽劫持和数据窃取"></a>拖拽劫持和数据窃取</h1><p>目前很多浏览器都开始支持Drag&amp;Drop的API，浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另一个窗口，因此拖拽是不受同源策略限制的。</p>
<p>“拖拽劫持”的思路是诱使用户从隐藏的不可见iframe中拖拽出攻击者希望得到的数据，然后放到另一个页面中，从而窃取数据。</p>
<p>点击劫持相较于XSS和CSRF来说，实施攻击的成本更高，因为它需要诱使用户与页面产生交互行为。但是点击劫持很可能被攻击者利用在钓鱼、欺诈和广告作弊等方面，还是需要加倍小心。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来聊聊前端应用安全问题中的最后一种，点击劫持(ClickJacking)。&lt;/p&gt;
&lt;h1 id=&quot;什么是点击劫持&quot;&gt;&lt;a href=&quot;#什么是点击劫持&quot; class=&quot;headerlink&quot; title=&quot;什么是点击劫持&quot;&gt;&lt;/a&gt;什么是点击劫持&lt;/h1&gt;&lt;p&gt;点击劫
    
    </summary>
    
      <category term="web安全" scheme="http://yuhan.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://yuhan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之CSRF</title>
    <link href="http://yuhan.com/2017/06/27/web-security-csrf/"/>
    <id>http://yuhan.com/2017/06/27/web-security-csrf/</id>
    <published>2017-06-27T07:26:54.000Z</published>
    <updated>2017-06-27T08:49:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端面试过程中遇到的另一个最多的问题就是web安全了，之前博客有分享过XSS攻击的内容，这次聊聊CSRF攻击。CSRF是一种常见的攻击，但是也是web安全中最容易被忽略的一种攻击方式。</p>
<h1 id="什么是CSRF-跨站点请求伪造"><a href="#什么是CSRF-跨站点请求伪造" class="headerlink" title="什么是CSRF(跨站点请求伪造)"></a>什么是CSRF(跨站点请求伪造)</h1><p>根据字面意思，大概能猜到，CSRF攻击就是攻击者伪造了用户的请求，在用户不知道的情况下，以用户的名义向服务器发送恶意请求。常见的场景是，用户首先登陆一个正常（下面称为被攻击网站）的网站，攻击者诱使用户在不关闭被攻击网站的同时打开攻击者的页面，这时攻击者就可以以用户的名义给被攻击网站发送恶意请求了。可以看出CSRF是有条件的，首先用户要登陆被攻击网站，并生成Cookie，然后在不登出被攻击网站的同时，访问攻击网站。这两个条件缺一不可。</p>
<h1 id="CSRF进阶"><a href="#CSRF进阶" class="headerlink" title="CSRF进阶"></a>CSRF进阶</h1><h2 id="浏览器Cookie策略"><a href="#浏览器Cookie策略" class="headerlink" title="浏览器Cookie策略"></a>浏览器Cookie策略</h2><p>CSRF之所以能成功，主要还是因为用户的浏览器成功发送了Cookie的缘故。浏览器所持有的Cookie分为两种：一种是“Session Cookie”，又叫“临时Cookie”；另一种是“Third-party Cookie”，也称为“本地Cookie”。<br>Third-party Cookie，服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，而Session Cookie则没有指定Expire时间，浏览器关闭后就失效了。如果浏览器从一个域的页面中，要加载另一个域的资源，由于安全原因，某些浏览器会阻止Third-party Cookie的发送。由于新打开的页面和原来的页面在同一个浏览器进程中，所以Session Cookie将会被发送。</p>
<p>IE浏览器处于安全考虑是禁止浏览器在&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt;、&lt;link&gt;等标签中发送第三方Cookie的。当前的主流浏览器中，默认会拦截Third-party Cookie的有：IE6~8、Safari，不会拦截的有：Firefox、Opera、Chrome等。</p>
<h2 id="只有GET请求么？"><a href="#只有GET请求么？" class="headerlink" title="只有GET请求么？"></a>只有GET请求么？</h2><p>在CSRF攻击流行之初，有一种错误的观点认为CSRF攻击只能由GET发起，这种错误观点的形成原因是大多数CSRF攻击发起时，使用的HTML标签都是&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt;等带src属性的标签，这列标签只能够发起一次GET请求，而不能发起POST请求。然而，对于攻击者来说，有若干种方法可以构造出一个POST请求。最简单的方法就是在一个页面中构造好一个form表单，然后使用javascript自动提交这个表单。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.a.com/register"</span> <span class="attr">id</span>=<span class="string">"register"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">"register"</span>);</div><div class="line">    f.inputs[<span class="number">0</span>].value = <span class="string">"test"</span>;</div><div class="line">    f.inputs[<span class="number">1</span>].value = <span class="string">"passwd"</span>;</div><div class="line">    f.submit();</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h1><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>验证码是对抗CSRF攻击最简单有效地防御方法。CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码则强制用户必须与应用进行交互，才能完成最终请求。<br>但是验证码并不是万能的，我们不可能给页面的所有操作都加上验证码。</p>
<h2 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h2><p>Referer Check在互联网中最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的源。</p>
<h2 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h2><p>CSRF攻击存在的本质原因还是网页中重要操作的所有参数都是可以被攻击者猜测到的。攻击者只有预测出url所有参数与参数值，才能成功地构造一个伪造的请求。所以我们可以通过把参数加密，或者使用一些随机数，从而让攻击者无法猜测到参数值。<br>我们可以给请求新增加一个token，这个token值是随机的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)]</div></pre></td></tr></table></figure></p>
<p>由于token的存在，攻击者就无法再构造出一个完整的url来实施CSRF攻击了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端面试过程中遇到的另一个最多的问题就是web安全了，之前博客有分享过XSS攻击的内容，这次聊聊CSRF攻击。CSRF是一种常见的攻击，但是也是web安全中最容易被忽略的一种攻击方式。&lt;/p&gt;
&lt;h1 id=&quot;什么是CSRF-跨站点请求伪造&quot;&gt;&lt;a href=&quot;#什么是CS
    
    </summary>
    
      <category term="web安全" scheme="http://yuhan.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://yuhan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之前端性能优化总结</title>
    <link href="http://yuhan.com/2017/06/23/high-performance-website-construction/"/>
    <id>http://yuhan.com/2017/06/23/high-performance-website-construction/</id>
    <published>2017-06-23T02:13:34.000Z</published>
    <updated>2017-07-06T02:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>距上次写博客已经有三个多月的时间了，三四月份一直在忙着找实习，期间还在和同学一起合作项目，五六月份时间基本都花在了项目上，本来就很懒的我，也就懒得写博客了。现在项目总算是要上线了，还是想继续把自己的博客维护下去。最近几篇文章，准备分享找实习和项目相关的，也希望大家多多支持我和同学一起合作的项目，也算是一个创业项目哈。</p>
<p>找实习期间还是面试了很多家公司的，基本大型的互联网公司都有面试过，有一个问题是每次面试官都会问到的，那就是前端的性能优化，所以就总结一下，以备9月份的校招。这些规则呢主要是来自《高性能网站建设指南》这本书，然后雅虎军规加以补充。</p>
<h1 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a>减少http请求</h1><p>学过计算机网络的同学应该都知道，http请求需要进行三次握手，这是很费时间的。通过查看流量也可以发现，大部分的时间都花在了为html文档所引用的所有组件进行的http请求上。因此减少http请求可以提高网站性能。</p>
<h2 id="图片地图"><a href="#图片地图" class="headerlink" title="图片地图"></a>图片地图</h2><p>这个我实际用的比较少，就是在一个图片上关联多个url。</p>
<h2 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h2><p>中文叫雪碧图，将多个图片合并到一个单独的图片中。如果用作背景图片，可以根据background-position来定位背景，这样需要很多张背景图片现在就只需要一张了。也就是本来需要发送多次http请求来请求图片现在只需要发送一次就可以了。</p>
<h2 id="内联图片"><a href="#内联图片" class="headerlink" title="内联图片"></a>内联图片</h2><p>通过编码的字符串将图片内嵌到网页文本中。通过使用data: URL模式可以在web页面中包含图片但无需额外的http请求。</p>
<h2 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h2><p>将多个js脚本文件打包成一个文件，将多个css样式表打包成一个样式表。如果分成多个小文件，每个文件都会导致一个额外的http请求。</p>
<h1 id="使用内容发布网络（CDN）"><a href="#使用内容发布网络（CDN）" class="headerlink" title="使用内容发布网络（CDN）"></a>使用内容发布网络（CDN）</h1><p>内容发布网络是一组分布在多个不同地理位置的web服务器，用于更加有效地向用户发布内容。在优化性能时，向特定用户发布内容的服务器的选择基于对网络可用度的测量。例如，CDN可能选择网络阶数最小的服务器，或者具有最短响应时间的服务器。这样就能减短网络请求的时间。</p>
<h1 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h1><p>添加Expires头可以最大化地利用浏览器的缓存能力来改善页面的性能。通过使用一个长久的Expires头，使组件被缓存，可以在后续的页面浏览中避免不必要的http请求。<br>web服务器使用Expires头来告诉web客户端它可以使用一个组件的当前副本，直到指定时间为止。</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>Expires头有一定的限制，就是要求服务器和客户端的时钟严格同步，另外，过期日期需要经常检查。HTTP 1.1引入了Cache-Control头来克服Expires头的限制。Cache-Control可以重写Expires头。</p>
<h1 id="压缩组件"><a href="#压缩组件" class="headerlink" title="压缩组件"></a>压缩组件</h1><p>压缩组件可以减小http响应的大小，进而减少响应时间。如果http请求产生的响应包很小，传输时间就会减少。</p>
<h1 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h1><p>将样式表放在文档底部会导致在浏览器中阻止内容逐步呈现，将样式表放在顶部会显得加载速度更快，这样可以是浏览器逐步呈现已经下载的网页内容。对于内容比较多的网页尤其重要，用户不用一直等待一个白屏的页面，而是可以先看已经下载的内容。</p>
<h1 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h1><p>在使用样式表时，页面逐步呈现会被阻止，直到所有的样式表下载完成。将样式表移到head中，就能首先下载样式表而不会阻止页面呈现。使用脚本时，所有位于脚本以下的内容，逐步呈现都会被阻塞，将脚本放在页面越靠下的位置，意味着越多的内容能够逐步地呈现。</p>
<h1 id="避免CSS表达式"><a href="#避免CSS表达式" class="headerlink" title="避免CSS表达式"></a>避免CSS表达式</h1><p>css表达式的问题在于对其进行求值的频率比我们期望的要高。不只是在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上移过时都要求值。</p>
<h1 id="使用外部JavaScript和CSS"><a href="#使用外部JavaScript和CSS" class="headerlink" title="使用外部JavaScript和CSS"></a>使用外部JavaScript和CSS</h1><p>纯粹而言，内联的js和css可以产生比外部文件更快的响应速度，因为外部文件需要承担多个http请求带来的开销。尽管如此，现实中还是使用外部文件会产生较快的页面，因为外部文件有机会被浏览器缓存起来。html文档通常不会配置为可以缓存的。</p>
<h1 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h1><p>Internet是通过ip地址来查找服务器的，由于IP地址很难记忆，通常使用url代替，但是当浏览器发送http请求时还是需要ip地址，DNS就是用来将url映射到ip地址上的。DNS查找当然也是有开销的，通常要花费20-120毫秒。在DNS查找完成之前，浏览器不能从主机名那下载到任何内容。</p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>DNS查找可以被缓存起来以提高查找性能，通常浏览器和用户主机都会进行DNS缓存。</p>
<h2 id="减少DNS查找-1"><a href="#减少DNS查找-1" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>DNS查找的数量与页面中唯一主机名的数量相等，包括页面url、图片、脚本文件、样式表、Flash对象等的主机名。减少唯一主机名的数量就可以减少DNS查找的数量。</p>
<h1 id="精简JavaScript"><a href="#精简JavaScript" class="headerlink" title="精简JavaScript"></a>精简JavaScript</h1><p>精简，就是从代码中移除不必要的字符以减小其大小，进而改善页面加载时间。同样，css文件也可以进行精简。压缩同时也可以减小所需要请求文件的大小，进而加快文件的请求。</p>
<h1 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h1><p>重定向是将用户从一个url重新路由到另一个url，重定向会使页面加载变慢。</p>
<h1 id="移除重复脚本"><a href="#移除重复脚本" class="headerlink" title="移除重复脚本"></a>移除重复脚本</h1><p>在一个页面中两次包含同样的一个js文件会损伤性能。一个大型的网站可能是多人协作或者多团队协作的，这样脚本被重复添加是很可能发生的事情。重复的脚本会增加不必要的http请求和浪费执行js所用的时间，这样会损伤页面性能，所以需要避免使用同样的脚本。</p>
<h1 id="配置ETag"><a href="#配置ETag" class="headerlink" title="配置ETag"></a>配置ETag</h1><p>当网站被宿主在多于一台服务器上时，ETag头可能会阻碍缓存。当浏览器从一台服务器上获取原始组件，之后，又向另外一台不同的服务器发起条件GET请求时，ETag是不会匹配的，而对于使用服务器集群来处理请求的网站来说，这是很常见的一种情况。所以需要对ETag进行配置，以利用其灵活的验证能力。</p>
<h1 id="雅虎军规补充"><a href="#雅虎军规补充" class="headerlink" title="雅虎军规补充"></a>雅虎军规补充</h1><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>延迟加载需要知道网页最初加载需要的最小内容集是什么。剩下的内容就可以延迟加载了。</p>
<h2 id="提前加载"><a href="#提前加载" class="headerlink" title="提前加载"></a>提前加载</h2><p>与延迟加载目的相反，提前加载的是为了提前加载接下来网页中要访问的资源。</p>
<h2 id="减少DOM元素数量"><a href="#减少DOM元素数量" class="headerlink" title="减少DOM元素数量"></a>减少DOM元素数量</h2><p>网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500个元素和5000个元素在加载速度上会有很大差别。所以减少DOM元素数量是十分有必要的。</p>
<h2 id="减少DOM操作"><a href="#减少DOM操作" class="headerlink" title="减少DOM操作"></a>减少DOM操作</h2><p>通过js访问DOM元素没有我们想象中快，元素多的网页尤其慢，利用js对DOM的访问时要注意:</p>
<ol>
<li>缓存已经访问过的元素</li>
<li>Offline更新节点然后再加回DOM Tree</li>
<li>避免通过Javascript修复layout</li>
</ol>
<h2 id="根据域名划分内容"><a href="#根据域名划分内容" class="headerlink" title="根据域名划分内容"></a>根据域名划分内容</h2><p>浏览器一般对同一个域的下载链接数有所限制，按照域名划分下载内容可以增大浏览器并行下载数量，但是也不能盲目增加域名，这样会增加DNS查找的负担。</p>
<h2 id="减少iframe负担"><a href="#减少iframe负担" class="headerlink" title="减少iframe负担"></a>减少iframe负担</h2><p>iframe会阻止页面的加载，而且即使iframe内容为空也会消耗时间，所以尽量避免使用iframe。</p>
<h2 id="使用Ajax-GET请求"><a href="#使用Ajax-GET请求" class="headerlink" title="使用Ajax GET请求"></a>使用Ajax GET请求</h2><p>浏览器在实现XMLHttpRequest POST的时候会分成两步，先发送header，然后再发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。</p>
<h2 id="避免空的图片src"><a href="#避免空的图片src" class="headerlink" title="避免空的图片src"></a>避免空的图片src</h2><p>空的图片src仍然会使浏览器发送请求到服务器，这样完全是不必要的浪费。</p>
<h2 id="用代替-import"><a href="#用代替-import" class="headerlink" title="用代替@import"></a>用<link>代替@import</h2><p>@import相当于将css放在网页内容底部。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距上次写博客已经有三个多月的时间了，三四月份一直在忙着找实习，期间还在和同学一起合作项目，五六月份时间基本都花在了项目上，本来就很懒的我，也就懒得写博客了。现在项目总算是要上线了，还是想继续把自己的博客维护下去。最近几篇文章，准备分享找实习和项目相关的，也希望大家多多支持我
    
    </summary>
    
      <category term="面试" scheme="http://yuhan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yuhan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="性能" scheme="http://yuhan.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现排序算法</title>
    <link href="http://yuhan.com/2017/03/02/sorting-with-javascript/"/>
    <id>http://yuhan.com/2017/03/02/sorting-with-javascript/</id>
    <published>2017-03-02T05:55:38.000Z</published>
    <updated>2017-03-04T12:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法主要用在元素的数组排序，常见的排序算法有冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序等。这些排序算法都可以用JavaScript实现。下面的排序算法都假设是从小到大进行排序，从大到小可以相应进行转化。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的基本思想是从头遍历要排序的数组，比较相邻两个数，如果前面位置的数大于后面位置的数，那么就将两者进行交换，否则不做任何操作。遍历完一次之后，最大的数就放到了数组最后的位置。然后再从头遍历数组，进行同样的操作，就可以将第二大的数放到倒数第二个位置，依此进行下去，直到所有数都排好位置为止。冒泡排序的代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">functon bubbleSort(arr) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length<span class="number">-1</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length<span class="number">-1</span>-i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                <span class="comment">// 交换位置</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j];</div><div class="line">                arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">                arr[j+<span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>冒泡排序平均时间复杂度为O(n^2),而且是一种稳定的排序算法。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的基本思想是先找到数组中最小的元素，将它和数组的第一个元素交换位置，再找到数组中第二小的元素，将它和数组的第二个元素交换位置，依次进行下去，直到整个数组排好序为止。选择排序代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">functon selectSort(arr) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length<span class="number">-1</span>; i++) &#123;</div><div class="line">        <span class="keyword">var</span> min = arr[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</div><div class="line">                <span class="keyword">var</span> temp = min;</div><div class="line">                min = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">            arr[i] = min;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选择排序的时间复杂度为O(n^2),而且是一个不稳定的排序算法。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的基本思想是将一个记录（数）插入到已排好序的有序数列中的适当位置。插入排序的代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> key = arr[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; key) &#123;</div><div class="line">                arr[j + <span class="number">1</span>] = arr[j];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                arr[j + <span class="number">1</span>] = key;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入排序的时间复杂度为O(n^2),而且是一个稳定的排序算法。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序又称“缩小增量排序”，是在直接插入排序算法上进行改进的，它的基本思想是先将整个待排序序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。因为插入排序在对几乎已经排好序的数据操作时，效率高。<br>希尔排序的步骤是：首先取一个小于序列长度的整数d1作为增量，对序列从头开始把所有距离为d的元素放在同一个分组中，现在各组内进行直接插入排序；然后去第二个增量d2（小于d1），进行同样的操作，直到增量为1，即对已经基本有序的序列进行插入排序。希尔排序代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr, dk</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> d = dk/<span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = d; j &lt; n; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-d]) &#123;</div><div class="line">                <span class="keyword">var</span> temp = arr[j];</div><div class="line">                <span class="keyword">var</span> k = j - d;</div><div class="line">                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; temp) &#123;</div><div class="line">                    arr[k + d] = arr[k];</div><div class="line">                    k -= d;</div><div class="line">                &#125;</div><div class="line">                arr[k + d] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>希尔排序的时间复杂度为O(n^3/2),而且是一个不稳定的排序算法。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种分而治之的算法，它是冒泡排序的改进，基本思想是通过一趟排序将待排序列分割成独立的两部分，其中一部分的值都要比另一部分的值小，再分别对这两部分继续进行排序，直到整个序列有序。<br>快速排序的步骤是：首先从序列中选择一个基准元素，假设为第一个元素，将列表分成两部分，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面，再分别对这两部分重复上面的步骤即可。代码首先如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// key为基准值序号</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">var</span> low = [];</div><div class="line">        <span class="keyword">var</span> high = [];</div><div class="line">        <span class="keyword">var</span> pivotkey = arr[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt;= pivotkey) &#123;</div><div class="line">                low.push(arr[i]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                high.push(arr[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> quickSort(low).concat(pivotkey, quickSort(high));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序的时间复杂度为O(nlogn),而且是一个不稳定的排序算法。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并的含义是将两个或两个以上的有序表组合成一个新的有序表。假设初始序列长度为n，首先，每个子序列的长度为1，然后前后两两归并。得到若干个长度为2或者1的子序列，再两两归并，如此重复，直至得到一个长度为n的的有序序列为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法主要用在元素的数组排序，常见的排序算法有冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序等。这些排序算法都可以用JavaScript实现。下面的排序算法都假设是从小到大进行排序，从大到小可以相应进行转化。&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yuhan.com/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://yuhan.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学前端半年来我读过哪些书</title>
    <link href="http://yuhan.com/2017/01/11/books/"/>
    <id>http://yuhan.com/2017/01/11/books/</id>
    <published>2017-01-11T06:50:16.000Z</published>
    <updated>2017-01-12T00:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼已经2017年了，我2016年4月份开始接触前端，到现在也有大半年了，马上就要过年了，准备好好休息休息，就想着把这大半年所读的前端书籍整理一下，顺便制定一下年后的学习计划。有些书看了很久也不记得多少了，年后还得再好好回味一遍。</p>
<h1 id="我看了哪些书"><a href="#我看了哪些书" class="headerlink" title="我看了哪些书"></a>我看了哪些书</h1><h2 id="HTML相关书籍"><a href="#HTML相关书籍" class="headerlink" title="HTML相关书籍"></a>HTML相关书籍</h2><ol>
<li>Head First HTML5 Programming</li>
<li>Head First HTML and CSS</li>
</ol>
<p>这两本书通俗易懂，是我刚开始学前端时看的，入门强推哦。</p>
<h2 id="CSS相关书籍"><a href="#CSS相关书籍" class="headerlink" title="CSS相关书籍"></a>CSS相关书籍</h2><ol>
<li>CSS权威指南</li>
<li>CSS揭秘</li>
</ol>
<p>CSS权威指南是CSS入门书籍，CSS看的书不太多，我时间真的不够啊，每天还有电视剧要追，还要时不时锻炼身体怕猝死，还不敢熬夜太晚怕长痘，想哭。</p>
<h2 id="JavaScript相关书籍"><a href="#JavaScript相关书籍" class="headerlink" title="JavaScript相关书籍"></a>JavaScript相关书籍</h2><ol>
<li>JavaScript DOM编程艺术</li>
<li>JavaScript高级程序设计</li>
<li>JavaScript语言精粹</li>
<li>JavaScript设计模式</li>
<li>ES6标准入门</li>
</ol>
<p>《Javascript DOM编程艺术》是我看的第一本关于JavaScript的书，这本书讲了一个网站从简单到复杂是怎么一步步完成的，适合入门，但不能止步于此哦。这两周我抽出时间把《JavaScript高级程序设计》又看了一遍，对JavaScript又有了进一步的理解。《JavaScript语言精粹》这本书看的时候对JavaScript的理解还不够，看的云里雾里，过完年打算再看一遍。《JavaScript设计模式》这本书之前有总结过，可参考我博客：<a href="http://hyuhan.com/2016/12/23/javascript-design-patterns/" target="_blank" rel="external">《JavaScript设计模式》读后感 觉很复杂</a>。</p>
<p>学习JavaScript还推荐codecademy这个网站上面的课程，这也是之前知乎上看别人推荐的。JQuery的学习嘛，并没有看书，看的都是网上的教程。</p>
<h2 id="Node-js相关书籍"><a href="#Node-js相关书籍" class="headerlink" title="Node.js相关书籍"></a>Node.js相关书籍</h2><ol>
<li>Nodejs开发实战详解</li>
<li>NodeJS实战</li>
<li>NodeJS开发指南</li>
<li>深入浅出nodejs</li>
</ol>
<p>自学前端真的很痛苦呐，木有啥项目，没有后台跟你联调，只能自己去学Node，什么都得自己弄。其实我并不想搞全栈啊，但是学了之后感觉真的挺有意思的，嘿嘿。前面三本书偏实战，比较好理解。《深入浅出nodejs》这本书自己还需要再看一遍，争取把里面的原理都弄懂。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>PhoneGap实战</li>
<li>白帽子讲Web安全</li>
<li>大型网站技术架构</li>
<li>图解HTTP</li>
<li>鸟哥的Linux私房菜（基础学习篇）</li>
</ol>
<p>《PhoneGap实战》这本书是7月份的时候自己练手做一个记事本app的时候学的。《大型网站技术架构》这本书强推，前端也需要了解一下这方面的知识。《HTTP权威指南》那本书实在是太厚了，我就看了《图解HTTP》这本书，嘻嘻。        </p>
<p>计算机基础课程本科的时候基本都学了，过完年准备把计算机网络、数据库和数据结构算法相关的再回顾一遍。</p>
<h2 id="Vue的学习"><a href="#Vue的学习" class="headerlink" title="Vue的学习"></a>Vue的学习</h2><p>Vue都是看官方文档学的，然后动手做小项目，项目中遇到问题再学习再理解。现在觉得没有人带我也不错，这段时间自学前端感觉自己独立解决问题的能力比以前真的强了很多很多。</p>
<h1 id="开年计划看的书"><a href="#开年计划看的书" class="headerlink" title="开年计划看的书"></a>开年计划看的书</h1><h2 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h2><ol>
<li>HTML5高级程序设计</li>
</ol>
<h2 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h2><ol>
<li>精通CSS：高级Web标准解决方案</li>
<li>CSS禅意花园</li>
</ol>
<h2 id="JavaScript相关书籍-1"><a href="#JavaScript相关书籍-1" class="headerlink" title="JavaScript相关书籍"></a>JavaScript相关书籍</h2><ol>
<li>JavaScript权威指南</li>
<li>你不知道的JavaScript</li>
<li>JavaScript设计模式与开发实践</li>
</ol>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Unix编程艺术</li>
<li>HTTP权威指南</li>
<li>程序员实用算法</li>
<li>程序员的数学</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在学习前端的大半年时间里，真的收获很多，最让我开心的是找到了一个自己喜欢的方向，不再像以前那样漫无目的，什么都懂一点但是什么都不精，想着以后能做自己喜欢的工作就很激动。我是2018届应届生，距离找工作还剩下半年时间了，这半年里要尽可能多的学习，找到一份自己心仪的工作。</p>
<p>每个月我都会给自己制定一个学习计划，目前我的学习计划已经制定到2017年6月份了，哈哈。如果能踏踏实实按照自己的计划走，我相信能找到一个不错的工作，加油！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼已经2017年了，我2016年4月份开始接触前端，到现在也有大半年了，马上就要过年了，准备好好休息休息，就想着把这大半年所读的前端书籍整理一下，顺便制定一下年后的学习计划。有些书看了很久也不记得多少了，年后还得再好好回味一遍。&lt;/p&gt;
&lt;h1 id=&quot;我看了哪些书&quot;&gt;&lt;
    
    </summary>
    
      <category term="总结" scheme="http://yuhan.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yuhan.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="书" scheme="http://yuhan.com/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript设计模式》读后感 觉很复杂</title>
    <link href="http://yuhan.com/2016/12/23/javascript-design-patterns/"/>
    <id>http://yuhan.com/2016/12/23/javascript-design-patterns/</id>
    <published>2016-12-23T12:23:51.000Z</published>
    <updated>2017-03-04T12:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触前端两三个月的时候，那时候只是听说设计模式很重要，然后我就去读了一本设计模式的书，读了一部分，也不知道这些设计模式到底设计出来干嘛的，然后就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有一些启发。于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事串起了一整本书，看了一部分发现原来我平时写代码的时候无意之中就用到了一些设计模式，然后就忍不住都看完了。看完整本书，让我完全改变了以前对设计模式的看法，也学到了很多在实际项目开发中的经验。这里就简单总结下这本书，也算是做个笔记，供自己以后参考。（定义一般都比较晦涩难懂，可以先看看使用场景再回来理解相关定义）<br>先给个书的链接: <a href="https://www.amazon.cn/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%A0%E5%AE%B9%E9%93%AD/dp/B013HO6DNS/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1482324196&amp;sr=1-2&amp;keywords=javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">JavaScript设计模式-张容铭</a></p>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是代码设计经验的总结，为了可重用代码，保证代码的可靠性等。设计模式主要分为三大类型，创建型模式，结构型模式和行为型模式，本书还额外写了另两类设计模式，技巧型模式和架构型模式。JavaScript设计模式是以面向对象编程为基础的，JavaScript的面向对象编程和传统的C++、Java的面向对象编程有些差别，这让我一开始接触JavaScript的时候感到十分痛苦，但是这只能靠自己慢慢积累慢慢思考。想继续了解JavaScript设计模式必须要先搞懂JavaScript面向对象编程，否则只会让你自己更痛苦。</p>
<h1 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h1><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。创建型设计模式主要有简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式和单例模式，下面一一道来。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>作者把简单工厂模式比喻成一个神奇的魔术师。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>看完上面的定义一定很不解，说的到底是啥，现在就举个例子来解释一下。比如体育商品店卖体育器材，里面有很多体育用品及其相关介绍。当你来到体育用品店买一个篮球，只需问售货员，他就会帮你找到你所要的东西。用程序实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 篮球基类</span></div><div class="line"><span class="keyword">var</span> Basketball = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intro = <span class="string">'篮球盛行于美国'</span>;</div><div class="line">&#125;;</div><div class="line">Basketball.prototype = &#123;</div><div class="line">    <span class="attr">getMember</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'每个队伍需要5名队员'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getBallSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'篮球很大'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 足球基类</span></div><div class="line"><span class="keyword">var</span> Football = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intro = <span class="string">'足球盛行于美国'</span>;</div><div class="line">&#125;;</div><div class="line">Football.prototype = &#123;</div><div class="line">    <span class="attr">getMember</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'每个队伍需要11名队员'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getBallSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'篮球很大'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 运动工厂</span></div><div class="line"><span class="keyword">var</span> SportsFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(name) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'NBA'</span>: </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Basketball();</div><div class="line">        <span class="keyword">case</span> <span class="string">'wordCup'</span>: </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Football();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当你使用这个运动工厂时只需要记住SportsFactory这个工厂对象就好了，它会帮你找到你想要的。<br>简单工厂模式的理念是创建对象，上面例子是将不同的类实例化，但是简单工厂模式还可以创建相似对象，将相似的东西提取，不相似的针对性处理即可。这样只需创建一个对象就可以替代多个类了。</p>
<h3 id="收获与总结"><a href="#收获与总结" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>团队开发不同于个人，对全局变量的限制很大，要尽量少得创建全局变量。如果有同一类对象在不同需求中重复使用，那么大部分是不需要重复创建的，要学会代码复用。用简单工厂来创建对象，可以减少全局变量创建提高代码复用率，它的使用场合限制在创建单一对象。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>作者把工厂方法模式比喻成一张名片。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际开发中，需求的变更是很正常的，开始需求简单可以直接创建对象，类似的需求多了可以用简单工厂方法重构，但是如果需求不停变化，那么不仅要修改工厂函数还要添加类，这样就没完了。而工厂方法模式本意是将实际创建对象的工作推迟到子类中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 工厂类</span></div><div class="line"><span class="keyword">var</span> Factory = <span class="function"><span class="keyword">function</span>(<span class="params">type, content</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Factory) &#123;</div><div class="line">        <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="keyword">this</span>[type](content);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 防止使用者不知道这是一个类，忘了加new操作符创建，导致全局变量污染</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Factory(type, content);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Factory.prototype = &#123;</div><div class="line">    <span class="attr">Java</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">JavaScript</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">php</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样以后如果想添加其他类，只需要在Factory的原型里添加就可以了。</p>
<h3 id="收获与总结-1"><a href="#收获与总结-1" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>对于创建很多类的对象，简单工厂模式就不适合了，通过工厂模式可以轻松创建多个类的实例对象，而且避免了使用者与对象类之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式让你感觉出现的都是幻觉。</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责某一类产品的实例。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种声明但不能使用的类，当你使用的时候就会报错。JavaScript中的抽象类不能像传统面向对象语言那样轻松地创建，我们可以在类的方法中手动抛出错误来模拟抽象类。你可能会想，这样的类什么都不能做能有什么用？其实它在继承上是很有用的。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>抽象工厂模式不能用来创建具体对象，一般用它作为父类类创建一些子类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象工厂方法</span></div><div class="line"><span class="keyword">var</span> VehicleFactory = <span class="function"><span class="keyword">function</span>(<span class="params">subType, superType</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断抽象工厂中是否有该抽象类</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="comment">// 缓存类</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">        <span class="comment">// 继承父类属性和方法</span></div><div class="line">        F.prototype = <span class="keyword">new</span> VehicleFactory[superType]();</div><div class="line">        <span class="comment">// 将子类构造函数指向子类</span></div><div class="line">        subType.constructor = subType;</div><div class="line">        <span class="comment">// 子类原型继承父类</span></div><div class="line">        subType.prototype = <span class="keyword">new</span> F();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不存在该抽象类抛出错误</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'未创建该抽象类'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 小汽车抽象类</span></div><div class="line">VehicleFactory.Car = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">'car'</span>;</div><div class="line">&#125;;</div><div class="line">VehicleFactory.Car.prototype = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 公交车抽象类</span></div><div class="line">VehicleFactory.Bus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">'bus'</span>;</div><div class="line">&#125;;</div><div class="line">VehicleFactory.Bus.prototype = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>抽象工厂实际上是一个子类继承父类的方法，在该方法中需要通过传递子类以及继承父类的名称。</p>
<h3 id="收获与总结-2"><a href="#收获与总结-2" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式。该模式创建出的结果不是一个真实的对象实例，而是一个类簇，指定了类的结构。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式告诉我们分即是合。</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>现在有一个发布简历的需求，就是帮别人在公司网站上发布简历，但是这些简历有一个需求，除了将兴趣爱好以及一些特长发布在页面里，其他信息如联系方式等不要发布在网站上，而且每个人想找的工作是可以分类的。这样一些需求我们需要创建的东西就多了，这时候前面的三种工厂模式都不适合了，这里就可以用建造者模式。<br>建造者模式和只关心创建结果的工厂模式不同，虽然其目的也是创建一个对象，但是更多关心的是创建这个对象的整个过程。在本例中，我们需要的不仅仅是应聘者的实例还要在创建过程中注意这位应聘者有哪些兴趣爱好等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一位人类</span></div><div class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="comment">// 技能</span></div><div class="line">    <span class="keyword">this</span>.skill = param &amp;&amp; param.skill || <span class="string">'保密'</span>;</div><div class="line">    <span class="comment">// 兴趣爱好</span></div><div class="line">    <span class="keyword">this</span>.hobby = param &amp;&amp; param.hobby || <span class="string">'保密'</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 类人原型方法</span></div><div class="line">Human.prototype = &#123;</div><div class="line">    <span class="attr">getSkill</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.skill;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getHobby</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例化姓名类</span></div><div class="line"><span class="keyword">var</span> Named = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 构造器，解析姓名的姓与名</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">name, that</span>) </span>&#123;</div><div class="line">        that.wholeName = name;</div><div class="line">        <span class="keyword">if</span>(name.indexOf(<span class="string">' '</span>) &gt; <span class="number">-1</span>) &#123;</div><div class="line">            that.FirstName = name.slice(<span class="number">0</span>, name.indexOf(<span class="string">' '</span>));</div><div class="line">            that.FirstName = name.slice(name.indexOf(<span class="string">' '</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;)(name, that);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例化职位类</span></div><div class="line"><span class="keyword">var</span> Work = <span class="function"><span class="keyword">function</span>(<span class="params">work</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 构造器，通过传入的职位特征来设置相应职位及描述</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">work, that</span>) </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(work) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'code'</span>:</div><div class="line">                that.work = <span class="string">'工程师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'UI'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'UE'</span>:</div><div class="line">                that.work = <span class="string">'设计师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'teach'</span>:</div><div class="line">                that.work = <span class="string">'教师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                that.work = work;</div><div class="line">        &#125;</div><div class="line">    &#125;)(work, that);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 更换期望的职位</span></div><div class="line">Work.prototype.changeWork = <span class="function"><span class="keyword">function</span>(<span class="params">work</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.work = work;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面来创建一位应聘者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 应聘者创建类</span></div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, work</span>) </span>&#123;</div><div class="line">    <span class="comment">// 创建应聘者缓存对象</span></div><div class="line">    <span class="keyword">var</span> _person = <span class="keyword">new</span> Human();</div><div class="line">    <span class="comment">// 创建应聘者姓名解析对象</span></div><div class="line">    _person.name = <span class="keyword">new</span> Named(name);</div><div class="line">    <span class="comment">// 创建应聘者期望职位</span></div><div class="line">    _person.work = <span class="keyword">new</span> Work(work);</div><div class="line">    <span class="comment">// 返回创建的应聘者对象</span></div><div class="line">    <span class="keyword">return</span> _person;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-3"><a href="#收获与总结-3" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>建造者模式和前面几种创建型设计模式不同，它关心对象的整个创建过程，因此通常将创建对象的类模块化，这样使创建类的每一个模块都可以得到灵活的运用与高质量的复用。这种方式对于整个对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低，不建议使用建造者模式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是JavaScript语言之魂。</p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>还是关于子类继承父类的问题，为了提高性能，对于每次创建的一些简单的而又有差异化的属性可以放在构造函数中，将一些消耗资源比较大的方法放在基类的原型中，这样就可以避免不必要的消耗，这就是原型模式的雏形。<br>原型模式更多的是用在对象的创建上，比如创建一个实例对象的构造函数比较复杂或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，可以通过对这些对象属性或者方法进行复制来实现创建。首先要有一个原型对象的复制方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型对象复制方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototypeExtend</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        args = <span class="built_in">arguments</span>,</div><div class="line">        i = <span class="number">0</span>,</div><div class="line">        len = args.length;</div><div class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</div><div class="line">        <span class="comment">// 遍历每个模板对象中的属性</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">in</span> args[i]) &#123;</div><div class="line">            F.prototype[j] = args[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回缓存类实例</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>企鹅游戏中创建一个企鹅对象，如果没有企鹅基类，只提供了一些动作模板对象，可以通过实现这些模板对象的继承来创建一个企鹅实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> penguin = prototypeExtend(&#123;</div><div class="line">    <span class="attr">speed</span>: <span class="number">20</span>,</div><div class="line">    <span class="attr">swim</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'游泳速度'</span> + <span class="keyword">this</span>.speed);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">run</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'奔跑速度'</span> + <span class="keyword">this</span>.speed);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样通过prototypeExtend创建的就是一个对象，不用再用new去创建一个新的实例对象。</p>
<h3 id="收获与总结-4"><a href="#收获与总结-4" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>原型模式实际上也是一种继承，可以让多个对象分享同一个原型对象的属性和方法，这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象。原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>哈哈，让你感受下一个人的寂寞。</p>
<h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>又被称为单体模式，只允许实例化一次的对象类。有时也可以用一个对象来规划一个命名空间，井井有条地管理对象上的属性和方法。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>单例模式应该是JavaScript中最常见的一种设计模式了，经常为我们提供一个命名空间，来防止不同的人命名变量的冲突。还可以用它来创建一个小型的代码库。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = &#123;</div><div class="line">    <span class="attr">Util</span>: &#123;</div><div class="line">        <span class="attr">util_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">util_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Tool</span>: &#123;</div><div class="line">        <span class="attr">tool_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">tool_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Ajax</span>: &#123;</div><div class="line">        <span class="attr">ajax_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">ajax_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想使用这个代码库，像下面这样访问即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.Util.util_method1();</div><div class="line">A.Tool.tool_method2();</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-5"><a href="#收获与总结-5" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>单例模式有时也被称为单体模式，它是只允许实例化一次的对象类，有时这么做也是为了节省系统资源。JavaScript中单例模式经常作为命名空间对象来实现，通过单例对象，我们可以将各个模块的代码井井有条地梳理在一起。</p>
<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计。主要有外观模式，适配器模式，代理模式，装饰者模式，桥接模式，组合模式和享元模式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>作者把这种模式比喻成一种套餐服务。</p>
<h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更加容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>
<h3 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h3><p>为页面文档document对象添加点击事件时，如果直接用onclick来绑定事件，那么如果团队中再有人要为document绑定click事件时，就会把之前绑定的那个时间覆盖，因为这是DOM0级事件。我们应该用DOM2级事件处理程序提供的addEventListener来实现，然而老版本IE是不支持这个方法的，必须用attachEvent，这样如果我们写一个能兼容所有浏览器的方式操作起来就会更方便，这时候就可以用到外观模式。为功能统一但方法不统一的接口提供一个统一的接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 外观模式实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">dom, type, fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// 对于支持DOM2级事件处理程序的浏览器</span></div><div class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</div><div class="line">        dom.addEventListener(type, fn, <span class="literal">false</span>);</div><div class="line">    <span class="comment">// 对于不支持addEventListener但支持attachEvent的浏览器</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</div><div class="line">        dom.attachEvent(<span class="string">'on'</span> + type, fn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dom[<span class="string">'on'</span> + type] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解决浏览器兼容问题只是外观模式应用的一部分，很多代码库中都是通过外观模式来封装多个功能，简化底层造作方法的。</p>
<h3 id="收获与总结-6"><a href="#收获与总结-6" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用及其复杂。通过外观模式，对接口进行二次封装可以隐藏其复杂性。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>听到这个模式的名字，有没有想到水管弯弯的场景呢？</p>
<h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>将一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>
<h3 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h3><p>公司有个活动页面正在使用公司内部开发的A框架，可是很多新来的同事使用A框架开发新的功能需求时总是感觉很吃力，而且能用的方法有限，为了让新同事尽快融入项目的开发，可以引入jQuery框架，由于A框架和jQuery框架很像，这样就可以写一个适配器而不需要将之前的代码全用jQuery写一遍。<br>适配器模式不仅在编程中很常见，在生活中这种模式也很常见，比如三角插头充电器对于两项插头是不能用的，此时就需要一个三项转两项插头电源适配器，这就是一种适配器模式，其实它就是为了两个代码库所写的代码兼容运行而书写的额外代码。<br>JavaScript中适配器模式还能适配两个代码库，适配参数，适配数据，适配服务端数据等。以参数适配为例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">name, title, age, color, size, prize</span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>记住这些参数的顺序是很困难的，所以我们经常是以一个参数对象方式传入的，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * obj.name: name</div><div class="line"> * obj.title: title</div><div class="line"> * obj.age: age</div><div class="line"> * obj.color: color</div><div class="line"> * obj.size: size</div><div class="line"> * obj.prize: prize</div><div class="line">***/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">obj</span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>然而当调用的时候也不能确定传递的参数是否完整，如有一些必须得参数没有传入，一些参数有默认值等，这个时候就可以用适配器来适配传入的参数对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _adapter = &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">'雨夜清荷'</span>,</div><div class="line">        <span class="attr">title</span>: <span class="string">'设计模式'</span>,</div><div class="line">        <span class="attr">age</span>: <span class="number">24</span>,</div><div class="line">        <span class="attr">color</span>: <span class="string">'pink'</span>,</div><div class="line">        <span class="attr">size</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">prize</span>: <span class="number">50</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> _adapter) &#123;</div><div class="line">        _adapter[i] = obj[i] || _adapter[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-7"><a href="#收获与总结-7" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>JavaScript中的适配器更多应用在对象之间，为了使对象可用，通常会将对象拆分并重新包装，这样就要了解适配器对象的内部结构，这也是与外观模式的区别所在。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>有没有想到牛郎织女鹊桥相会的场景？</p>
<h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。</p>
<h3 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h3><p>跨域问题应该是使用代理模式解决的一个最典型的问题。由于用户模块上传的照片量越来越大，导致服务器需要将上传模块重新部署到另外一个域中，这就导致了跨域问题。我们可以将相册页面和上传模块所在的服务器抽象成两个对象，想让跨域两端的对象之间实现通信，就需要找个代理对象来实现他们之间的通信。<br>代理对象有很多种，简单一点的如img之类的标签通过src可以向其他域下的服务器发送请求。不过这类请求是get请求，是单向的，不会有响应数据。另外一种代理对象的形式是通过script标签。而我们需要的代理对象，是对页面与浏览器间通信的，JSONP就实现了一种代理模式。我们知道src属性可以实现get请求，因此可以在src指向的url地址上添加一些字段信息，服务器获取这些字段信息，相应生成一分内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 前端浏览器页面</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="comment">// 回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallBack</span>(<span class="params">res,req</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(res,req);</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost/test/jsonp.php?callback=jsonp CallBack&amp;data=getJsonPData"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 另一个域下的服务器请求接口</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/* 后端获取请求字段数据，并生成返回内容 */</span></div><div class="line">$data = $_GET[<span class="string">"data"</span>];</div><div class="line">$callback = $_GET[<span class="string">"callback"</span>];</div><div class="line"><span class="keyword">echo</span> $callback.<span class="string">"('success', '"</span>.$data.<span class="string">"')"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>这种方式可以想象成合理的一只小船，通过小船将你的请求发送给对岸，然后对岸的人们将数据放在小船里为你带回来。</p>
<h3 id="收获与总结-8"><a href="#收获与总结-8" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>代理模式除了在跨域问题中有很多应用外，有时对对象的实例化对资源的开销很大，如页面加载初期加载文件有很多，此时能够延迟加载一些图片对页面首屏加载时间收益是很大的，通过代理可以先加载预览图片然后再加载开销大的图片。<br>由此可见，代理模式可以解决系统之间耦合度以及系统资源开销大的问题，通过代理对象可以保护被代理对象，使被代理对象不受外界的影响。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>显然房子装修就是一种典型的装饰者模式。</p>
<h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>
<h3 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h3><p>静止是相对的，运动是绝对的，所以没有一成不变的需求。在实际项目开发中需求总在不断变化，当原有的功能已经不能满足用户的需求时，我们要做的就是在这个基础上添砖加瓦，设置新功能和属性来满足用户提出的需求，这就是装饰者模式要做的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 装饰者</span></div><div class="line"><span class="keyword">var</span> decorator = <span class="function"><span class="keyword">function</span>(<span class="params">input, fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// 获取事件源</span></div><div class="line">    <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(input);</div><div class="line">    <span class="comment">// 若事件源已经绑定事件</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> input.onclick === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="comment">// 缓存事件源原有回调函数</span></div><div class="line">        <span class="keyword">var</span> oldClickFn = input.onclick;</div><div class="line">        <span class="comment">// 为事件源定义新的事件</span></div><div class="line">        input.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 事件源原有回调函数</span></div><div class="line">            oldClickFn();</div><div class="line">            <span class="comment">// 执行事件源新增回调函数</span></div><div class="line">            fn();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        input.onclick = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-9"><a href="#收获与总结-9" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>除了装饰者模式，适配器模式也可以对原有对象进行扩展，所不同的是适配器进行扩展很多时候是对对象内部结构的重组，因此了解其自身结构是必须的。而装饰者模式对对象的扩展是一种良性扩展，不用了解其具体实现，只是在外部进行了一次封装扩展。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>作者把这种模式比喻成城市间的公路。</p>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>
<h3 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h3><p>有时候，页面中一些小小细节的改变常常因逻辑相似而导致大片臃肿的代码，让页面苦涩不堪。现在项目有一个需求，是要把页面上部的用户信息添加一些鼠标划过的特效，但是用户信息由很多小组件组成，对于用户名，鼠标划过直接改变背景色，但是像用户等级、用户消息这类部件只能改变里面的数字内容，处理逻辑不太一样。这样就需要写不少代码，但是又会感觉很冗余。这时候，我们首先要提取共同点，对想的抽象逻辑做抽象提取处理。<br>对于用户信息模块的每一部分鼠标滑过与鼠标离开两个事件的执行函数有很大一部分是相似的，比如它们都处理每个部件中的某个元素，它们都是处理元素的字体颜色和背景颜色。可以创建下面这样一个函数，解除this耦合。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">dom, color, bg</span>) </span>&#123;</div><div class="line">    <span class="comment">// 设置元素的字体颜色</span></div><div class="line">    dom.style.color = color;</div><div class="line">    <span class="comment">// 设置元素的背景颜色</span></div><div class="line">    dom.style.background = bg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是对具体元素绑定事件了，但是仅仅知道元素事件绑定与抽象提取的设置样式方法changeColor是不够的，需要用一个方法将他们链接起来，这个方法就是桥接方法，这种模式就是桥接模式。就像你开着车去沈阳，那么你就需要找到一条连接北京与沈阳的公路，才能顺利往返两地。<br>对于事件的桥接方法，可以用一个匿名函数来代替。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spans = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</div><div class="line">spans[<span class="number">0</span>].onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    changeColor(<span class="keyword">this</span>, <span class="string">'red'</span>, <span class="string">'#ddd'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-10"><a href="#收获与总结-10" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>桥接模式最主要的特点是将实现层（如元素绑定事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，桥接模式主要是对结构之间的解耦。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>作者把组合模式比喻成超值午餐，感觉很形象。</p>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层级结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h3 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h3><p>为强化首页用户体验，项目经理准备在用户首页添加一个新闻模块，当然新闻的内容是根据用户平时关注的内容挖掘的，因此有的人可能会显示文字新闻，有的人可能会是图片新闻等等。<br>我们先来仔细分析下这个需求，需求中的这些新闻大致可以分为相互独立的几种类型，对某类新闻做修改时不会影响到其他类的新闻，这样可以将每一类新闻抽象成面向对象编程中的一个类，然后在这些新闻类中挑选一些组合成需要的模块，这时候就可以用组合模式了。<br>在页面中，组合模式更常用在创建表单上，比如注册页面可能有不同的表单提交模块。对于这些需求，我们只需要有一个基本的个体，然后通过一定的组合即可实现。</p>
<h3 id="收获与总结-11"><a href="#收获与总结-11" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>组合模式能够给我们提供一个清晰的组成结构，组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了统一管理与使用。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>作者把享元模式比喻成城市公交车，可以仔细思考一番。</p>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>
<h3 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h3><p>现在有新闻的内容太多，我们有了一个分页显示所有新闻的需求。一个简单直观的做法就是页面加载后异步请求新闻数据，然后创建所有条新闻插入页面中，需要显示哪一页就显示哪一页。但是这样做有一个很大的问题，这样一下子创建几百条新闻同时插入页面会造成多页的开销严重影响网页的性能。这里的所有新闻都有相似的结构，只是内容不同罢了，对于这种相同结构造成多余开销的问题，可以用享元模式来解决。<br><strong>享元模式</strong> 主要是对其数据、方法共享分离，将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或共有的数据和方法，所以将其提取出来减少开销。上面例子中，所有新闻个体都有共同的结构，应该作为内部数据，而下一页按钮绑定的事件则是外部方法。同时为了使用内部数据还需要提供一个操作方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Flyweight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 已创建的元素</span></div><div class="line">    <span class="keyword">var</span> created = [];</div><div class="line">    <span class="comment">// 创建一个新闻包装容器</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">        <span class="comment">// 将容器插入新闻列表容器中</span></div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).appendChild(dom);</div><div class="line">        <span class="comment">// 缓存新创建的元素</span></div><div class="line">        created.push(dom);</div><div class="line">        <span class="comment">// 返回创建的新元素</span></div><div class="line">        <span class="keyword">return</span> dom;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 获取创建新闻元素方法</span></div><div class="line">        getDiv: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果已创建的元素小于当前页元素总个数(5个)，则创建</span></div><div class="line">            <span class="keyword">if</span>(created.length &lt; <span class="number">5</span>) &#123;</div><div class="line">                <span class="keyword">return</span> created();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 获取第一个元素，并插入去后面</span></div><div class="line">                <span class="keyword">var</span> div = created.shift();</div><div class="line">                created.push(div);</div><div class="line">                <span class="keyword">return</span> div;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面创建一个享元类，由于每页只能显示5条新闻，所以创建5个元素，保存在享元类内部，可以通过getDiv方法来获取创建的元素。下面就要实现外部数据和外部方法，外部数据就是我们要显示的所有新闻内容，由于每个内容都不一样肯定不能共享。首先，我们要根据新闻内容实例化页面，然后，对下一页绑定一个点击事件，显示下一页。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> paper = <span class="number">0</span>,</div><div class="line">    num = <span class="number">5</span>,</div><div class="line">    len = article.length;</div><div class="line"><span class="comment">// 添加五条新闻</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(article[i])</div><div class="line">        <span class="comment">// 通过享元类获取创建的元素并写入新闻内容</span></div><div class="line">        Flyweight.getDiv().innerHTML = article[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下一页按钮绑定事件</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'next_page'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果新闻内容不足5条则返回</span></div><div class="line">    <span class="keyword">if</span>(article.length &lt; <span class="number">5</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> n = ++paper * num % len,  <span class="comment">// 获取当前页的第一条新闻索引</span></div><div class="line">        j = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 插入5条新闻</span></div><div class="line">    <span class="keyword">for</span>(; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">        <span class="comment">// 如果存在n+j条则插入</span></div><div class="line">        <span class="keyword">if</span>(article[n + j]) &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = article[n + j];</div><div class="line">        <span class="comment">// 否则插入起始位置第n+j-len条</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(article[n + j - len]) &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = article[n + j - len];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样用享元模式对页面重构之后每次操作只需要操作5个元素，这样性能可以提高很多。</p>
<h3 id="收获与总结-12"><a href="#收获与总结-12" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>享元模式的应用是为了提高程序的执行效率与系统性能，因此在大型系统开发中应用比较广泛，可以避免程序中的数据重复。应用时一定要找准内部状态与外部状态，这样才能更合理地提取分离。</p>
<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。行为型设计模式主要有模板方法模式，观察者模式，状态模式，策略模式，职责链模式，命令模式，访问者模式，中介者模式，备忘录模式，迭代器模式和解释器模式，这么多的模式真得好好消化一阵子了。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>作者把这种模式比喻成照猫画虎。</p>
<h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类，使得子类可以不改变父类算法结构的同时可重新定义算法中某些实现步骤。</p>
<h3 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h3><p>提示框归一化，一个网站有很多页面，如果每个页面的弹出框样式不太一致就会显得不是很和谐，需要将他们的样式统一。新手最直观的想法就是去每个页面一个个修改，当然这样的代价是很大的，我们需要写一个弹出框插件，将这些弹出框封装好，然后再各个页面调用即可。这是在这个插件中就可以使用模板方法模式了，不需要重复写多个样式。<br>模板方法模式就是将多个模型抽象画归一，从中抽象出一个最基本的模板，这个模板可以作为实体也可以作为抽象对象，其他模块只需要继承这个模板方法，也可以扩展某些方法。<br>打个比方，我们生活中用蛋糕做模具做蛋糕，做出的蛋糕是外形相同的，因为他们都用同一个模具。然而商店里面卖的蛋糕是各式各样的，这都是对蛋糕的二次加工。我们的需求中基本提示框就是我们抽象出来的模具，其他提示框比这个提示框要多一些功能，我们只需要对他们做一些二次加工就能满足需求了。<br>模板方法不仅在归一化组件时使用，有时候创建页面时也是很常用的，比如创建三类导航，第一类是基础的，第二类是多了消息提醒功能的，第三类多了后面显示网址功能。这也可以用模板方法实现，此时抽象出来的基类是最简单的基础导航类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式化字符串方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formateString</span>(<span class="params">str, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\&#123;#(\w+)#\&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> data[key] === <span class="literal">undefined</span> ? <span class="string">''</span>: data[key]</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 基础导航</span></div><div class="line"><span class="keyword">var</span> Nav = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 基础导航样式模板</span></div><div class="line">    <span class="keyword">this</span>.item = <span class="string">'&lt;a href="&#123;#href#&#125;" title="&#123;#title#&#125;"&gt;&#123;#name#&#125;&lt;/a&gt;'</span>;</div><div class="line">    <span class="comment">// 创建字符串</span></div><div class="line">    <span class="keyword">this</span>.html = <span class="string">''</span>;</div><div class="line">    <span class="comment">// 格式化数据</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">this</span>.html += formateString(<span class="keyword">this</span>.item, data[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回字符串数据</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于消息提醒导航类，只需额外添加消息提醒组件模板，并与消息提醒组件模板对传入的网址数据进行装饰，得到所需的字符串，在调用从基类继承的方法处理这些字符串即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> NumNav = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 消息提醒信息组件模板</span></div><div class="line">    <span class="keyword">var</span> tpl = <span class="string">'&lt;b&gt;&#123;#num#&#125;&lt;/b&gt;'</span>;</div><div class="line">    <span class="comment">// 装饰数据</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        data[i].name += data[i].name + formateString(tpl, data[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 继承基础导航类</span></div><div class="line">    <span class="keyword">return</span> Nav.call(<span class="keyword">this</span>, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-13"><a href="#收获与总结-13" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>模板方法的核心在于对方法的重用，将核心方法封装在基类中，让子类继承基类的方法，实现基类方法的共享，达到方法共用。子类继承的方法是可扩展的，这就需要对基类继承的方法进行重写。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>作者把这种模式比喻成通信卫星。</p>
<h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>
<h3 id="使用场景-13"><a href="#使用场景-13" class="headerlink" title="使用场景"></a>使用场景</h3><p>在团队开发中，经常是一个人负责一个模块，那么每人负责的模块之间要如何进行沟通呢？比如你实现一些需求需要添加一些代码，但是这个需求需要其他模块配合，但是每个模块都是不同人写的，你不想因为新添加的代码影响到他人实现的功能，这个时候就需要用到观察者模式了。<br>观察者模式就是为了解决主体对象与观察者之间的耦合。打个比方，目前每个国家都在研发并发射卫星，发射这些卫星是为了监控一些信息，那么它就可以被看做一个观察者或者说是一个消息系统，如果让这颗卫星为飞机导航，那么这架飞机就是一个被观察者或者说是一个主体对象。那么如果地面上的中转站或者其他飞机需要知道这架飞机的信息，于是每当飞机到达一个地方时就会向卫星发出位子信息，然后卫星又将信息广播到已经订阅这架飞机的中转站，这样就可以避免一些飞机事故发生。<br>这时候，观察者至少需要有两个方法，一个是接收某架飞机发来的消息，一个是向订阅的中转站发送响应消息。但是，并不是每个中转站都要时刻监控飞机状态的，所以还需要一个取消注册的方法。当然这些消息还需要保存，就需要一个保存消息的容器。这时候观察者雏形就出来了，他有一个消息容器和三个方法，订阅消息方法，取消订阅消息方法，发送订阅消息方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Observer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 防止消息队列暴露而被篡改，故将消息容器作为静态私有变量保存</span></div><div class="line">    <span class="keyword">var</span> __messages = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 注册信息接口</span></div><div class="line">        regist: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 发布信息接口</span></div><div class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 移除信息接口</span></div><div class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>下面就是可以自己具体实现这些接口了。</p>
<h3 id="收获与总结-14"><a href="#收获与总结-14" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>观察者模式最主要是解决类或对象之间的耦合，解耦两个互相依赖的对象，使其依赖于观察者的消息机制。这样对于任何一个订阅者来说，其他订阅者对象的改变不会影响到自身，其自身既可以是消息的发出者也可以是消息的执行者，这都依赖于调用观察者对象中的三种方法（订阅，注销，发布消息）中的哪一种。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>作者把这种模式比喻成超级玛丽。</p>
<h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对像。</p>
<h3 id="使用场景-14"><a href="#使用场景-14" class="headerlink" title="使用场景"></a>使用场景</h3><p>平时写代码的时候经常会遇到要写很多条件判断语句的情况，那么怎么减少代码中的条件判断语句呢？对于这类分支条件内部独立结果的管理，可以使用状态模式，每一种条件作为对象的一种状态，面对不同的判断结果，其实就是选择对象内的一种状态。<br>将不同的判断结果封装在状态对象内，然后该状态对象返回一个可被调用的接口方法，用于调用状态对象内部的某种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 投票结果状态对象</span></div><div class="line"><span class="keyword">var</span> ResultState = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断结果保存在内部状态中</span></div><div class="line">    <span class="keyword">var</span> States = &#123;</div><div class="line">        <span class="comment">// 每种状态作为一种独立方法保存</span></div><div class="line">        state0: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第一种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第二种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第三种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第四种情况'</span>)：</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取某种状态并执行对应方法</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">        States[<span class="string">'state'</span> + result] &amp;&amp; States[<span class="string">'state'</span> + result]();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 返回调用状态方法接口</span></div><div class="line">        show: show</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>想调用第三种结果就可以如下调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResultState.show(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>对于状态模式，主要目的就是将条件判断的不同结果转化为状态对象的内部状态，这个内部状态一般作为状态对象的私有变量，然后提供一个能够调用状态对象内部状态的接口方法对象即可。</p>
<h3 id="收获与总结-15"><a href="#收获与总结-15" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>状态模式既是解决程序中臃肿的分支判断语句问题，将每一个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次只需时遍历所有分支。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>作者把这种模式比喻成活诸葛。</p>
<h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><p>将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>
<h3 id="使用场景-15"><a href="#使用场景-15" class="headerlink" title="使用场景"></a>使用场景</h3><p>年底的时候，公司商品展销页都要开展大促销活动。在圣诞节，一部分商品5折出售，一部分商品8折出售，一部分商品9折出售，到元旦搞个幸运反馈活动，普通用户满100返30，高级VIP用户满100返50。这个时候上面的状态模式就不适用了，因为每一天每一个商品只有一种促销情况，这个时候可以用策略模式。<br>结构上看，它与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现实现对内部对象的调用，不同点是，策略模式不需要管理状态、状态间没有依赖关系、策略之剑可以相互替换、在策略对象内部保存的是相互独立的一些算法。看看策略对象的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 价格策略对象</span></div><div class="line"><span class="keyword">var</span> PriceStrategy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 内部算法对象</span></div><div class="line">    <span class="keyword">var</span> strategy = &#123;</div><div class="line">        <span class="comment">// 100返30</span></div><div class="line">        return30: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 100返50</span></div><div class="line">        return50: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 9折</span></div><div class="line">        percent90: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 8折</span></div><div class="line">        percent80: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 5折</span></div><div class="line">        percent50: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 策略算法调用接口</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">algorithm, price</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> strategy[algorithm] &amp;&amp; strategy[algorithm](price);</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-16"><a href="#收获与总结-16" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>策略模式主要特色是创建一系列策略算法，每组算法处理业务都是相同的，只是处理的过程或者处理的结果不一样，所以它们是可以相互替换的，这样就解决了算法与使用者之间的耦合。</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>作者把这种模式比喻成一个有序车站。</p>
<h3 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h3><p>解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，知道最后一个对象完成请求的处理。</p>
<h3 id="使用场景-16"><a href="#使用场景-16" class="headerlink" title="使用场景"></a>使用场景</h3><p>项目经理准备改善页面中的输入验证与提示交互体验。如用户在输入框输入信息后，在输入框的下面提示出一些备选项，当用户输入完成后，则要对用户输入信息进行验证等，页面中很多模块需要用户提交信息，为增强用户体验，这些输入框大部分需要具备以上两种功能。现在需要完成这个需求，但是以后可能要对原有表单交互体验做一些修改，也就是这是一个半成品需求。这种情况下，我们需要将需求里面需要做的每一件事情独立出来，这样完整的需求就变成一个个相互独立的模块需求，这样就不会因为以后需求的改变而影响我们项目的进展，这样还有利于以后的单元测试。这其实就是一种职责链模式。<br>对于上面的需求，对输入框绑定事件是第一部分，第二部分是创建xhr进行异步数据获取，第三部分就是适配响应数据，将接收到的数据格式化成可处理的形式，最后一部分是向组件创建器传入相应数据生成组件。</p>
<h3 id="收获与总结-17"><a href="#收获与总结-17" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>职责链模式定义了请求的传递方向，通过多个对象对请求的传递，实现一个复杂的逻辑操作。因此职责链模式将负责的需求颗粒化逐一实现每个最小分内的需求，并将请求顺序地传递。对于职责链上的每一个对象来说，它可能是请求的发起者也可能是请求的接收者，通过这种方式不仅仅简化原对象的复杂度，而且解决原请求的发起者与原请求的接收者之间的耦合。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h3><p>将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。</p>
<h3 id="使用场景-17"><a href="#使用场景-17" class="headerlink" title="使用场景"></a>使用场景</h3><p>现在的需求是要做一个活动页面，平铺式的结构，不过页面的每个模块都有些相似的地方，比如每个预览产品图片区域，都有一行标题，然后标题下面是产品图片，只是图片的数量与排列不同。我们需要一种自由创建视图模块的方法，有时候创建多张图片有时候只创建一张图片，这时候可以试试命令模式。<br>命令模式是将创建模块的逻辑封装在一个对象里，这个对象提供一个参数化的请求接口，通过调用这个接口并传递一些参数实现调用命令对象内部中的一些方法。请求部分很简单，只需要按照给定参数格式书写指令即可，所以实现部分的封装才是重点，因为它要为请求部分提供所需方法。<br>那么哪些对象需要被命令化呢？既然需要动态展示不同模块，所以创建元素这一需求就是变化的，因此创建元素方法、展示方法应该被命令化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模块实现模块</span></div><div class="line"><span class="keyword">var</span> viewCommand = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tpl = &#123;</div><div class="line">        <span class="comment">// 展示图片结构模块</span></div><div class="line">        product: [</div><div class="line">            <span class="string">'&lt;div&gt;'</span>,.....,<span class="string">'&lt;/div&gt;'</span></div><div class="line">        ].join(<span class="string">''</span>),</div><div class="line">        <span class="comment">// 展示标题结构模块</span></div><div class="line">        title: [</div><div class="line">        <span class="string">'&lt;div&gt;'</span>,.....,<span class="string">'&lt;/div&gt;'</span></div><div class="line">        ].join(<span class="string">''</span>),</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 格式化字符串缓存字符串</span></div><div class="line">    html = <span class="string">''</span>;</div><div class="line">    <span class="comment">// 格式化字符串</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">formateString</span>(<span class="params">str, obj</span>) </span>&#123;&#125;</div><div class="line">    <span class="comment">// 方法集合</span></div><div class="line">    <span class="keyword">var</span> Action = &#123;</div><div class="line">        <span class="comment">// 创建方法</span></div><div class="line">        create: <span class="function"><span class="keyword">function</span>(<span class="params">data, view</span>) </span>&#123;</div><div class="line">            <span class="comment">// 解析数据</span></div><div class="line">            <span class="keyword">if</span>(data.length) &#123;</div><div class="line">                <span class="comment">// 遍历</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</div><div class="line">                    html += formateString(tpl[view], data[i]);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                html += formateString(tpl[view], data);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 展示方法</span></div><div class="line">        display: <span class="function"><span class="keyword">function</span>(<span class="params">container, data, vuew</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果传入数据</span></div><div class="line">            <span class="keyword">if</span>(data) &#123;</div><div class="line">                <span class="comment">// 根据给的数据创建视图</span></div><div class="line">                <span class="keyword">this</span>.create(data, view);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 展示模块</span></div><div class="line">            <span class="built_in">document</span>.getElementById(container).innerHTML = html;</div><div class="line">            <span class="comment">// 展示后清空缓存字符串</span></div><div class="line">            html = <span class="string">''</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 命令接口</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">excute</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">        <span class="comment">// 解析命令，如果msg.param不是数组则将其转化为数组</span></div><div class="line">        msg.param = <span class="built_in">Object</span>.prototype.toString.call(msg.param) === <span class="string">"[object Array]"</span> ? msg.param : [msg.param];</div><div class="line">        <span class="comment">// Action内部调用的方法引用this，此处保证作用域this执行传入Action</span></div><div class="line">        Action[msg.command].apply(Action, msg.param)</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>下面就可以测试这个命令对象了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> productData = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">src</span>: <span class="string">'command/02.jpg'</span>,</div><div class="line">        <span class="attr">text</span>: <span class="string">'绽放的桃花'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">src</span>: <span class="string">'command/03.jpg'</span>,</div><div class="line">        <span class="attr">text</span>: <span class="string">'阳光下的温馨'</span></div><div class="line">    &#125;</div><div class="line">],</div><div class="line"><span class="comment">// 模块标题数据</span></div><div class="line">titleData = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'夏日里的一片温馨'</span>,</div><div class="line">    <span class="attr">tips</span>: <span class="string">'暖暖的温情带给人们家的感觉'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用命令对象</span></div><div class="line">viewCommand(&#123;</div><div class="line">    <span class="attr">command</span>: <span class="string">'display'</span>,</div><div class="line">    <span class="attr">param</span>: [<span class="string">'title'</span>, titleData, <span class="string">'title'</span>]</div><div class="line">&#125;);</div><div class="line">viewCommand(&#123;</div><div class="line">    <span class="attr">command</span>: <span class="string">'create'</span>,</div><div class="line">    <span class="attr">param</span>: [<span class="string">'product'</span>, productData, <span class="string">'product'</span>]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>有了命令模式，想创建任何页面视图都是一件很简单的事情。</p>
<h3 id="收获与总结-18"><a href="#收获与总结-18" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>命令模式是将执行的命令封装，解决命令发起者与命令执行者之间的耦合，每一条命令实质上是一个操作。命令的是使用者不必了解命令执行者的命令接口是如何实现的，只需要知道如何调用。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>作者把这种模式比喻成驻华大使。</p>
<h3 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h3><p>针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的新方法。</p>
<h3 id="使用场景-18"><a href="#使用场景-18" class="headerlink" title="使用场景"></a>使用场景</h3><p>用DOM2级事件为页面中元素绑定事件时，为css设置一些样式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params">dom, type, fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</div><div class="line">        dom.addEventListener(type, fn, <span class="literal">false</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</div><div class="line">        dom.attachEvent(<span class="string">'on'</span> + type, fn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dom[<span class="string">'on'</span> + type] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> demo = <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>);</div><div class="line">bindEvent(demo, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.style.background = <span class="string">'red'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个在IE浏览器中会出问题，因为IE的attachEvent事件中this指向的竟然是window而不是这个元素，所以如果想获取事件对象必须用window.e来获取。这个问题可以借用访问者模式来解决。<br>访问者模式的思想是我们在不改变操作对象的同时，为它添加新的操作方法，来实现对操作对象的访问。下面看看IE的实现方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindIEEvent</span>(<span class="params">dom, type, fn, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = data || &#123;&#125;;</div><div class="line">    dom.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        fn.call(dom, e, data);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面实现方法的核心就是调用call方法，call方法的作用就是更改函数执行时的作用域，这正是访问者模式的精髓。</p>
<h3 id="收获与总结-19"><a href="#收获与总结-19" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>访问者模式解决数据与数据操作方法之间的耦合，将数据的操作方法独立于数据，使其可以自由化演变。访问者更适合那些数据稳定但是数据的操作方法易变的环境下。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>作者把这种模式比喻成媒婆，好吧，我笑了这里。</p>
<h3 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h3><p>通过中介者对象封装一系列对象之间的交互，是对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可以改变对象之间的交互。</p>
<h3 id="使用场景-19"><a href="#使用场景-19" class="headerlink" title="使用场景"></a>使用场景</h3><p>项目经理准备在用户首页上的导航模块添加一个设置层，让用户可以通过设置层来设置导航展开样式。但是页面中好多模块都有导航，这要改起来工作量也很大，上面讲的观察者模式虽然能解决模块之间的耦合，但是这里我们并没有需要向设置层发送请求的需求，设置层只是单向控制导航模块内导航的样式。这样的单向通信就可以使用中介者模式。<br>观察者模式和中介者模式都是通过消息收发机制实现，不过在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，而中介者模式中消息的发送方只有一个就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象（订阅者）才能订阅中介者消息。<br>如果用中介者模式来解决上面的问题，那么中介者对象就是设置层模块对象，它负责向各个导航模块对象发送用户设置消息，而各个导航模块则应该作为消息的订阅者存在，实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 中介者对象</span></div><div class="line"><span class="keyword">var</span> Mediator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 消息对象</span></div><div class="line">    <span class="keyword">var</span> _msg = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 订阅消息方法，type:消息名称 action:消息回调函数</span></div><div class="line">        register: <span class="function"><span class="keyword">function</span>(<span class="params">type, action</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果消息存在</span></div><div class="line">            <span class="keyword">if</span>(_msg[type])</div><div class="line">                <span class="comment">// 存入回调函数</span></div><div class="line">                _msg[type].push(action);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不存在则建立消息容器</span></div><div class="line">                _msg[type] = [];</div><div class="line">                _msg[type].push(action);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 发布消息方法</span></div><div class="line">        send: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果该消息已经被订阅</span></div><div class="line">            <span class="keyword">if</span>(_msg[type]) &#123;</div><div class="line">                <span class="comment">// 遍历已存储的消息回调函数</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = _msg[type].length; i &lt; len; i++) &#123;</div><div class="line">                    <span class="comment">// 执行回调函数</span></div><div class="line">                    _msg[type][i] &amp;&amp; _msg[type][i]();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>这样就创建了一个中介者对象，下面就可以利用这个中介者对象完成我们的需求了。</p>
<h3 id="收获与总结-20"><a href="#收获与总结-20" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>同观察者模式一样，中介者模式的主要业务也是通过模块间或者对象间的复杂通信，来解决模块间或对象间的耦合。在中介者模式中，订阅者是单向的，只能是订阅者而不能是发布者。而消息统一由中介者对象发布。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h3><p>在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部状态以便日后对象使用或者对象恢复到以前的某个状态。</p>
<h3 id="使用场景-20"><a href="#使用场景-20" class="headerlink" title="使用场景"></a>使用场景</h3><p>在前面提到的新闻页面中，有上一页和下一页的按钮，页面的内容是用异步请求获取的。如果点击下一页按钮接着再点击上一页那么之前那一页又要进行一次异步请求，这是多余的操作。因为第一次已经获取了数据，不需要再发送多余的请求。这个时候可以用备忘录模式来缓存请求过的数据。也就是说每次发生请求的时候对当前状态做一次记录，将请求到的数据以及对应得页码缓存下来，如果之后返回到之前浏览过的页面，直接在缓存中查询即可，不用发生异步请求。先创建一个新闻缓存器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Page备忘录类</span></div><div class="line"><span class="keyword">var</span> Page = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 信息缓存对象</span></div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">page, fn</span>) </span>&#123;</div><div class="line">        <span class="comment">// 判断该页数据是否在缓存中</span></div><div class="line">        <span class="keyword">if</span>(cache[page]) &#123;</div><div class="line">            <span class="comment">// 显示该页内容</span></div><div class="line">            showPage(page, cache[page]);</div><div class="line">            <span class="comment">// 执行成功回调函数</span></div><div class="line">            fn &amp;&amp; fn();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 否则异步请求</span></div><div class="line">            $.post(<span class="string">'./data/getNewsData.php'</span>, &#123;</div><div class="line">                <span class="attr">page</span>: page</div><div class="line">            &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">                <span class="comment">// 成功返回</span></div><div class="line">                <span class="keyword">if</span>(res.errNo == <span class="number">0</span>) &#123;</div><div class="line">                    showPage(page, res.data);</div><div class="line">                    cache[page] = res.data;</div><div class="line">                    fn &amp;&amp; fn();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 处理异常</span></div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码可以看出Page缓存器内部缓存了每次请求回来的新闻数据，这样以后如果用户想回看某页新闻数据就不需要发送不必要的请求了。</p>
<h3 id="收获与总结-21"><a href="#收获与总结-21" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>备忘录模式最主要的任务是对现有的数据或状态进行缓存，为将类某个时刻使用或恢复做准备。但是当数据量过大时，会严重占用系统提供的资源，此时对缓存器的优化是很有必要的，复用率低的数据缓存下来是不值得的。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>作者把这种模式比喻成一个点钞机。</p>
<h3 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h3><p>在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>
<h3 id="使用场景-21"><a href="#使用场景-21" class="headerlink" title="使用场景"></a>使用场景</h3><p>迭代器模式主要是解决重复循环迭代的问题，之前接触过面向对象语言的应该都对迭代器有所了解。迭代器就是用来顺序地访问一个聚合对象内部元素的，它可以简化我们遍历操作，就行银行里的点钞机，有了它可以大幅度降低我们的点钞成本。下面创建一个常用的迭代器对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Iterator = <span class="function"><span class="keyword">function</span>(<span class="params">items, container</span>) </span>&#123;</div><div class="line">    <span class="comment">// 获取父元素</span></div><div class="line">    <span class="keyword">var</span> container = container &amp;&amp; <span class="built_in">document</span>.getElementById(container) || <span class="built_in">document</span>,</div><div class="line">    <span class="comment">// 获取元素</span></div><div class="line">        items = container.getElementsByTagName(items),</div><div class="line">    <span class="comment">// 获取元素长度</span></div><div class="line">        length = items.length,</div><div class="line">    <span class="comment">// 当前索引值</span></div><div class="line">        index = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 缓存原生数组splice方法</span></div><div class="line">    <span class="keyword">var</span> splice = [].splice;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 获取第一个元素</span></div><div class="line">        first: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取最后一个元素</span></div><div class="line">        second: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取前一个元素</span></div><div class="line">        pre: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取后一个元素</span></div><div class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取某一个元素</span></div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 对每一个元素执行某一个方法</span></div><div class="line">        dealEach: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 对某一个元素执行某一个方法</span></div><div class="line">        dealItem: <span class="function"><span class="keyword">function</span>(<span class="params">num, fn</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 排他方式处理某一个元素</span></div><div class="line">        exclusive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面具体实现迭代器里面的这些方法，然后就可以用这个迭代器对象啦。</p>
<h3 id="收获与总结-22"><a href="#收获与总结-22" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>通过迭代器我们可以顺序地访问一个聚合对象中的每一个元素。在开发中，迭代器极大简化了代码中的循环语句，使代码结构清晰紧凑。用迭代器去处理一个对象时，只需要提供处理的方法，而不必去关心对象的内部结构，这也解决了对象的使用者与对象内部结构之间的耦合。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h3><p>对于一种语言，给出其文法表示，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>
<h3 id="使用场景-22"><a href="#使用场景-22" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个页面中的某些功能好坏有时是靠一定的数据依据支撑的。项目经理想看看用户对最近新增的功能使用情况，前后端要给出统计数据，然而前端交互统计项中要给出交互元素路径。这件事情与冒泡事件类似，只不过在这个路径中还要关心同一层级中当前元素的兄弟元素。比如下面的结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"link-inner"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button-inner"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>要获取button相对于class为wrap的div元素的Xpath路径，那么可以表示为DIV&gt;DIV2&gt;SPAN。<br>上面对需求的描述是一种文法，描述的是一组规则，现在要做的事实现一个规则解释器来解释上面的规则。首先要分析给出的文法，查找他们的相似点，然后该清楚我们要先实现什么再实现什么，基本上问题就能解决了。</p>
<h3 id="收获与总结-23"><a href="#收获与总结-23" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>一些描述性语句，几次功能的提取抽象，形成了一套语法法则，这就是解释器模式要处理的事情。是否能应用解释器模式的一条重要准则是能否根据需求解析出一套完整的语法规则，不论该语法规则简单或是复杂都是必须的。</p>
<h1 id="技巧型设计模式"><a href="#技巧型设计模式" class="headerlink" title="技巧型设计模式"></a>技巧型设计模式</h1><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。这本书中总结了8种技巧型设计模式，分别是链模式，委托模式，数据访问对象模式，节流模式，简单模板模式，惰性模式，参与者模式和等待者模式。有兴趣的同学可以去买书来看哦，这里就不一一解释了。</p>
<h1 id="架构型设计模式"><a href="#架构型设计模式" class="headerlink" title="架构型设计模式"></a>架构型设计模式</h1><p>架构型设计模式是一类框架结构，通过提供一些子系统，指定它们的职责，并将它们条理清晰地组织在一起。现在流行的前端框架都用了这种类型的设计模式。本书总结了6种架构型设计模式，分别是同步模块模式，异步模块模式，Widget模式，MVC模式，MVP模式和MVVM模式。</p>
<p>学习设计模式的学习对于我们来说任重而道远，我们需要在实践中不断思考不断总结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触前端两三个月的时候，那时候只是听说设计模式很重要，然后我就去读了一本设计模式的书，读了一部分，也不知道这些设计模式到底设计出来干嘛的，然后就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://yuhan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli#2.0项目结构分析</title>
    <link href="http://yuhan.com/2016/12/20/vue-cli-2-0/"/>
    <id>http://yuhan.com/2016/12/20/vue-cli-2-0/</id>
    <published>2016-12-20T11:17:06.000Z</published>
    <updated>2017-03-04T08:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触过vue的同学应该都知道，用vue-cli开发vue的项目十分方便，它可以帮你快速构建一个具有强大构建能力的Vue.js项目。今天不谈什么是vue-cli，而是来说说用vue-cli构建的项目结构是什么样的并分析部分文件。这里以我之前写的一个小项目为参考，项目是用vue-cli的webpack模板构建的，项目地址：<a href="https://github.com/hieeyh/tong2-family" target="_blank" rel="external">https://github.com/hieeyh/tong2-family</a>。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">|-- build                            // 项目构建(webpack)相关代码</div><div class="line">|   |-- build.js                     // 生产环境构建代码</div><div class="line">|   |-- check-version.js             // 检查node、npm等版本</div><div class="line">|   |-- dev-client.js                // 热重载相关</div><div class="line">|   |-- dev-server.js                // 构建本地服务器</div><div class="line">|   |-- utils.js                     // 构建工具相关</div><div class="line">|   |-- webpack.base.conf.js         // webpack基础配置</div><div class="line">|   |-- webpack.dev.conf.js          // webpack开发环境配置</div><div class="line">|   |-- webpack.prod.conf.js         // webpack生产环境配置</div><div class="line">|-- config                           // 项目开发环境配置</div><div class="line">|   |-- dev.env.js                   // 开发环境变量</div><div class="line">|   |-- index.js                     // 项目一些配置变量</div><div class="line">|   |-- prod.env.js                  // 生产环境变量</div><div class="line">|   |-- test.env.js                  // 测试环境变量</div><div class="line">|-- src                              // 源码目录</div><div class="line">|   |-- components                     // vue公共组件</div><div class="line">|   |-- store                          // vuex的状态管理</div><div class="line">|   |-- App.vue                        // 页面入口文件</div><div class="line">|   |-- main.js                        // 程序入口文件，加载各种公共组件</div><div class="line">|-- static                           // 静态文件，比如一些图片，json数据等</div><div class="line">|   |-- data                           // 群聊分析得到的数据用于数据可视化</div><div class="line">|-- .babelrc                         // ES6语法编译配置</div><div class="line">|-- .editorconfig                    // 定义代码格式</div><div class="line">|-- .gitignore                       // git上传需要忽略的文件格式</div><div class="line">|-- README.md                        // 项目说明</div><div class="line">|-- favicon.ico </div><div class="line">|-- index.html                       // 入口页面</div><div class="line">|-- package.json                     // 项目基本信息</div><div class="line">.</div></pre></td></tr></table></figure>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。</p>
<h2 id="scripts字段"><a href="#scripts字段" class="headerlink" title="scripts字段"></a>scripts字段</h2><p>package.json文件里有一个scripts字段。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在开发环境下，在命令行中运行<code>npm run dev</code>就相当于在执行<code>node build/dev-server.js</code>。所以script字段是用来指定npm相关命令的缩写的。</p>
<h2 id="dependencies字段和devDependencies字段"><a href="#dependencies字段和devDependencies字段" class="headerlink" title="dependencies字段和devDependencies字段"></a>dependencies字段和devDependencies字段</h2><p>dependencies字段指定了项目运行时所依赖的模块，devDependencies字段指定了项目开发时所依赖的模块。在命令行中运行npm install命令，会自动安装dependencies和devDependencies字段中的模块。<br>package.json还有很多配置相关项，想进一步了解package.json的可参考：<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></p>
<h1 id="webpack配置相关"><a href="#webpack配置相关" class="headerlink" title="webpack配置相关"></a>webpack配置相关</h1><p>上面说到在命令行中<code>npm run dev</code>就相当于在执行<code>node build/dev-server.js</code>，想必dev-server.js这个文件是十分重要的，它是在开发环境下构建时第一个要运行的文件。掘金上已经有一篇对vue-cli#2.0 webpack配置的分析文章，里面详细讲解了webpack相关配置文件的每行代码的意思，我只做一些补充。链接在此（一定要仔细阅读，收获会很大）：<a href="https://gold.xitu.io/post/584e48b2ac502e006c74a120" target="_blank" rel="external">https://gold.xitu.io/post/584e48b2ac502e006c74a120</a>。</p>
<h2 id="dev-server-js"><a href="#dev-server-js" class="headerlink" title="dev-server.js"></a>dev-server.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line"><span class="comment">// http-proxy可以实现转发所有请求代理到后端真实API地址，以实现前后端开发完全分离</span></div><div class="line"><span class="comment">// 在config/index.js中可以对proxyTable想进行配置</span></div><div class="line"><span class="keyword">var</span> proxyMiddleware = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</div><div class="line">...</div><div class="line">...</div><div class="line"><span class="comment">// 热加载要使用webpack-dev-middleware在没有webpack-dev-server的时候进行热加载</span></div><div class="line"><span class="keyword">var</span> hotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>)(compiler)</div><div class="line"><span class="comment">// 当html-webpack-plugin模板改变是强制进行页面重新加载</span></div><div class="line">compiler.plugin(<span class="string">'compilation'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;</div><div class="line">  compilation.plugin(<span class="string">'html-webpack-plugin-after-emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data, cb</span>) </span>&#123;</div><div class="line">    hotMiddleware.publish(&#123; <span class="attr">action</span>: <span class="string">'reload'</span> &#125;)</div><div class="line">    cb()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line">module.export = &#123;</div><div class="line">    <span class="comment">// 编译入口文件</span></div><div class="line">    entry: &#123;&#125;,</div><div class="line">    <span class="comment">// 编译输出路径</span></div><div class="line">    output: &#123;&#125;,</div><div class="line">    <span class="comment">// 一些解决方案配置</span></div><div class="line">    resolve: &#123;&#125;,</div><div class="line">    <span class="attr">resolveLoader</span>: &#123;&#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="comment">// 各种不同类型文件加载器配置</span></div><div class="line">        loaders: &#123;</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        <span class="comment">// js文件用babel转码</span></div><div class="line">        &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">            <span class="attr">include</span>: projectRoot,</div><div class="line">            <span class="comment">// 哪些文件不需要转码</span></div><div class="line">            exclude: <span class="regexp">/node_modules/</span></div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// vue文件一些相关配置</span></div><div class="line">    vue: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="check-version-js"><a href="#check-version-js" class="headerlink" title="check-version.js"></a>check-version.js</h2><p>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载语义化版本测试库</span></div><div class="line"><span class="keyword">var</span> semver = <span class="built_in">require</span>(<span class="string">'semver'</span>)</div><div class="line"><span class="comment">// 定制控制台日志的输入样式</span></div><div class="line"><span class="keyword">var</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)</div><div class="line"><span class="comment">// 引入package.json文件</span></div><div class="line"><span class="keyword">var</span> packageConfig = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</div><div class="line"><span class="keyword">var</span> exec = <span class="function"><span class="keyword">function</span> (<span class="params">cmd</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'child_process'</span>)</div><div class="line">    .execSync(cmd).toString().trim()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义node和npm版本需求所组成的数组</span></div><div class="line"><span class="keyword">var</span> versionRequirements = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'node'</span>,</div><div class="line">    <span class="attr">currentVersion</span>: semver.clean(process.version),</div><div class="line">    <span class="attr">versionRequirement</span>: packageConfig.engines.node</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'npm'</span>,</div><div class="line">    <span class="attr">currentVersion</span>: exec(<span class="string">'npm --version'</span>),</div><div class="line">    <span class="attr">versionRequirement</span>: packageConfig.engines.npm</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> warnings = []</div><div class="line">  <span class="comment">// 依次判断版本是否符合要求</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; versionRequirements.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> mod = versionRequirements[i]</div><div class="line">    <span class="keyword">if</span> (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</div><div class="line">      warnings.push(mod.name + <span class="string">': '</span> +</div><div class="line">        chalk.red(mod.currentVersion) + <span class="string">' should be '</span> +</div><div class="line">        chalk.green(mod.versionRequirement)</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想把webpack完全搞懂还是需要费很大功夫的，我感觉自己也只是入了一个门而已，要想深入了解webpack还是要去官网看说明文档。</p>
<ol>
<li><a href="http://webpack.github.io/docs/" target="_blank" rel="external">http://webpack.github.io/docs/</a></li>
<li><a href="https://webpack.js.org/configuration/" target="_blank" rel="external">https://webpack.js.org/configuration/</a></li>
<li><a href="https://github.com/wangning0/Autumn_Ning_Blog/blob/master/blogs/3-12/webpack.md" target="_blank" rel="external">webpack学习之路</a></li>
</ol>
<h1 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h1><p>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。这里有一篇阮一峰老师写的相关文章供参考：<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">Babel 入门教程</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设定转码规则</span></div><div class="line"><span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"stage-2"</span>],</div><div class="line"><span class="comment">// 转码的一些插件</span></div><div class="line"><span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>],</div><div class="line"><span class="string">"comments"</span>: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h1 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h1><p>该文件定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = true</div><div class="line"></div><div class="line">[*]    // 对所有文件应用下面的规则</div><div class="line">charset = utf-8                    // 编码规则用utf-8</div><div class="line">indent_style = space               // 缩进用空格</div><div class="line">indent_size = 2                    // 缩进数量为2个空格</div><div class="line">end_of_line = lf                   // 换行符格式</div><div class="line">insert_final_newline = true        // 是否在文件的最后插入一个空行</div><div class="line">trim_trailing_whitespace = true    // 是否删除行尾的空格</div></pre></td></tr></table></figure></p>
<p>了解更多请参考官方配置文档<a href="http://editorconfig.org/" target="_blank" rel="external">http://editorconfig.org/</a></p>
<p>接触vue并不久，很多东西也不是特别清楚，文章里有什么问题欢迎指出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触过vue的同学应该都知道，用vue-cli开发vue的项目十分方便，它可以帮你快速构建一个具有强大构建能力的Vue.js项目。今天不谈什么是vue-cli，而是来说说用vue-cli构建的项目结构是什么样的并分析部分文件。这里以我之前写的一个小项目为参考，项目是用vue
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="vue-cli" scheme="http://yuhan.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>vue-router2.0学习笔记</title>
    <link href="http://yuhan.com/2016/12/12/vue-router/"/>
    <id>http://yuhan.com/2016/12/12/vue-router/</id>
    <published>2016-12-12T02:30:18.000Z</published>
    <updated>2016-12-22T06:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="external">官方文档</a>。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。</p>
<h1 id="先上例子"><a href="#先上例子" class="headerlink" title="先上例子"></a>先上例子</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- html部分，省略head --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/goods"</span>&gt;</span>商品<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/ratings"</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/seller"</span>&gt;</span>商家<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path-to-vue"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path-to-vue-router"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先定义或者引入路由的组件</span></div><div class="line"><span class="comment">// 方法一：直接定义路由组件</span></div><div class="line"><span class="keyword">const</span> goods = &#123; <span class="attr">template</span>: <span class="string">'&lt;p&gt;goods&lt;/p&gt;'</span> &#125;;</div><div class="line"><span class="keyword">const</span> ratings = &#123; <span class="attr">template</span>: <span class="string">'&lt;p&gt;ratings&lt;/p&gt;'</span> &#125;;</div><div class="line"><span class="keyword">const</span> seller = &#123; <span class="attr">template</span>: <span class="string">'&lt;p&gt;seller&lt;/p&gt;'</span> &#125;;</div><div class="line"><span class="comment">// 方法二：import引入路由组件</span></div><div class="line"><span class="keyword">import</span> goods <span class="keyword">from</span> <span class="string">'components/goods/goods'</span>;</div><div class="line"><span class="keyword">import</span> ratings <span class="keyword">from</span> <span class="string">'components/ratings/ratings'</span>;</div><div class="line"><span class="keyword">import</span> seller <span class="keyword">from</span> <span class="string">'components/seller/seller'</span>;</div><div class="line"><span class="comment">// 然后定义路由(routes)，components还可以是Vue.extend()创建的</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/goods'</span>, <span class="attr">component</span>: goods &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/ratings'</span>, <span class="attr">component</span>: ratings &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/seller'</span>, <span class="attr">component</span>: seller &#125;</div><div class="line">];</div><div class="line"><span class="comment">// 接着创建路由实例</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  <span class="comment">// ES6缩写语法，相当于routes:routes</span></div><div class="line">  routes  </div><div class="line">&#125;);</div><div class="line"><span class="comment">// 最后创建vue实例并挂载</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  router</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure>
<p>到这里就可以用vue-router轻松搭建一个单页面应用了。我一般都是使用模块化编程的形式，用.vue单文件，不知道在模块化编程里怎么加载vue-router的可以参考我的<a href="https://github.com/hieeyh/tong2-family" target="_blank" rel="external">某个项目源码</a>。</p>
<h1 id="router-link和router-view"><a href="#router-link和router-view" class="headerlink" title="router-link和router-view"></a>router-link和router-view</h1><p>看了上面的例子，一定对router-link和router-view很感兴趣。</p>
<h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><p>从上面例子中的书写形式就可以看出，router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址。<br><strong>注意</strong>：被选中的router-link将自动添加一个class属性值<code>.router-link-active</code>。</p>
<h3 id="router-link属性配置"><a href="#router-link属性配置" class="headerlink" title="router-link属性配置"></a>router-link属性配置</h3><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><p>这是一个必须设置的属性，否则路由无法生效。它表示路由的链接，可以是一个字符串也可以是一个描述目标位置的对象。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"goods"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123;path='goods'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>一个布尔类型，默认为false。如果replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"goods"</span> <span class="attr">replace</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>router-link默认渲染成a标签，也有方法让它渲染成其他标签，tag属性就用来设置router-link渲染成什么标签的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 渲染成li标签 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"goods"</span> <span class="attr">tag</span>=<span class="string">"li"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h4><p>上面说了被选中的router-link将自动添加一个class属性值<code>.router-link-active</code>，这个属性就是来修改这个class值的。</p>
<h2 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h2><p>这个组件十分关键，它就是用来渲染匹配到的路由的。<br>可以给router-view组件设置transition过渡，具体用法见<a href="http://hyuhan.com/2016/12/08/vue-transition/" target="_blank" rel="external">Vue2.0 Transition常见用法全解惑</a>。<br>还可以配合<code>&lt;keep-alive&gt;</code>使用，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，之前那个路由组件的数据被清除了。比如对当前的路由组件a进行了一些DOM操作之后，点击进入另一个路由组件b，再回到路由组件a的时候之前的DOM操作还保存在，如果不加keep-alive再回到路由组件a时，之前的DOM操作就没有了，得重新进行。如果你的应用里有一个购物车组件，就需要用到keep-alive。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="一些小需求怎么实现"><a href="#一些小需求怎么实现" class="headerlink" title="一些小需求怎么实现"></a>一些小需求怎么实现</h1><h2 id="不同路由不同页面标题"><a href="#不同路由不同页面标题" class="headerlink" title="不同路由不同页面标题"></a>不同路由不同页面标题</h2><p>多页面应用我们可以给每一个页面都设置一个不同的标题，但是如果是单页面应用的路由呢？其实也是可以实现的，实现的方法不止一种，我之前用的是结合命名路由和导航钩子函数的方法。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义路由的时候如下定义，name也可为中文</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/goods'</span>, <span class="attr">component</span>: goods, <span class="attr">name</span>: <span class="string">'goods'</span> &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/ratings'</span>, <span class="attr">component</span>: ratings, <span class="attr">name</span>: <span class="string">'ratings'</span> &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/seller'</span>, <span class="attr">component</span>: seller, <span class="attr">name</span>: <span class="string">'seller'</span> &#125;</div><div class="line">];</div><div class="line"><span class="comment">// 创建路由实例</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  <span class="attr">routes</span>: routes</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 关键在这里，设置afterEach钩子函数</span></div><div class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">document</span>.title = to.name;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>既然用到了命名路由，这里就提一下吧。命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'seller'&#125;"</span>&gt;</span>seller<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="导航钩子"><a href="#导航钩子" class="headerlink" title="导航钩子"></a>导航钩子</h3><p>这个我还没怎么用过，它主要是用来拦截导航的，想使用的参考<a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank" rel="external">官方文档</a>吧。</p>
<h2 id="怎么刚进入应用就渲染某个路由组件"><a href="#怎么刚进入应用就渲染某个路由组件" class="headerlink" title="怎么刚进入应用就渲染某个路由组件"></a>怎么刚进入应用就渲染某个路由组件</h2><p>刚进入应用都是进入到“/”这个路由的，如果想直接进入到“/goods”怎么办，这里提供两种方法。一种是利用重定向，另一种是利用vue-router的导航式编程。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/goods'</span>&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>是不是很简单呢？重定向的目标也可以是一个命名的路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'goods'</span> &#125;&#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="导航式编程"><a href="#导航式编程" class="headerlink" title="导航式编程"></a>导航式编程</h3><p>利用vue-router的导航式编程的router.push方法也可以实现上面的需求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在创建vue实例并挂载后调用</span></div><div class="line">router.push(<span class="string">'/goods'</span>)</div></pre></td></tr></table></figure></p>
<p>router.push方法就是用来动态导航到不同的链接的。它会向history栈添加一个新的记录，点击<code>&lt;router-link :to=&quot;...&quot;&gt;</code>等同于调用router.push(…)。</p>
<p>vue-router中还有router.replace方法和router.go方法，概念及用法可参考<a href="https://router.vuejs.org/zh-cn/essentials/navigation.html" target="_blank" rel="external">https://router.vuejs.org/zh-cn/essentials/navigation.html</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看&lt;a href=&quot;h
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="vue-router" scheme="http://yuhan.com/tags/vue-router/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0 Transition常见用法全解惑</title>
    <link href="http://yuhan.com/2016/12/08/vue-transition/"/>
    <id>http://yuhan.com/2016/12/08/vue-transition/</id>
    <published>2016-12-08T00:48:41.000Z</published>
    <updated>2016-12-08T05:43:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue2.0的过渡系统（transition）有了很大的改变，想把1.0的项目迁移到2.0，着实需要费一些功夫，今天我就要把vue2.0的过渡系统的用法搞清楚，因为之前确实踩了不少坑。这里只涉及单元素/组件的过渡实现，<a href="http://cn.vuejs.org/v2/guide/transitions.html#初始渲染的过渡" target="_blank" rel="external">vue2.0的文档</a>中还讲到了初始渲染的过渡、多个元素的过渡、多个组件的过渡和列表过渡，他们的过渡效果实现方式和单元素/组件的类似，我感觉实际项目中用的不太多吧，有兴趣的同学可以去了解一下，文档这里说的多个元素和多个组件<strong>和我们的理解可能不太一样</strong>，一定要仔细阅读文档，搞清楚到底说的是什么样的情况。</p>
<h1 id="什么是过渡"><a href="#什么是过渡" class="headerlink" title="什么是过渡"></a>什么是过渡</h1><p>Vue只有在插入，更新或者移除DOM元素时才会应用过渡效果，过渡效果的应用可以通过不同方式实现，官方文档中提到了如下几种：</p>
<ol>
<li>在CSS过渡和动画中自动应用class；</li>
<li>配合使用第三方的CSS动画库，如Animate.css；</li>
<li>在过渡钩子函数中使用JavaScript直接操作DOM；</li>
<li>配合使用第三方JavaScript动画库，如Velocity；</li>
</ol>
<p>上面四种方式其实主要就是两种，一个是利用CSS过渡或者动画，另一个是利用JavaScript钩子函数。</p>
<h2 id="怎么应用过渡到元素-组件上"><a href="#怎么应用过渡到元素-组件上" class="headerlink" title="怎么应用过渡到元素/组件上"></a>怎么应用过渡到元素/组件上</h2><p>要想使元素或者组件应用到我们所写的过渡动画，需要使用vue提供的transition来封装组件成为过渡组件，transition需要与如下情景中的任一种一起使用：</p>
<ul>
<li>v-if（条件渲染）</li>
<li>v-show（条件展示）</li>
<li>动态组件</li>
<li>在组建的根节点上，并且被vue实例DOM方法触发，如appendTo方法把组件添加到某个根节点上</li>
</ul>
<p>当需要插入或者删除封装成过渡元素的元素时，vue将做如下事情：</p>
<ol>
<li>查找目标元素是否有CSS过渡或者动画，如果有就在适当的时候进行处理；</li>
<li>如果过渡组件设置了JavaScript钩子函数，vue会在相应阶段调用钩子函数；</li>
<li>如果以上两者都没有，DOM操作（插入或者删除）就在下一帧立即执行。</li>
</ol>
<h1 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h1><p>先举一个典型的CSS过渡的例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 首先将要过渡的元素用transition包裹，并设置过渡的name，然后添加触发这个元素过渡的按钮（实际项目中不一定是按钮，任何能触发过渡组件的DOM操作的操作都可以） --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 接着为过渡类名添加规则</div><div class="line">&amp;.fade-enter-active, &amp;.fade-leave-active</div><div class="line">  transition: all 0.5s ease     </div><div class="line">&amp;.fade-enter, &amp;.fade-leave-active</div><div class="line">  opacity: 0</div></pre></td></tr></table></figure>
<p>封装上面的代码，就可以实现一个简单的动画了，CSS的transition属性是用来设置过渡总体效果的，具体可参考：<a href="http://www.w3cplus.com/content/css3-transition" target="_blank" rel="external">http://www.w3cplus.com/content/css3-transition</a>。</p>
<h2 id="CSS过渡类名"><a href="#CSS过渡类名" class="headerlink" title="CSS过渡类名"></a>CSS过渡类名</h2><p>组件过渡过程中，会有四个CSS类名进行切换，这四个类名与上面transition的name属性有关，比如name=”fade”，会有如下四个CSS类名：</p>
<ol>
<li>fade-enter：进入过渡的开始状态，元素被插入时生效，只应用一帧后立即删除；</li>
<li>fade-enter-active：进入过渡的结束状态，元素被插入时就生效，在过渡过程完成之后移除；</li>
<li>fade-leave：离开过渡的开始状态，元素被删除时触发，只应用一帧后立即删除；</li>
<li>fade-leave-active：离开过渡的结束状态，元素被删除时生效，离开过渡完成之后被删除；</li>
</ol>
<p>从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。<br>上面示例中，fade-enter和fade-leave-active类设置CSS为opacity:0，说明过渡刚进入和离开的时候透明度为0，即不显示。当然还可以设置其他的CSS属性，transform属性是除了opacity之外经常在这里被用到的，transform用法可参考<a href="http://www.w3cplus.com/content/css3-transition" target="_blank" rel="external">http://www.w3cplus.com/content/css3-transition</a></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>组件过渡的实现不仅可以通过CSS过渡还可以通过CSS动画(animation)实现，建议先了解一下<a href="http://www.w3cplus.com/content/css3-animation" target="_blank" rel="external">CSS3 Animation</a>，这里还是给个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fold"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.fold-enter-active</span> &#123;</div><div class="line">  <span class="attribute">animation-name</span>: fold-in;</div><div class="line">  <span class="attribute">animation-duration</span>: .<span class="number">5s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.fold-leave-active</span> &#123;</div><div class="line">  <span class="attribute">animation-name</span>: fold-out;</div><div class="line">  <span class="attribute">animation-duration</span>: .<span class="number">5s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> fold-in &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 100%, 0);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 50%, 0);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> fold-out &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 50%, 0);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 100%, 0);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果预先了解了CSS动画（上面给了链接），上面代码还是很好理解的，要注意的是CSS动画中，fold-enter类名在节点插入DOM后不会立即删除，而是在animationed事件触发时删除。</p>
<h2 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h2><p>上面的四个过渡类名都是根据transition的name属性自动生成的，那么能否自己定义这四个类名呢？答案是可以的，通过enter-class、enter-active-class、leave-class、leave-active-class这四个特性来定义。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> </span></div><div class="line">    <span class="attr">name</span>=<span class="string">"fade"</span></div><div class="line">    <span class="attr">enter-class</span>=<span class="string">"fade-in-enter"</span></div><div class="line">    <span class="attr">enter-active-class</span>=<span class="string">"fade-in-active"</span></div><div class="line">    <span class="attr">leave-class</span>=<span class="string">"fade-out-enter"</span></div><div class="line">    <span class="attr">leave-active-class</span>=<span class="string">"fade-out-active"</span></div><div class="line">  &gt;</div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&amp;.fade-in-active, &amp;.fade-out-active</div><div class="line">  transition: all 0.5s ease     </div><div class="line">&amp;.fade-in-enter, &amp;.fade-out-active</div><div class="line">  opacity: 0</div></pre></td></tr></table></figure>
<p>上面代码中，原来默认的fade-enter类对应fade-in-enter，fade-enter-active类对应fade-in-active，依次类推。</p>
<h1 id="JavaScript钩子函数"><a href="#JavaScript钩子函数" class="headerlink" title="JavaScript钩子函数"></a>JavaScript钩子函数</h1><p>除了用CSS过渡的动画来实现vue的组件过渡，还可以用JavaScript的钩子函数来实现，在钩子函数中直接操作DOM。我们可以在属性中声明以下钩子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span></span></div><div class="line">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></div><div class="line">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></div><div class="line">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></div><div class="line">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></div><div class="line">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></div><div class="line">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></div><div class="line">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></div><div class="line">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></div><div class="line">&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">methods: &#123;</div><div class="line">  <span class="comment">// 过渡进入</span></div><div class="line">  <span class="comment">// 设置过渡进入之前的组件状态</span></div><div class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡进入完成时的组件状态</span></div><div class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    done()</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡进入完成之后的组件状态</span></div><div class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">enterCancelled</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 过渡离开</span></div><div class="line">  <span class="comment">// 设置过渡离开之前的组件状态</span></div><div class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡离开完成时地组件状态</span></div><div class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    done()</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡离开完成之后的组件状态</span></div><div class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// leaveCancelled 只用于 v-show 中</span></div><div class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的钩子函数中可以进行任何你想做的DOM操作。<br><strong>小技巧</strong>：如果你只想设置组件过渡进入的效果而不想有组件过渡离开的效果，这时你就可以用钩子函数，只设置beforeEnter、enter、afterEnter这几个钩子函数就可以了。</p>
<p>目前接触到的关于vue transition相关的就这么多了，当然vue transition的用法可不止这么点，这需要我以后的慢慢积累。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue2.0的过渡系统（transition）有了很大的改变，想把1.0的项目迁移到2.0，着实需要费一些功夫，今天我就要把vue2.0的过渡系统的用法搞清楚，因为之前确实踩了不少坑。这里只涉及单元素/组件的过渡实现，&lt;a href=&quot;http://cn.vuejs.org
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="transition" scheme="http://yuhan.com/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之Generator函数</title>
    <link href="http://yuhan.com/2016/12/06/ES6-Generator/"/>
    <id>http://yuhan.com/2016/12/06/ES6-Generator/</id>
    <published>2016-12-06T13:27:34.000Z</published>
    <updated>2016-12-08T00:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前断断续续接触到了一些ES6的知识，异步编程方面听得比较多的就是Promise，直到最近比较系统地学习了ES6的新特性才发现Generator这个神奇的存在，它可以实现一些前所未有的事情，让我顿时对它充满了兴趣。</p>
<h1 id="为什么需要Generator？"><a href="#为什么需要Generator？" class="headerlink" title="为什么需要Generator？"></a>为什么需要Generator？</h1><p>JavaScript异步编程是为解决JavaScript执行环境是“单线程”这个问题的。在JavaScript中，异步编程的使用非常频繁，也经常会出现需要逐步完成多个异步操作的情况。之前用回调函数实现异步编程如果碰到了这种问题就需要嵌套使用回调函数，异步操作越多，嵌套得就越深，这样非常不利于代码的维护，代码阅读起来也很困难。Generator函数是ES6提出的一种异步编程解决方案，它可以避免回调的嵌套，但是它的用处可不仅仅如此哦，待我细细道来。</p>
<h1 id="举个小例子"><a href="#举个小例子" class="headerlink" title="举个小例子"></a>举个小例子</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g1 = gen1();</div><div class="line">g1.next();  <span class="comment">// Object &#123;value: 1, done: false&#125;</span></div><div class="line">g1.next();  <span class="comment">// Object &#123;value: "hello", done: false&#125;</span></div><div class="line">g1.next();  <span class="comment">// Object &#123;value: true, done: true&#125;</span></div><div class="line">g1.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>上面的代码就定义了一个Generator函数，Generator函数的定义跟普通函数差不多，只是在function关键字后面加了一个星号。调用Generator函数后和普通函数不同的是，该函数并不立即执行，也不返回函数执行结果，而是返回一个指向内部状态的generator对象，也可以看作是一个遍历器对象。然后必须调用该对象的next方法，让函数继续走下去，是指针移向下一个状态。每当碰到yield语句,内部指针就停下来，直到下一次调用next()才开始执行。<br>上面代码调用了四次next方法，遍历才结束。next方法会返回一个有两个属性的对象，value属性的值为当前yield语句的值，done属性的值表示遍历是否结束，即最后一次调用next方法时，再也碰不到yield或者return语句了。<br><strong>星号写在哪</strong>：<br>function关键字和函数名之间的星号写在哪都可以，只要在两者之间即可，但是一般都采取我上面代码的那种写法。</p>
<h2 id="Generator函数本质"><a href="#Generator函数本质" class="headerlink" title="Generator函数本质"></a>Generator函数本质</h2><p>上面说了那么多，想必大家已经知道Generator函数是怎么用的了，那么Generator本质上到底是个啥呢？Generator函数的理解有多种：</p>
<ol>
<li>Generator函数可以被理解成一个状态机，里面封装了多种状态，有兴趣的同学可以去了解一下状态机，操作系统的书里都会讲到。</li>
<li>Generator函数还可以被理解成一个遍历器对象生成器，它返回的遍历器对象可以依次遍历Generator函数内部的每一个状态。这就是为什么之前说Generator函数不仅是为了解决回调函数嵌套问题。Generator函数是生成一个对象，但是调用的时候前面<strong>不能加new命令</strong>。</li>
</ol>
<h1 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h1><p>yield语句是Generator函数内部可以暂停执行程序的语句，yield语句后面的值可以是各种数据类型，字符串，整数，布尔值等等都可以。这里主要想说说Generator函数中yield语句和return语句的区别。</p>
<h2 id="和return语句区别"><a href="#和return语句区别" class="headerlink" title="和return语句区别"></a>和return语句区别</h2><p>从上面的例子可以看出，函数不仅是碰到yield语句才会停止执行，碰到return语句也会停止执行。这很容易理解，不管怎样Generator函数也是一个函数，碰到return语句必然会停止执行，返回值。那么，两者的区别是什么呢？先来看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g2 = gen2();</div><div class="line">g2.next();  <span class="comment">// Object &#123;value: true, done: true&#125;</span></div><div class="line">g2.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>从上面例子可以看出，当碰到return语句时，返回对象的done属性值就为true，遍历结束，不管后面是否还有yield或者return语句。这种区别本质上是因为yield语句具备位置记忆功能而return语句则没有该功能。</p>
<h2 id="再说一点"><a href="#再说一点" class="headerlink" title="再说一点"></a>再说一点</h2><p>Generator函数，不管内部有没有yield语句，调用函数时都不会执行任何语句，只有当调用next(),内部语句才会执行，只要调用next()，就会返回一个对象。yield语句只是函数暂停执行的一个标记。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了么？'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g3 = gen3();  <span class="comment">// 没有任何输出</span></div><div class="line">g3.next();</div><div class="line"><span class="comment">// 执行了么？</span></div><div class="line"><span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：yield函数不能在普通函数中使用，否则会报错。</p>
<h1 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h1><p>除了yield语句，next方法也是Generator函数实现中很重要的特性。既然next()是一个函数，那么这个函数可以带参数么，当然可以。上面的例子比较简单，都只是一些单纯的yield语句，其实Generator函数和普通函数一样里面是可以进行各种复杂的计算和操作的，也可以有各种循环语句，不仅next方法可以传参数，Generator函数也是可以传参数的，立马上例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen4</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> (a + <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> b * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g4 = gen4(<span class="number">1</span>);</div><div class="line">g4.next();  <span class="comment">//  Object &#123;value: 2, done: false&#125;</span></div><div class="line">g4.next();  <span class="comment">//  Object &#123;value: NaN, done: true&#125;</span></div><div class="line"><span class="keyword">let</span> g5 = gen4(<span class="number">1</span>);</div><div class="line">g5.next();  <span class="comment">//  Object &#123;value: 2, done: false&#125;</span></div><div class="line">g5.next(<span class="number">3</span>);  <span class="comment">//  Object &#123;value: 6, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面例子中，Generator函数需要接收一个参数a，表面上变量b是用yield语句赋值了，但是遗憾的是这个赋值好像并没有成功，当第二次调用next方法（没有传参数）时，返回的对象value值居然为NaN，而不是我们想的 2 *（1+1）= 4。但是如果第二次调用next方法时，传入一个参数3，返回对象的value值就为6。这可以说明两点：</p>
<ol>
<li>yield语句没有返回值，或者总是返回undefined；</li>
<li>next方法如果带上一个参数，这个参数就是作为上一个yield语句的返回值。</li>
</ol>
<p><strong>注意</strong>：因为next方法表示上一个yield语句的返回值，所以必须有上一个yield语句的存在，那么第一次调用next方法时就不能传参数。第一个next只是用来启动Generator函数内部的遍历器，传参也没有多大意义。</p>
<h1 id="再说Generator函数与普通函数区别"><a href="#再说Generator函数与普通函数区别" class="headerlink" title="再说Generator函数与普通函数区别"></a>再说Generator函数与普通函数区别</h1><h2 id="可以用prototype么？"><a href="#可以用prototype么？" class="headerlink" title="可以用prototype么？"></a>可以用prototype么？</h2><p>虽然Generator函数和普通函数区别很大，但是Generator函数的实例也可以继承Generator函数的prototype对象上的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen5</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">gen5.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'有generator?'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g6 = gen5();</div><div class="line">g6.say();  <span class="comment">// 有generator?</span></div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出，Generator函数返回的g6，继承了gen5.prototype。</p>
<h2 id="this咋用？"><a href="#this咋用？" class="headerlink" title="this咋用？"></a>this咋用？</h2><p>大家都知道普通函数都会有一个this对象，那么Generator的this对象怎么用呢？还是例子更直观：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen6</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g7 = gen6();</div><div class="line">g7.a;  <span class="comment">//  undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，Generator函数在this对象上添加了一个属性a，g7实例并不能取到这个属性。那么怎么让Generator函数返回一个可以正常使用this对象的实例呢？阮一峰老师提供了一种方法，首先，生成一个空对象，使用call方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。参考代码在这：<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/generator</a></p>
<h1 id="Generator函数与Iterator"><a href="#Generator函数与Iterator" class="headerlink" title="Generator函数与Iterator"></a>Generator函数与Iterator</h1><p>Generator函数返回的是一个遍历器对象，那么它在遍历这方面肯定有用武之地。实际上遍历器最简单的实现就是使用Generator函数。遍历器（Iterator）也是ES6种一个很重要的新特性，参考资料：<a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/iterator</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前断断续续接触到了一些ES6的知识，异步编程方面听得比较多的就是Promise，直到最近比较系统地学习了ES6的新特性才发现Generator这个神奇的存在，它可以实现一些前所未有的事情，让我顿时对它充满了兴趣。&lt;/p&gt;
&lt;h1 id=&quot;为什么需要Generator？&quot;&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://yuhan.com/tags/ES6/"/>
    
      <category term="generator" scheme="http://yuhan.com/tags/generator/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之Symbol</title>
    <link href="http://yuhan.com/2016/12/05/ES6-symbol/"/>
    <id>http://yuhan.com/2016/12/05/ES6-symbol/</id>
    <published>2016-12-05T09:03:43.000Z</published>
    <updated>2017-03-04T07:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术日新月异，不断有新技术出现，我们就需要不断地学习新知识，虽然ES6已经提出很久了，但是最近我才有时间静下心来好好学习一下里面提出的新规则。今天总结下ES6提出的这个新的原始数据类型–Symbol。</p>
<h1 id="为啥需要Symbol"><a href="#为啥需要Symbol" class="headerlink" title="为啥需要Symbol"></a>为啥需要Symbol</h1><p>一个新规则的提出，必然是因为有需求，熟悉ES5的人都知道，ES5里面对象的属性名都是字符串，如果你需要使用一个别人提供的对象，你对这个对象有哪些属性也不是很清楚，但又想为这个对象新增一些属性，那么你新增的属性名就很可能和原来的属性名发送冲突，显然我们是不希望这种情况发生的。所以，我们需要确保每个属性名都是独一无二的，这样就可以防止属性名的冲突了。因此，ES6里就引入了Symbol，用它来产生一个独一无二的值。</p>
<h1 id="Symbol是什么"><a href="#Symbol是什么" class="headerlink" title="Symbol是什么"></a>Symbol是什么</h1><p>我们已经知道ES6中引入了一个叫Symbol的东西，但是这个东西到底是什么呢？是一个函数还是一个对象或者是其他什么？Symbol实际上是ES6引入的一种原始数据类型，除了Symbol，JavaScript还有其他5种数据类型，分别是Undefined、Null、Boolean、String、Number，这5种数据类型都是ES5中就有的。</p>
<h1 id="怎么生成一个Symbol类型的值"><a href="#怎么生成一个Symbol类型的值" class="headerlink" title="怎么生成一个Symbol类型的值"></a>怎么生成一个Symbol类型的值</h1><p>既然我们已经知道了Symbol是一种原始的数据类型，那么怎么生成这种数据类型的值呢？Symbol值是通过Symbol函数生成的，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// Symbol()</span></div><div class="line"><span class="keyword">typeof</span> s;  <span class="comment">// "symbol"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，s就是一个Symbol类型的值，它是独一无二的。</p>
<h2 id="Symbol函数前不能用new"><a href="#Symbol函数前不能用new" class="headerlink" title="Symbol函数前不能用new"></a>Symbol函数前不能用new</h2><p>Symbol函数不是一个构造函数，前面不能用new操作符。所以Symbol类型的值也不是一个对象，不能添加任何属性，它只是一个类似于字符型的数据类型。如果强行在Symbol函数前加上new操作符，会报错，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Symbol</span>();</div><div class="line"><span class="comment">// Uncaught TypeError: Symbol is not a constructor(…)</span></div></pre></td></tr></table></figure></p>
<h2 id="Symbol函数的参数"><a href="#Symbol函数的参数" class="headerlink" title="Symbol函数的参数"></a>Symbol函数的参数</h2><h3 id="字符串作为参数"><a href="#字符串作为参数" class="headerlink" title="字符串作为参数"></a>字符串作为参数</h3><p>用上面的方法生成的Symbol值不好进行区分，Symbol函数还可以接受一个字符串参数，来对产生的Symbol值进行描述，方便我们区分不同的Symbol值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>);</div><div class="line"><span class="built_in">console</span>.log(s1);  <span class="comment">// Symbol(s1)</span></div><div class="line"><span class="built_in">console</span>.log(s2);  <span class="comment">// Symbol(s2)</span></div><div class="line">s1 === s2;  <span class="comment">//  false</span></div><div class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>);</div><div class="line">s2 === s3;  <span class="comment">//  false</span></div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出：</p>
<ol>
<li>给Symbol函数加了参数之后，控制台输出的时候可以区分到底是哪一个值；</li>
<li>Symbol函数的参数只是对当前Symbol值的描述，因此相同参数的Symbol函数返回值是不相等的；</li>
</ol>
<h3 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h3><p>如果Symbol函数的参数是一个对象，就会调用该对象的toString方法，将其转化为一个字符串，然后才生成一个Symbol值。所以，说到底，Symbol函数的参数只能是字符串。</p>
<h3 id="Symbol值可以进行运算么？"><a href="#Symbol值可以进行运算么？" class="headerlink" title="Symbol值可以进行运算么？"></a>Symbol值可以进行运算么？</h3><p>既然Symbol是一种数据类型，那我们一定想知道Symbol值是否能进行运算。告诉你，Symbol值是不能进行运算的,不仅不能和Symbol值进行运算，也不能和其他类型的值进行运算，否则会报错。<br>Symbol值可以显式转化为字符串和布尔值，但是不能转为数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mysym1 = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</div><div class="line">mysym1.toString() <span class="comment">//  'Symbol('my symbol')'</span></div><div class="line"><span class="built_in">String</span>(mysym1)  <span class="comment">//  'Symbol('my symbol')'</span></div><div class="line"><span class="keyword">var</span> mysym2 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">Boolean</span>(mysym2);  <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>(mysym2)  <span class="comment">// TypeError: Cannot convert a Symbol value to a number(…)</span></div></pre></td></tr></table></figure></p>
<h3 id="Symbol如何作为属性名"><a href="#Symbol如何作为属性名" class="headerlink" title="Symbol如何作为属性名"></a>Symbol如何作为属性名</h3><p>Symbol就是为对象的属性名而生，那么Symbol值怎么作为对象的属性名呢？有下面几种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="comment">// 第一种写法</span></div><div class="line">a[s4] = <span class="string">'mySymbol'</span>;</div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line">a = &#123;</div><div class="line">    [s4]: <span class="string">'mySymbol'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 第三种写法</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(a, s4, &#123;<span class="attr">value</span>: <span class="string">'mySymbol'</span>&#125;);</div><div class="line">a.s4;  <span class="comment">//  undefined</span></div><div class="line">a.s4 = <span class="string">'mySymbol'</span>;</div><div class="line">a[s4]  <span class="comment">//  undefined</span></div><div class="line">a[<span class="string">'s4'</span>]  <span class="comment">// 'mySymbol'</span></div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出：</p>
<ol>
<li>使用对象的Symbol值作为属性名时，获取相应的属性值不能用点运算符；</li>
<li>如果用点运算符来给对象的属性赋Symbol类型的值，实际上属性名会变成一个字符串，而不是一个Symbol值；</li>
<li>在对象内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中，否则只是一个字符串。</li>
</ol>
<h2 id="Symbol值作为属性名的遍历"><a href="#Symbol值作为属性名的遍历" class="headerlink" title="Symbol值作为属性名的遍历"></a>Symbol值作为属性名的遍历</h2><p>使用for…in和for…of都无法遍历到Symbol值的属性，Symbol值作为对象的属性名，也无法通过Object.keys()、Object.getOwnPropertyNames()来获取了。但是，不同担心，这种平常的需求肯定是会有解决办法的。我们可以使用Object.getOwnPropertySymbols()方法获取一个对象上的Symbol属性名。也可以使用Reflect.ownKeys()返回所有类型的属性名，包括常规属性名和 Symbol属性名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>(<span class="string">'s5'</span>);</div><div class="line"><span class="keyword">let</span> s6 = <span class="built_in">Symbol</span>(<span class="string">'s6'</span>);</div><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    [s5]: <span class="string">'s5'</span>,</div><div class="line">    [s6]: <span class="string">'s6'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(a);   <span class="comment">// [Symbol(s5), Symbol(s6)]</span></div><div class="line">a.hello = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">Reflect</span>.ownKeys(a);  <span class="comment">//  ["hello", Symbol(s5), Symbol(s6)]</span></div></pre></td></tr></table></figure></p>
<p>利用Symbol值作为对象属性的名称时，不会被常规方法遍历到这一特性，可以为对象定义一些非私有的但是又希望只有内部可用的方法。</p>
<h2 id="Symbol-for-和Symbol-keyFor"><a href="#Symbol-for-和Symbol-keyFor" class="headerlink" title="Symbol.for()和Symbol.keyFor()"></a>Symbol.for()和Symbol.keyFor()</h2><p>Symbol.for()函数也可以用来生成Symbol值，但该函数有一个特殊的用处，就是可以重复使用一个Symbol值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s7 = <span class="built_in">Symbol</span>.for(<span class="string">'s7'</span>);</div><div class="line"><span class="built_in">console</span>.log(s7); <span class="comment">// Symbol(s7)</span></div><div class="line">s7.toString(); <span class="comment">// "Symbol(s7)"</span></div><div class="line"><span class="keyword">let</span> s8 = <span class="built_in">Symbol</span>.for(<span class="string">'s7'</span>);</div><div class="line">s7 === s8 <span class="comment">//  true</span></div><div class="line"><span class="keyword">let</span> s9 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s9); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">Symbol</span>.keyFor(s8); <span class="comment">// "s8"</span></div></pre></td></tr></table></figure></p>
<p><strong>Symbol.for()</strong>函数要接受一个字符串作为参数，先搜索有没有以该参数作为名称的Symbol值，如果有，就直接返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。上面代码中，s7和s8实际上就是同一个Symbol值，所以两者是相等的。<br><strong>Symbol.keyFor()</strong>函数是用来查找一个Symbol值的登记信息的，Symbol()写法没有登记机制，所以返回undefined；而Symbol.for()函数会将生成的Symbol值登记在全局环境中，所以Symbol.keyFor()函数可以查找到用Symbol.for()函数生成的Symbol值。</p>
<h2 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h2><p>ES6提供了11个内置的Symbol值，分别是Symbol.hasInstance 、Symbol.isConcatSpreadable 、Symbol.species 、Symbol.match 、Symbol.replace 、Symbol.search 、Symbol.split 、Symbol.iterator 、Symbol.toPrimitive 、Symbol.toStringTag 、Symbol.unscopables 等。<br>有兴趣的可以自行了解：<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/symbol</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端技术日新月异，不断有新技术出现，我们就需要不断地学习新知识，虽然ES6已经提出很久了，但是最近我才有时间静下心来好好学习一下里面提出的新规则。今天总结下ES6提出的这个新的原始数据类型–Symbol。&lt;/p&gt;
&lt;h1 id=&quot;为啥需要Symbol&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://yuhan.com/tags/ES6/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="symbol" scheme="http://yuhan.com/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>echarts画图实例讲解</title>
    <link href="http://yuhan.com/2016/11/19/how-to-use-echarts/"/>
    <id>http://yuhan.com/2016/11/19/how-to-use-echarts/</id>
    <published>2016-11-19T11:16:22.000Z</published>
    <updated>2016-12-05T13:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天分享了一个项目(<a href="http://hyuhan.com/2016/11/17/A-data-display-platform/" target="_blank" rel="external">http://hyuhan.com/2016/11/17/A-data-display-platform/</a>)，里面用到了echarts（一个纯Javascript的图表库）来画图，项目中用到了它的字符云图，地图，柱状图，饼图等，今天就给大家分享一些一些实现的细节。建议先去看看<a href="http://echarts.baidu.com/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="external">五分钟上手Echarts</a>再来看这篇博客。</p>
<h1 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h1><p>Echarts百度地图扩展，可以在百度地图上进一步展现点图，线图，热力图等，我主要在百度地图上展现的是气泡图。</p>
<h2 id="引入百度地图"><a href="#引入百度地图" class="headerlink" title="引入百度地图"></a>引入百度地图</h2><ul>
<li>首先引入百度地图的jssdk，需要使用在百度地图开发者平台申请的ak</li>
<li>然后引入Echarts</li>
<li>最后引入百度地图扩展bmap（已经打包在echarts包中）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak=你的ak"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts/dist/echarts.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts/dist/extension/bmap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h2><p>百度地图引入之后，主要就是设置参数了，以我画的最喜爱建筑分布图为例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    <span class="comment">// 设置标题样式</span></div><div class="line">    title: &#123;</div><div class="line">        <span class="comment">// 标题文本</span></div><div class="line">        text: <span class="string">'学生最喜爱学校建筑分布'</span>,</div><div class="line">        <span class="comment">// 标题离容器左侧的距离，center表示水平居中</span></div><div class="line">        left: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">15</span>, </div><div class="line">        <span class="comment">// 标题文本的样式设置</span></div><div class="line">        textStyle: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">24</span>,</div><div class="line">            <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">            <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 提示框设置为由数据项图形触发</span></div><div class="line">    tooltip: &#123;</div><div class="line">        <span class="attr">trigger</span>: <span class="string">'item'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 添加保存为图片和数据视图工具工具栏</span></div><div class="line">    toolbox: &#123;</div><div class="line">        <span class="attr">feature</span>: &#123;</div><div class="line">            <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">            <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: <span class="number">15</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">10</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 加载bmap组件</span></div><div class="line">    bmap: &#123;</div><div class="line">        <span class="comment">// 百度地图中心经纬度（设置为你需要的地图中心即可）</span></div><div class="line">        center: [<span class="number">114.427877</span>, <span class="number">30.517249</span>],</div><div class="line">        <span class="comment">// 百度地图缩放比例（按需配置）</span></div><div class="line">        zoom: <span class="number">15</span>,</div><div class="line">        <span class="comment">// 是否开启拖拽缩放</span></div><div class="line">        roam: <span class="literal">true</span>,</div><div class="line">        <span class="comment">// 设置百度地图样式（可参考http://developer.baidu.com/map/jsdevelop-11.htm）</span></div><div class="line">        mapStyle: &#123;</div><div class="line">            <span class="attr">style</span>: <span class="string">'light'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">series</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'最喜爱建筑'</span>,</div><div class="line">            <span class="comment">// 图标类型设置为气泡图</span></div><div class="line">            type: <span class="string">'scatter'</span>,</div><div class="line">            <span class="comment">// 设置坐标系为前面提到的bmap</span></div><div class="line">            coordinateSystem: <span class="string">'bmap'</span>,</div><div class="line">            <span class="comment">// 数据</span></div><div class="line">            data: [&#123;&#125;],</div><div class="line">            <span class="comment">// 气泡标记大小</span></div><div class="line">            symbolSize: ,</div><div class="line">            <span class="attr">label</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                    <span class="attr">formatter</span>: <span class="string">'&#123;b&#125;'</span>,</div><div class="line">                    <span class="attr">position</span>: <span class="string">'right'</span>,</div><div class="line">                    <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                    <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">itemStyle</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                    <span class="attr">color</span>: <span class="string">'rgba(11, 110, 72, 1)'</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    ]    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外给大家推荐一个百度的<a href="http://api.map.baidu.com/lbsapi/getpoint/index.html" target="_blank" rel="external">拾取坐标系统</a>，挺好用的。</p>
<h1 id="字符云图"><a href="#字符云图" class="headerlink" title="字符云图"></a>字符云图</h1><p>之前一直觉得字符云是个很酷炫的东西，所以这次也就强行把它用上了，嘿嘿。里面的数据是我根据群聊记录分析出来的高频词汇。Echarts的字符云是基于<a href="https://github.com/timdream/wordcloud2.js" target="_blank" rel="external">wordcloud2.js</a>的。  </p>
<h2 id="引入字符云"><a href="#引入字符云" class="headerlink" title="引入字符云"></a>引入字符云</h2><h3 id="直接下载js文件并引入"><a href="#直接下载js文件并引入" class="headerlink" title="直接下载js文件并引入"></a>直接下载js文件并引入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts-wordcloud.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="webpack引入"><a href="#webpack引入" class="headerlink" title="webpack引入"></a>webpack引入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install echarts-wordcloud</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import echarts from &apos;echarts&apos;</div><div class="line">import &apos;echarts-wordcloud&apos;</div></pre></td></tr></table></figure>
<h2 id="设置参数-1"><a href="#设置参数-1" class="headerlink" title="设置参数"></a>设置参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    <span class="attr">title</span>: &#123;</div><div class="line">        <span class="attr">text</span>: title,</div><div class="line">        <span class="attr">textStyle</span>: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">26</span>,</div><div class="line">            <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">            <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">20</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toolbox</span>: &#123;</div><div class="line">        <span class="attr">feature</span>: &#123;</div><div class="line">            <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">            <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: <span class="number">20</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">20</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">series</span>: [&#123;</div><div class="line">        <span class="comment">// 设置图表类型为'wordCloud'</span></div><div class="line">        type: <span class="string">'wordCloud'</span>,</div><div class="line">        <span class="comment">// 设置cloud的形状</span></div><div class="line">        shape: <span class="string">'cardioid'</span>,</div><div class="line">        <span class="comment">// shape: 'pentagon',</span></div><div class="line">        <span class="comment">// shape: 'circle',</span></div><div class="line">        left: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">30</span>,</div><div class="line">        <span class="attr">width</span>: <span class="string">'75%'</span>,</div><div class="line">        <span class="attr">height</span>: <span class="string">'80%'</span>,</div><div class="line">        <span class="comment">// 设置字符字体大小的范围</span></div><div class="line">        sizeRange: [<span class="number">12</span>, <span class="number">75</span>],</div><div class="line">        <span class="comment">// 设置字符旋转的角度范围</span></div><div class="line">        rotationRange: [<span class="number">-90</span>, <span class="number">90</span>],</div><div class="line">        <span class="attr">rotationStep</span>: <span class="number">45</span>,</div><div class="line">        <span class="comment">// 字符间距</span></div><div class="line">        gridSize: <span class="number">8</span>,</div><div class="line">        <span class="comment">// 字符字体样式</span></div><div class="line">        textStyle: &#123;</div><div class="line">            <span class="attr">normal</span>: &#123;</div><div class="line">                <span class="attr">fontFamily</span>: <span class="string">'Microsoft Yahei'</span>,</div><div class="line">                <span class="attr">fontWeight</span>: <span class="string">'bold'</span>,</div><div class="line">                <span class="comment">// 字符字体颜色用一个函数随机设置</span></div><div class="line">                color: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">'rgb('</span> + [</div><div class="line">                        <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">160</span>),</div><div class="line">                        <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">160</span>),</div><div class="line">                        <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">160</span>)</div><div class="line">                    ].join(<span class="string">','</span>) + <span class="string">')'</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">emphasis</span>: &#123;</div><div class="line">                <span class="attr">shadowBlur</span>: <span class="number">10</span>,</div><div class="line">                <span class="attr">shadowColor</span>: <span class="string">'#333'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// data必选包含name和value选项,name即为显示的字符，value越大字符字体大小越大</span></div><div class="line">        data: [&#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">''</span>,</div><div class="line">            <span class="attr">value</span>: ,   </div><div class="line">            <span class="attr">textStyle</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;&#125;,</div><div class="line">                <span class="attr">emphasis</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,&#123;...&#125;,...]</div><div class="line">    &#125;]   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="画热力图"><a href="#画热力图" class="headerlink" title="画热力图"></a>画热力图</h1><p>根据班级群聊数据分析出来的同学之间亲密度，思前想后最后决定用热力图。热力图不需要额外的插件，直接讲参数设置。</p>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    <span class="attr">title</span>: &#123;</div><div class="line">        <span class="attr">text</span>: <span class="string">'通信1502班同学关系密切度分析图（仅通过群聊数据分析）'</span>,</div><div class="line">        <span class="comment">// 子标题</span></div><div class="line">        subtext: <span class="string">'数值越大两者越亲密'</span>,</div><div class="line">        <span class="attr">subtextStyle</span>: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">16</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">4</span>,</div><div class="line">        <span class="attr">textStyle</span>: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">22</span>,</div><div class="line">            <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">            <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">tooltip</span>: &#123;</div><div class="line">        <span class="attr">trigger</span>: <span class="string">'item'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toolbox</span>: &#123;</div><div class="line">        <span class="attr">feature</span>: &#123;</div><div class="line">            <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">            <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: <span class="number">15</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">grid</span>: &#123;</div><div class="line">        <span class="attr">height</span>: <span class="string">'78%'</span>,</div><div class="line">        <span class="attr">bottom</span>: <span class="string">'14%'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// x轴设置</span></div><div class="line">    xAxis: &#123;</div><div class="line">        <span class="comment">// 坐标轴为类目轴</span></div><div class="line">        type: <span class="string">'category'</span>,</div><div class="line">        <span class="comment">// 数组，x轴显示的刻度标签</span></div><div class="line">        data: [...],</div><div class="line">        <span class="comment">// 刻度标签相关设置</span></div><div class="line">        axisLabel: &#123;</div><div class="line">            <span class="comment">// 如果水平放不下，可以旋转</span></div><div class="line">            rotate: <span class="number">60</span>,</div><div class="line">            <span class="comment">// 刻度标签显示间隔</span></div><div class="line">            interval: <span class="number">0</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">splitArea</span>: &#123;</div><div class="line">            <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">yAxis</span>: &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">'category'</span>,</div><div class="line">        <span class="attr">data</span>: [...],</div><div class="line">        <span class="attr">splitArea</span>: &#123;</div><div class="line">            <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">        &#125;  </div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 视觉映射组件，也就是项目展示中热力图最小面现实的那个组件</span></div><div class="line">    visualMap: &#123;</div><div class="line">        <span class="comment">// 组件允许的最小值和最大值</span></div><div class="line">        min: <span class="number">0</span>,</div><div class="line">        <span class="attr">max</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">calculable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="comment">// 组件高度</span></div><div class="line">        itemheight: <span class="number">300</span>,</div><div class="line">        <span class="comment">// 组件水平放置</span></div><div class="line">        orient: <span class="string">'horizontal'</span>,</div><div class="line">        <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">bottom</span>: <span class="string">'3%'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">series</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'亲密度'</span>,</div><div class="line">            <span class="comment">// 图标类型为heatmap</span></div><div class="line">            type: <span class="string">'heatmap'</span>,</div><div class="line">            <span class="comment">// 二维数组，每个数据项都是一个一维的数组，前两个值表示直角坐标系上的x,y，第三个至表示大小。</span></div><div class="line">            data: [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>],[]...],</div><div class="line">            <span class="attr">label</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                  <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">itemStyle</span>: &#123;</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                    <span class="attr">shadowBlur</span>: <span class="number">10</span>,</div><div class="line">                    <span class="attr">shadowColor</span>: <span class="string">'rgba(0, 0, 0, 0.5)'</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饼图和条形图比较基础，可以参考<a href="http://echarts.baidu.com/examples.html" target="_blank" rel="external">官方实例</a>,建议仔细阅读官方<a href="http://echarts.baidu.com/option.html" target="_blank" rel="external">配置文档</a>，可以自己画出各种有趣的图形来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天分享了一个项目(&lt;a href=&quot;http://hyuhan.com/2016/11/17/A-data-display-platform/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hyuhan.com/2016/11/17/A-
    
    </summary>
    
      <category term="echarts" scheme="http://yuhan.com/categories/echarts/"/>
    
    
      <category term="echarts" scheme="http://yuhan.com/tags/echarts/"/>
    
      <category term="可视化" scheme="http://yuhan.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基于vue、vuex、vue-router、echarts搭建的数据展示平台</title>
    <link href="http://yuhan.com/2016/11/17/A-data-display-platform/"/>
    <id>http://yuhan.com/2016/11/17/A-data-display-platform/</id>
    <published>2016-11-17T01:14:05.000Z</published>
    <updated>2016-12-05T13:10:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的好久没有更新博客了，但是我最近并没有偷懒哦，一直在学习vue这个框架，并且用它做了一个小项目，现在就给大家分享一下我的这个还比较有意思的小项目，项目是基于vue2.0开发的。</p>
<h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>这是一个数据可视化相关的项目，作为一个学生班主任，需要对班上同学的各方面的情况都有所了解，于是我便做了一个问卷调查来了解学生各方面的情况。然后我又想到可以分析我们班的群聊记录呀，根据群聊记录可以得到班上同学之间的亲密度和班级群聊活跃度等信息。自然而然，我就想着可以搭建一个平台来展示这些数据，既然是数据当然是以图表的方式来展示更加直观，然后折中选择了echarts这个图表库。至于为什么要选择用vue这个插件，之前只是觉得学习了vue刚好可以练练手，做完之后发现vue真的很轻量也很好上手，结合vuex和vue-router基本能完成我项目中的所有需求。      </p>
<blockquote>
<p>在线展示：<a href="http://119.29.57.165:8080/family" target="_blank" rel="external">http://119.29.57.165:8080/family</a>  （请用电脑打开，还没适配移动端）<br>源码：<a href="https://github.com/hieeyh/tong2-family" target="_blank" rel="external">https://github.com/hieeyh/tong2-family</a><br><strong>本教程是基于你已经有一定vue基础之上的，如果你还不了解什么是vue建议先去学习一下</strong></p>
</blockquote>
<h2 id="项目初始构建"><a href="#项目初始构建" class="headerlink" title="项目初始构建"></a>项目初始构建</h2><p>首先全局安装vue-cli，vue-cli是vue自己的项目构建工具，几个简单的步骤就可以帮助你快速构建一个vue项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g vue-cli</div></pre></td></tr></table></figure></p>
<p>然后，利用vue-cli构建一个vue项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 创建一个基于 &quot;webpack&quot; 模板的新项目</div><div class="line">$ vue init webpack family</div><div class="line"># 安装项目依赖</div><div class="line">$ cd family</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<h3 id="项目文件解释"><a href="#项目文件解释" class="headerlink" title="项目文件解释"></a>项目文件解释</h3><ul>
<li>build中是webpack基本配置文件，开发环境配置文件，生产环节配置文件</li>
<li>node_modules是各种依赖模块</li>
<li>src中是vue组件及入口文件</li>
<li>static中放置静态文件（群聊分析之后得到的json数据就放在这里）</li>
<li>index.html是页面入口文件</li>
</ul>
<h2 id="基本页面实现"><a href="#基本页面实现" class="headerlink" title="基本页面实现"></a>基本页面实现</h2><p>项目创建好之后，就开始实现自己想要的页面了，修改src文件夹下的App.vue文件，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 导航栏 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-head</span>&gt;</span><span class="tag">&lt;/<span class="name">my-head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-nav</span>&gt;</span><span class="tag">&lt;/<span class="name">my-nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-foot</span>&gt;</span><span class="tag">&lt;/<span class="name">my-foot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">import myHead from './components/header'</div><div class="line">import myNav from './components/nav'</div><div class="line">import myFoot from './components/foot'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  name: 'app',</div><div class="line">  components: &#123;</div><div class="line">    myHead,</div><div class="line">    myNav,</div><div class="line">    myFoot</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>myHead组件是页面头部，myNav组件是页面左侧导航栏，myFoot是页面底部，router-view组件是vue-router中渲染路径匹配到的视图组件。每个组件的具体实现可以去github项目地址去看源码。</p>
<h2 id="创建配置路由"><a href="#创建配置路由" class="headerlink" title="创建配置路由"></a>创建配置路由</h2><p>显然，我要做的是一个单页面应用，要用到vue-router，先安装vue-router，输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save vue-router</div></pre></td></tr></table></figure></p>
<p>然后，在src文件夹下面的main.js文件中添加路由相关的代码，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"></div><div class="line">Vue.use(VueRouter) </div><div class="line"><span class="comment">// 定义路由组件</span></div><div class="line"><span class="keyword">const</span> Worldcloud = <span class="built_in">require</span>(<span class="string">'./components/cloud.vue'</span>)</div><div class="line"><span class="keyword">const</span> Building = <span class="built_in">require</span>(<span class="string">'./components/building.vue'</span>)</div><div class="line"><span class="keyword">const</span> Canteen = <span class="built_in">require</span>(<span class="string">'./components/canteen.vue'</span>)</div><div class="line"><span class="keyword">const</span> Selfstudy = <span class="built_in">require</span>(<span class="string">'./components/selfstudy.vue'</span>)</div><div class="line"><span class="keyword">const</span> Difficult = <span class="built_in">require</span>(<span class="string">'./components/difficult.vue'</span>)</div><div class="line"><span class="keyword">const</span> Interest = <span class="built_in">require</span>(<span class="string">'./components/interest.vue'</span>)</div><div class="line"><span class="keyword">const</span> Bedroom = <span class="built_in">require</span>(<span class="string">'./components/bedroom.vue'</span>)</div><div class="line"><span class="keyword">const</span> Graduate = <span class="built_in">require</span>(<span class="string">'./components/graduate.vue'</span>)</div><div class="line"><span class="keyword">const</span> Getup = <span class="built_in">require</span>(<span class="string">'./components/getup.vue'</span>)</div><div class="line"><span class="keyword">const</span> Gotobed = <span class="built_in">require</span>(<span class="string">'./components/gotobed.vue'</span>)</div><div class="line"><span class="keyword">const</span> Eat = <span class="built_in">require</span>(<span class="string">'./components/eat.vue'</span>)</div><div class="line"><span class="keyword">const</span> Amuse = <span class="built_in">require</span>(<span class="string">'./components/amuse.vue'</span>)</div><div class="line"><span class="keyword">const</span> Single = <span class="built_in">require</span>(<span class="string">'./components/single.vue'</span>)</div><div class="line"><span class="keyword">const</span> Chat = <span class="built_in">require</span>(<span class="string">'./components/chat.vue'</span>)</div><div class="line"><span class="keyword">const</span> Onlyme = <span class="built_in">require</span>(<span class="string">'./components/onlyme.vue'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 定义路由，配置路由映射</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/wordcloud'</span> &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/wordcloud'</span>, <span class="attr">component</span>: Worldcloud &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/building'</span>, <span class="attr">component</span>: Building &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/canteen'</span>, <span class="attr">component</span>: Canteen &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/selfstudy'</span>, <span class="attr">component</span>: Selfstudy &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/difficult'</span>, <span class="attr">component</span>: Difficult &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/interest'</span>, <span class="attr">component</span>: Interest &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/bedroom'</span>, <span class="attr">component</span>: Bedroom &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/graduate'</span>, <span class="attr">component</span>: Graduate &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/getup'</span>, <span class="attr">component</span>: Getup &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/gotobed'</span>, <span class="attr">component</span>: Gotobed &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/eat'</span>, <span class="attr">component</span>: Eat &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/amuse'</span>, <span class="attr">component</span>: Amuse &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/single'</span>, <span class="attr">component</span>: Single &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/chat'</span>, <span class="attr">component</span>: Chat &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/onlyme'</span>, <span class="attr">component</span>: Onlyme &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; App &#125;,</div><div class="line">  router</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>从路由映射的配置中可以看出，访问网站的根路由会直接跳转到/wordcloud。路由映射的组件中用到了百度的<a href="http://echarts.baidu.com/" target="_blank" rel="external">echarts</a>库来画图，这是一个很好用的图表库。</p>
<h2 id="怎么画图"><a href="#怎么画图" class="headerlink" title="怎么画图"></a>怎么画图</h2><p>怎么用echarts画图呢？其实官网上有很多实例，下面以bedroom.vue组件为例来简单说明，bedroom.vue代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main_content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bedroom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    data() &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">chart</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">opinion</span>: [<span class="string">'学习氛围差'</span>, <span class="string">'学习氛围一般'</span>, <span class="string">'学习氛围很好'</span>],</div><div class="line">        <span class="attr">opinionData</span>: [</div><div class="line">          &#123;<span class="attr">value</span>:<span class="number">26</span>, <span class="attr">name</span>:<span class="string">'学习氛围差'</span>&#125;,</div><div class="line">          &#123;<span class="attr">value</span>:<span class="number">31</span>, <span class="attr">name</span>:<span class="string">'学习氛围一般'</span>&#125;,</div><div class="line">          &#123;<span class="attr">value</span>:<span class="number">8</span>, <span class="attr">name</span>:<span class="string">'学习氛围很好'</span>&#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">      drawPie (id) &#123;</div><div class="line">        <span class="keyword">this</span>.chart = echarts.init(<span class="built_in">document</span>.getElementById(id))</div><div class="line">        <span class="keyword">this</span>.chart.setOption(&#123;</div><div class="line">          <span class="attr">title</span>: &#123;</div><div class="line">            <span class="attr">text</span>: <span class="string">'寝室学习氛围情况调查'</span>,</div><div class="line">            <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">            <span class="attr">top</span>: <span class="number">10</span>,</div><div class="line">            <span class="attr">textStyle</span>: &#123;</div><div class="line">              <span class="attr">fontSize</span>: <span class="number">24</span>,</div><div class="line">              <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">              <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">tooltip</span>: &#123;</div><div class="line">            <span class="attr">trigger</span>: <span class="string">'item'</span>,</div><div class="line">            <span class="attr">formatte</span>: <span class="string">"&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)"</span></div><div class="line">          &#125;,</div><div class="line">          <span class="attr">toolbox</span>: &#123;</div><div class="line">            <span class="attr">feature</span>: &#123;</div><div class="line">              <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">              <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">right</span>: <span class="number">15</span>,</div><div class="line">            <span class="attr">top</span>: <span class="number">10</span></div><div class="line">          &#125;,</div><div class="line">          <span class="attr">legend</span>: &#123;</div><div class="line">              <span class="attr">orient</span>: <span class="string">'vertical'</span>,</div><div class="line">              <span class="attr">left</span>: <span class="number">5</span>,</div><div class="line">              <span class="attr">top</span>: <span class="number">10</span>,</div><div class="line">              <span class="attr">data</span>: <span class="keyword">this</span>.opinion,</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">series</span>: [</div><div class="line">            &#123;</div><div class="line">              <span class="attr">name</span>: <span class="string">'寝室学习氛围'</span>,</div><div class="line">              <span class="attr">type</span>: <span class="string">'pie'</span>,</div><div class="line">              <span class="attr">radius</span>: [<span class="string">'50%'</span>, <span class="string">'70%'</span>],</div><div class="line">              <span class="attr">center</span>: [<span class="string">'50%'</span>, <span class="string">'60%'</span>],</div><div class="line">              <span class="attr">avoidLabelOverlap</span>: <span class="literal">false</span>,</div><div class="line">              <span class="attr">label</span>: &#123;</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                  <span class="attr">show</span>: <span class="literal">true</span>,</div><div class="line">                  <span class="attr">textStyle</span>: &#123;</div><div class="line">                    <span class="attr">fontSize</span>: <span class="string">'24'</span>,</div><div class="line">                    <span class="attr">fontWeight</span>: <span class="string">'bold'</span></div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">labelLine</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                  <span class="attr">show</span>: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">data</span>: <span class="keyword">this</span>.opinionData,</div><div class="line">              <span class="attr">itemStyle</span>: &#123;</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                  <span class="attr">shadowBlur</span>: <span class="number">10</span>,</div><div class="line">                  <span class="attr">shadowOffset</span>: <span class="number">0</span>,</div><div class="line">                  <span class="attr">shadowColor</span>: <span class="string">'rgba(0, 0, 0, 0.5)'</span></div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted() &#123;</div><div class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.drawPie(<span class="string">'bedroom'</span>)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line">#bedroom &#123;</div><div class="line">  position: relative;</div><div class="line">  left: 50%;</div><div class="line">  margin-left: -400px;</div><div class="line">  margin-bottom: 70px;</div><div class="line">  width: 800px;</div><div class="line">  height: 600px;</div><div class="line">  border: solid #D01257 1px;</div><div class="line">  box-shadow: 0 0 8px #FB90B7;</div><div class="line">  border-radius: 10px;</div><div class="line">&#125;   </div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这是一个vue的单文件组件，script中，首先导入echarts库，前提是已经安装了echarts库，输入以下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save echarts</div></pre></td></tr></table></figure></p>
<p>data对象中是画图要用到的一些数据，drawpie方法用来画图，接收一个DOM对象，然后在mounted构子函数中调用drawpie即可。</p>
<h4 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h4><ol>
<li>drawpie方法接收的DOM对象需要有确定的宽高，否则图像不显示</li>
<li>mounted中要包含vm.$nextTick才能保证该实例已经插入文档</li>
<li>想要进一步了解echarts画图相关的可以看看我的另一篇博客<a href="http://hyuhan.com/2016/11/19/how-to-use-echarts/" target="_blank" rel="external">echarts画图实例讲解</a></li>
</ol>
<h2 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h2><p>登录功能基于vuex（vue状态管理）和浏览器的sessionStorage实现的。首先在src文件夹下新建store文件夹，存放vuex的store（仓库）,新建三个文件store.js、login.js、user.js。login.js中存储登录状态，user.js中存储用户登录信息，store.js加载login和user模块。</p>
<p><strong>注意</strong>：在store.js中要引入babel-polyfill（先安装），否则会报错，报错原因是Babel默认只转换新的JavaScript句法，而不转换新的API，比如Iterator、Generator、Set、Maps、Promise等全局对象，以及一些定义在全局对象上的方法。所以必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<p>然后修改main.js文件，引入store：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/store'</span></div><div class="line">...</div><div class="line">...</div><div class="line">new Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; App &#125;,</div><div class="line">  router,</div><div class="line">  store</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>修改App.vue文件，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 导航栏 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-head</span>&gt;</span><span class="tag">&lt;/<span class="name">my-head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-nav</span>&gt;</span><span class="tag">&lt;/<span class="name">my-nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-mask</span> <span class="attr">v-if</span>=<span class="string">"canlogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-mask</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-login</span> <span class="attr">v-if</span>=<span class="string">"canlogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-login</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-foot</span>&gt;</span><span class="tag">&lt;/<span class="name">my-foot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">...</div><div class="line">import myMask <span class="keyword">from</span> <span class="string">'./components/mask'</span></div><div class="line"><span class="keyword">import</span> myLogin <span class="keyword">from</span> <span class="string">'./components/login'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  ...</div><div class="line">  data() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">canlogin</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    canlogin() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.login.islogin</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>到此，就基本上大功告成了，在命令行中输入 npm run dev预览一下。</p>
<h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><p>项目可以在本地预览了，但是要怎么发布到网上呢？首先，在命令行中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure></p>
<p>会生成一个dist文件夹，该文件夹中就是我们可以用来发布的代码，直接将代码上传到你的服务器上就可以啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的好久没有更新博客了，但是我最近并没有偷懒哦，一直在学习vue这个框架，并且用它做了一个小项目，现在就给大家分享一下我的这个还比较有意思的小项目，项目是基于vue2.0开发的。&lt;/p&gt;
&lt;h2 id=&quot;灵感来源&quot;&gt;&lt;a href=&quot;#灵感来源&quot; class=&quot;header
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="vuex" scheme="http://yuhan.com/tags/vuex/"/>
    
      <category term="vue-router" scheme="http://yuhan.com/tags/vue-router/"/>
    
      <category term="echarts" scheme="http://yuhan.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>webpack+vue项目中常用ES6语法小结</title>
    <link href="http://yuhan.com/2016/10/25/some-ES6-grammer-I-used-in-my-project/"/>
    <id>http://yuhan.com/2016/10/25/some-ES6-grammer-I-used-in-my-project/</id>
    <published>2016-10-25T09:24:57.000Z</published>
    <updated>2016-10-25T12:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客啦，最近入了阴阳师的坑，纯种非洲人，都没心情写博客了。这段时间在接触vue这个框架，用vue+webpack做一些小项目的时候经常会用到ES6的语法，用起来确实比较方便，今天就总结下在vue+webpack项目中经常会用到的一些ES6语法吧。首先来谈谈什么是ES6。</p>
<h2 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h2><p>首先要说说ECMAScript是什么，ECMAScript是JavaScript的规格，而JavaScript是ECMAScript的一种实现，ECMAScript的实现还有Jscript和ActionScript等。ES6（ECMAScript6）一般指ECMAScript2015标准，它是JavaScript语言的下一代标准。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>ES6标准虽然已经发布了，但是很多浏览器环境都还不支持，webpack是通过Babel这个转码器将ES6代码转为ES5，从而在现有环境执行。babel是在webpack的配置文件webpack.config.js的module参数中的loaders中配置，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	...</div><div class="line">	module: &#123;</div><div class="line">		<span class="attr">loaders</span>: [</div><div class="line">		&#123;</div><div class="line">			<span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">			<span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">			<span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">		&#125;,</div><div class="line">		...</div><div class="line">		]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置完成后还需要安装”babel-loader”模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>然后webpack就可以对用了ES6语法的js文件进行转码了。下面总结一些常用到的ES6语法。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>ES6中let命令用来声明变量，用法类似于var，但是let所声明的变量是局部变量，只在let命令所在的代码块内有效。所以在for循环中很适合用let变量做计数器。<br>let变量不会像var变量那样会进行变量提升，变量一定要在声明后使用，否则会报错。<br>只要块级作用域内存在let命令，它所声明的所有变量都绑定这个作业域，不收外部变量的影响，即形成了一个封闭的作用域。<br>let不允许在相同作用域内重复声明同一个变量。可以看出，let变量实际上为JavaScript新增了块级作用域</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>const声明一个只读的常量，一旦声明，值就不能改变。所以，const一旦声明就必须立即初始化，不能只声明不初始化。<br>const作用域和let命令相同，只在声明所在的块级作用域中有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>在ES6之前不能直接为函数的参数指定默认值，只能采用变通的方法。ES6允许为函数参数设置默认值，直接写在参数定义的后面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y=<span class="string">'World'</span></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></div></pre></td></tr></table></figure></p>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常定义了默认值的参数应该是函数的尾参数，如果是非尾部的参数设置默认值，实际上这个参数是没法省略的。除非显式输入undefined。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6允许使用“箭头”（=&gt;）定义函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</div></pre></td></tr></table></figure></p>
<p>上述箭头定义的函数等同于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> v;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>若箭头函数不需要参数或者需要多于一个参数，就使用一个圆括号代表参数部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若箭头函数的代码部分多于一条语句，就要使用大括号将他们括起来，并且使用return语句返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</div></pre></td></tr></table></figure></p>
<p><strong>使用注意点</strong></p>
<ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可当做构造函数，不可以使用new命令，否则会抛出错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在，可以用Rest参数代替。</li>
</ol>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>ES6之前，JavaScript一直没有模块（module）体系，ES6在语言规格的层面上，实现了模块功能，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。<br>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时采用静态命令的形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;stat, exists, readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码就是从fs模块加载3个方法，其他方法不加载。这种加载成为“编译时加载”。ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。</p>
<h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>模块功能主要由两个命令构成，export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</div></pre></td></tr></table></figure></p>
<p>还可以如下书写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure></p>
<p>export除了输出变量通用可以输出函数或者类，export输出的变量还可以用as关键字重命名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  v1 <span class="keyword">as</span> streamV1,</div><div class="line">  v2 <span class="keyword">as</span> streamV2,</div><div class="line">  v2 <span class="keyword">as</span> streamLatestVersion</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。用法上面已经有介绍，如果想为输入的变量重命名，使用as关键字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div></pre></td></tr></table></figure></p>
<h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><p>从前面的例子可以看出，使用import命令的时候，需要知道所要加载的变量名或函数名，否则无法加载。export default命令，为模块指定默认输出，其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<p>我在项目中目前用到的ES6语法就这些了，以后有机会再进一步学习ES6的新语法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有更新博客啦，最近入了阴阳师的坑，纯种非洲人，都没心情写博客了。这段时间在接触vue这个框架，用vue+webpack做一些小项目的时候经常会用到ES6的语法，用起来确实比较方便，今天就总结下在vue+webpack项目中经常会用到的一些ES6语法吧。首先来谈谈什么是
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="ES6" scheme="http://yuhan.com/tags/ES6/"/>
    
      <category term="webpack" scheme="http://yuhan.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化小结</title>
    <link href="http://yuhan.com/2016/09/13/about-module/"/>
    <id>http://yuhan.com/2016/09/13/about-module/</id>
    <published>2016-09-13T06:10:03.000Z</published>
    <updated>2016-11-17T06:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着我们的项目越来越复杂，参与项目的人员越来越多，将项目划分模块就变得十分重要，开发者只需要实现自己负责的功能，其他部分可以加载别人已经写好的模块。但是JavaScript不是一种模块化的编程语言，所以JavaScript开发人员做了很多努力，在现有的运行环境中实现了模块化的功能。</p>
<p>前端的模块化开发主要解决两个问题：命名冲突和文件依赖。在前端领域探究模块化开发的过程中，产生了不同的js模块规范，目前通用的JavaScript模块规范主要是：<strong>CommonJS</strong>和<strong>AMD</strong>，先从CommonJS说起。</p>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>CommonJS是服务器端的模块的规范，NodeJS将其发扬光大，标志着JavaScript模块化编程正式登上舞台。</p>
<ol>
<li>定义模块：CommonJS规范规定一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在该模块内部的变量无法被其它模块读取，除非定义为global对象的属性。</li>
<li>模块输出：想要输出模块中的变量使用module.exports对象，该对象是模块外部与内部通信的桥梁。</li>
<li>加载模块：使用require方法加载模块，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。</li>
</ol>
<p>下面举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义模块 module.js</span></div><div class="line"><span class="keyword">var</span> age = <span class="number">23</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(age);</div><div class="line">&#125;</div><div class="line"><span class="comment">//模块输出</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">printAge</span>: printAge</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加载模块</span></div><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule.printAge();</div></pre></td></tr></table></figure>
<p>加载模块时，一般可以省略js扩展名，可以使用相对路径也可以使用绝对路径。</p>
<p>然而CommonJS模块加载是同步的，这在服务器端很容易实现，但是在浏览器端实现起来会出现很多问题。</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>AMD(Asynchronous Module Definition)翻译成中文是异步模块定义，它是一个在浏览器端模块化开发的规范。由于不是JavaScript原生支持的，使用AMD规范进行页面开发需要用对应的库，RequireJS就是其中最出名的一个，实际上，AMD是RequireJS在推广过程中对模块定义的规范化的产出。</p>
<p>RequireJS主要解决了两个问题：</p>
<ol>
<li>实现js文件的异步加载，避免网页失去响应。</li>
<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
</ol>
<h2 id="define函数"><a href="#define函数" class="headerlink" title="define函数"></a>define函数</h2><p>RequireJS定义了一个define函数，它是一个全局变量，用来定义模块，描述如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(id?, dependencies?, factory);</div></pre></td></tr></table></figure></p>
<ol>
<li>id：可选参数，定义中模块的名字，若没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。</li>
<li>dependencies：一个当前模块依赖的，已被模块定义的模块标识的数组字面量。该参数可选，若忽略该参数，它默认为[“require”, “exports”, “module”]。</li>
<li>factory：模块初始化要执行的函数或对象。若为函数，它应该只被执行一次。若为对象，该对象应该为模块的输出值。</li>
</ol>
<h2 id="require函数"><a href="#require函数" class="headerlink" title="require函数"></a>require函数</h2><p>RequireJS还定义了一个require函数用来加载模块，描述如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([dependencies], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>require函数接受两个参数，第一个参数是一个数组，表示所依赖的模块。第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块要以参数形式传入该函数，在回调函数内部才可以使用这些模块。</p>
<p>require函数在加载依赖模块的时候是异步加载的，这样浏览器就不会失去响应，它指定的回调函数，也只有在前面的模块都加载成功后，才会运行，这样就解决了依赖性的问题。</p>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD(Common Module Definition)翻译成中文就是通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。和AMD一样，使用CMD规范也需要相应的库函数，SeaJS就是其中一个。实际上，CMD是SeaJS在推广过程中对模块定义的规范化的产出。SeaJS要解决的问题和RequireJS一样，只不过在模块定义方式和模块加载的时机上有些区别。</p>
<h2 id="define函数-1"><a href="#define函数-1" class="headerlink" title="define函数"></a>define函数</h2><p>CMD规范的define函数和AMD规范的描述相同，也是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(id?, dependencies?, factory);</div></pre></td></tr></table></figure></p>
<p>但是CMD推崇一个文件一个模块，所以经常用文件名作为模块id。同时，CMD推崇就近依赖，所以一般不在define函数的参数中写依赖，而是在factory函数中就近写。</p>
<p>factory函数有三个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factory(<span class="built_in">require</span>, exports, <span class="built_in">module</span>)</div></pre></td></tr></table></figure></p>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>require是一个方法，它接受模块标识作为唯一的参数，用来导入其他的模块，获取其它模块提供的接口。</p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>exports是一个对象，用来向外部提供接口。</p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module是一个对象，存储了去模块相关联的一些属性和方法。</p>
<h1 id="AMD与CMD的区别"><a href="#AMD与CMD的区别" class="headerlink" title="AMD与CMD的区别"></a>AMD与CMD的区别</h1><p>首先我们知道，AMD是RequireJS 在推广过程中对模块定义的规范化产出。CMD是SeaJS在推广过程中对模块定义的规范化产出。他们的区别主要有以下四点。</p>
<p>1、对于依赖的模块，AMD是提前执行（<strong>注意是执行不是加载</strong>），CMD是延迟执行。RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。AMD和CMD都是异步加载的，只是AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样就会导致依赖模块的执行顺序和书写顺序不一定一致，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才会执行。而CMD在加载完某个依赖模块后并不执行，只是下载下来，在所有依赖模块加载完成后再进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</p>
<p>2、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。CMD推崇就近依赖，只有在用到某个模块的时候再去require。对比如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AMD</span></div><div class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></div><div class="line">    a.doSomething()</div><div class="line">    b.doSomething()</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;) </div><div class="line"><span class="comment">// CMD</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</div><div class="line">    a.doSomething()</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写，需要用到的时候才require</span></div><div class="line">    b.doSomething()</div><div class="line">    <span class="comment">// ... </span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>3、AMD的API根据使用范围有区别，但使用同一个API接口。CMD的API严格区分，推崇职责单一。</p>
<p>4、AMD是异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。而CMD的机制不同，这种加载方式会产生错误，但是如果能规范化模块的内容形式，也可以异步并行加载。</p>
<h1 id="RequireJS与SeaJS的区别"><a href="#RequireJS与SeaJS的区别" class="headerlink" title="RequireJS与SeaJS的区别"></a>RequireJS与SeaJS的区别</h1><p>两者遵循的规范不同，RequireJS遵循AMD规范，SeaJS遵循CMD规范。两者的区别可以参考<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="external">SeaJS与RequireJS的异同</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着我们的项目越来越复杂，参与项目的人员越来越多，将项目划分模块就变得十分重要，开发者只需要实现自己负责的功能，其他部分可以加载别人已经写好的模块。但是JavaScript不是一种模块化的编程语言，所以JavaScript开发人员做了很多努力，在现有的运行环境中实现了模块化
    
    </summary>
    
      <category term="模块化" scheme="http://yuhan.com/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="总结" scheme="http://yuhan.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="模块" scheme="http://yuhan.com/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之XSS</title>
    <link href="http://yuhan.com/2016/09/09/client-script-security/"/>
    <id>http://yuhan.com/2016/09/09/client-script-security/</id>
    <published>2016-09-09T08:23:47.000Z</published>
    <updated>2016-12-05T13:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web安全是网站开发中我们经常容易忽视的一个问题，但一旦出现问题将会带来很大的影响。这几天读了<a href="https://book.douban.com/subject/10546925/" target="_blank" rel="external">白帽子讲Web安全</a>这本书的前半部分内容，目前还没有怎么接触过后端的东西，今天主要简单总结一下客户端脚本安全中的头号大敌——跨站脚本攻击。先说说浏览器的安全相关知识。</p>
<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>浏览器安全被越来越多的人所重视。首先，浏览器是一个客户端，如果具备了安全功能，就可以像安全软件一样对用户上网起到很好的保护作用。另外，浏览器安全也是各大浏览器厂商之间竞争的一张底牌。下面介绍一些浏览器具有的的安全功能。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器最核心最基本的安全功能。该策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。影响源的因素有：host（域名或IP地址，如果是IP地址则看做一个根域名）、子域名、端口、协议。</p>
<p><strong>注意：</strong>对于当前页面来说，页面内存放JavaScript文件的域并不重要，重要的是加载JavaScript页面所在的域。</p>
<h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈被称为“挂马”。浏览器厂商根据挂马的特点研究出了一些对抗挂马的技术。与此同时，浏览器还发展出了多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。</p>
<p>Sandbox，即沙箱，已经成为泛指“资源隔离类模块”的代名词。其设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任代码访问隔离区之外的资源。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道。</p>
<h2 id="恶意网址拦截"><a href="#恶意网址拦截" class="headerlink" title="恶意网址拦截"></a>恶意网址拦截</h2><p>恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址拦黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。</p>
<p>常见的恶意网址分为两类：一类是挂马网站，这类网站通常有恶意的脚本，如JavaScript或Flash，通过利用浏览器的漏洞执行shellcode，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。</p>
<p>下面进入本文的正题，跨站脚本攻击（XSS).</p>
<h1 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h1><p>跨站脚本攻击（XSS）是客户端脚本安全中的头号大敌。通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。XSS主要有三种不同的类型，下面一一介绍。</p>
<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>第一种是反射型XSS，首先来举个例子，假设一个页面把用户输入的参数直接输出到页面上：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$input = $_GET[<span class="string">"param"</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;div&gt;"</span>.$input.<span class="string">"&lt;/div&gt;"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>在正常的情况下，用户向param提交的数据会展示到页面中，比如提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/phptest/index.php?param=this is a test</div></pre></td></tr></table></figure>
<p>会得到如下结果：<br><img src="/img/xss_test1.png" alt="xss1"></p>
<p>但是如果提交一段HTML代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/phptest/index.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>会发现alert在当前页面执行了：<br><img src="/img/xss_test2.png" alt="xss2"></p>
<p>再查看源代码会发现：<br><img src="/img/xss_test2.png" alt="xss3"></p>
<p><em>以上测试在IE中进行，有些浏览器对这种简单的XSS攻击做了防御</em></p>
<p>用户写入的script脚本已经被写入页面中。这就是XSS的第一种类型：反射型XSS。它只是简单地把用户输入的数据反射给浏览器。黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久性XSS”。</p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>第二种XSS类型是存储型XSS，它会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。</p>
<p>比较常见的场景是黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。黑客把恶意的脚本保存到服务器端，所以这种XSS攻击叫做“存储型XSS”。通常也叫做“持久型XSS”。</p>
<h2 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h2><p>第三种类型是DOM Based XSS，从效果上来说也是反射型XSS。它是通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。还是举个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">function test() &#123;</div><div class="line">    var str = document.getElementById("text").value;</div><div class="line">    document.getElementById("t").innerHTML = "&lt;a href = '"+str+"' &gt;testLink&lt;/a&gt;";</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id = "t"&gt;&lt;/div&gt;</div><div class="line">&lt;input type="text" id="text" value=""&gt;</div><div class="line">&lt;input type="button" id="s" value="write" onclick="test()"&gt;</div></pre></td></tr></table></figure>
<p>点击“write”按钮后，会在当前页面插入一个超链接，其地址为文本框的内容：<br><img src="/img/dom_xss1.png" alt="domxss1"></p>
<p>“write”按钮的onclick事件调用了test()函数，在test()函数中修改了页面的DOM节点，通过innerHTML把一段用户数据当作HTML写入到页面中，就造成了DOM Based XSS。</p>
<p>然后，我们构造如下数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">' onclick = alert(/xss/) //</span></div></pre></td></tr></table></figure>
<p>输入后，页面代码变成了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">''</span> <span class="attr">onclick</span>=<span class="string">alert(/xss/)</span> //' &gt;</span>testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>首先第一个单引号闭合掉href的第一个单引号，然后插入一个onclick事件，最后再用注释符“//”注释掉第二个单引号。点击这个新生成的连接，脚本将被执行。<br>此外，还可以通过闭合a标签，并插入一个新的HTML标签，来利用XSS攻击。例如，进行如下输入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">'&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">alert(/xss2/)</span> /&gt;</span><span class="tag">&lt;<span class="name">'</span></span></div></pre></td></tr></table></figure>
<p>会有什么效果可以自己下去实践一下！</p>
<h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><p>XSS防御是很复杂的，前文也只是浅显地介绍了XSS，这里也只简单介绍几种易懂的XSS防御方式。</p>
<h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>HttpOnly最早是由微软提出，并在IE6中实现的，现在已经逐渐成为一个标准。浏览器将禁止页面的JavaScript访问带有HttpOnly属性的Cookie。</p>
<h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>常见的Web漏洞如XSS，SQL注入等，都要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。</p>
<p>输入检查的逻辑必须放在服务端脚本代码中实现。如果只是在客户端使用JavaScript进行输入检查，是很容易被攻击者绕过的。目前Web开发的普遍做法，是同时在客户端JavaScript中和服务器端代码中实现相同的输入检查。客户端的JavaScript的输入检查可以阻挡大部分误操作的正常用户，从而节约服务器资源。</p>
<p>在XSS防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、”等。如果发现这些字符就将这些字符过滤或者编码。比较智能的“输入检查”，可能还会匹配XSS的特征。比如查找用户数据中是否包含了“script”、“javascript”等敏感字符。这种输入检查的方式可以称为“XSS Filter”。互联网上有许多开源的“XSS Filter”实现。</p>
<h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p>
<p>编码分为很多种，针对HTML代码的编码方式是HtmlEncode。它并非专用名词，只是一种函数实现，作用是将字符转换成HTMLEntities。在PHP中，有 htmlentities() 和 htmlspecialchars()两个函数可以满足安全要求。</p>
<h3 id="防御DOM-Based-XSS"><a href="#防御DOM-Based-XSS" class="headerlink" title="防御DOM Based XSS"></a>防御DOM Based XSS</h3><p>DOM Based XSS是一种比较特别的XSS漏洞，前文提到的几种防御方法都不太适用，需要特别对待。</p>
<p>先回头看看前面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">function test() &#123;</div><div class="line">    var str = document.getElementById("text").value;</div><div class="line">    document.getElementById("t").innerHTML = "&lt;a href = '"+str+"' &gt;testLink&lt;/a&gt;";</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id = "t"&gt;&lt;/div&gt;</div><div class="line">&lt;input type="text" id="text" value=""&gt;</div><div class="line">&lt;input type="button" id="s" value="write" onclick="test()"&gt;</div></pre></td></tr></table></figure>
<p>在button的onclick事件中，执行了test()函数，而该函数中最关键的一句是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).innerHTML = <span class="string">"&lt;a href = '"</span>+str+<span class="string">"' &gt;testLink&lt;/a&gt;"</span>;</div></pre></td></tr></table></figure>
<p>它将HTML代码写入了DOM节点，最后导致了XSS的发生。DOM Based XSS是从JavaScript中输出数据到HTML页面中。而前面提到的方法都是针对“从服务器应用直接输出到HTML页面”的XSS漏洞，因此不适用于DOM Based XSS。先举个例子看看正确的解决方法是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> x = <span class="string">"$var"</span>;</div><div class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;a href='"</span>+x+<span class="string">"' &gt;test&lt;/a&gt;"</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>变量“$var”输出在script标签内，可是最后又被 document.write输出到HTML页面中。假设为了保护“$var”直接在script标签内产生XSS，服务器端对其进行了javascriptEscape。可是，$var在document.write时，仍然能够产生XSS。原因在于，第一次执行javascriptEscape后，只保护了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var x = &quot;$var&quot;;</div></pre></td></tr></table></figure>
<p>但是当 document.write输出数据到HTML页面时，浏览器重新渲染了页面。在script标签执行时，已经对变量x进行了解码，其后 document.write再运行时，其参数就变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&apos; &apos;onclick=alert(1);//&apos;&apos; &gt;test&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>因此产生了XSS。</p>
<p>正确的防御方法应该是首先在“$var”输出到script时，应该执行一次javascriptEncode;其次，在 document.write输出到HTML页面时，要分具体情况：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode。也就是说从JavaScript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p>
<p>关于XSS的分享就这么多了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web安全是网站开发中我们经常容易忽视的一个问题，但一旦出现问题将会带来很大的影响。这几天读了&lt;a href=&quot;https://book.douban.com/subject/10546925/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;白帽子讲Web
    
    </summary>
    
      <category term="web安全" scheme="http://yuhan.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://yuhan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
