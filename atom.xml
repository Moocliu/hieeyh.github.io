<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hieeyh&#39;s blog</title>
  <subtitle>一只前端小菜鸟的成长日记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuhan.com/"/>
  <updated>2017-03-04T12:32:16.000Z</updated>
  <id>http://yuhan.com/</id>
  
  <author>
    <name>hieeyh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript实现排序算法</title>
    <link href="http://yuhan.com/2017/03/02/sorting-with-javascript/"/>
    <id>http://yuhan.com/2017/03/02/sorting-with-javascript/</id>
    <published>2017-03-02T05:55:38.000Z</published>
    <updated>2017-03-04T12:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法主要用在元素的数组排序，常见的排序算法有冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序等。这些排序算法都可以用JavaScript实现。下面的排序算法都假设是从小到大进行排序，从大到小可以相应进行转化。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的基本思想是从头遍历要排序的数组，比较相邻两个数，如果前面位置的数大于后面位置的数，那么就将两者进行交换，否则不做任何操作。遍历完一次之后，最大的数就放到了数组最后的位置。然后再从头遍历数组，进行同样的操作，就可以将第二大的数放到倒数第二个位置，依此进行下去，直到所有数都排好位置为止。冒泡排序的代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">functon bubbleSort(arr) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length<span class="number">-1</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length<span class="number">-1</span>-i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                <span class="comment">// 交换位置</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j];</div><div class="line">                arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">                arr[j+<span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>冒泡排序平均时间复杂度为O(n^2),而且是一种稳定的排序算法。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的基本思想是先找到数组中最小的元素，将它和数组的第一个元素交换位置，再找到数组中第二小的元素，将它和数组的第二个元素交换位置，依次进行下去，直到整个数组排好序为止。选择排序代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">functon selectSort(arr) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length<span class="number">-1</span>; i++) &#123;</div><div class="line">        <span class="keyword">var</span> min = arr[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</div><div class="line">                <span class="keyword">var</span> temp = min;</div><div class="line">                min = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">            arr[i] = min;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选择排序的时间复杂度为O(n^2),而且是一个不稳定的排序算法。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的基本思想是将一个记录（数）插入到已排好序的有序数列中的适当位置。插入排序的代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> key = arr[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; key) &#123;</div><div class="line">                arr[j + <span class="number">1</span>] = arr[j];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                arr[j + <span class="number">1</span>] = key;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入排序的时间复杂度为O(n^2),而且是一个稳定的排序算法。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序又称“缩小增量排序”，是在直接插入排序算法上进行改进的，它的基本思想是先将整个待排序序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。因为插入排序在对几乎已经排好序的数据操作时，效率高。<br>希尔排序的步骤是：首先取一个小于序列长度的整数d1作为增量，对序列从头开始把所有距离为d的元素放在同一个分组中，现在各组内进行直接插入排序；然后去第二个增量d2（小于d1），进行同样的操作，直到增量为1，即对已经基本有序的序列进行插入排序。希尔排序代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr, dk</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> d = dk/<span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = d; j &lt; n; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-d]) &#123;</div><div class="line">                <span class="keyword">var</span> temp = arr[j];</div><div class="line">                <span class="keyword">var</span> k = j - d;</div><div class="line">                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; temp) &#123;</div><div class="line">                    arr[k + d] = arr[k];</div><div class="line">                    k -= d;</div><div class="line">                &#125;</div><div class="line">                arr[k + d] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>希尔排序的时间复杂度为O(n^3/2),而且是一个不稳定的排序算法。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种分而治之的算法，它是冒泡排序的改进，基本思想是通过一趟排序将待排序列分割成独立的两部分，其中一部分的值都要比另一部分的值小，再分别对这两部分继续进行排序，直到整个序列有序。<br>快速排序的步骤是：首先从序列中选择一个基准元素，假设为第一个元素，将列表分成两部分，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面，再分别对这两部分重复上面的步骤即可。代码首先如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// key为基准值序号</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">var</span> low = [];</div><div class="line">        <span class="keyword">var</span> high = [];</div><div class="line">        <span class="keyword">var</span> pivotkey = arr[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt;= pivotkey) &#123;</div><div class="line">                low.push(arr[i]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                high.push(arr[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> quickSort(low).concat(pivotkey, quickSort(high));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序的时间复杂度为O(nlogn),而且是一个不稳定的排序算法。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并的含义是将两个或两个以上的有序表组合成一个新的有序表。假设初始序列长度为n，首先，每个子序列的长度为1，然后前后两两归并。得到若干个长度为2或者1的子序列，再两两归并，如此重复，直至得到一个长度为n的的有序序列为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法主要用在元素的数组排序，常见的排序算法有冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序等。这些排序算法都可以用JavaScript实现。下面的排序算法都假设是从小到大进行排序，从大到小可以相应进行转化。&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yuhan.com/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://yuhan.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学前端半年来我读过哪些书</title>
    <link href="http://yuhan.com/2017/01/11/books/"/>
    <id>http://yuhan.com/2017/01/11/books/</id>
    <published>2017-01-11T06:50:16.000Z</published>
    <updated>2017-01-12T00:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼已经2017年了，我2016年4月份开始接触前端，到现在也有大半年了，马上就要过年了，准备好好休息休息，就想着把这大半年所读的前端书籍整理一下，顺便制定一下年后的学习计划。有些书看了很久也不记得多少了，年后还得再好好回味一遍。</p>
<h1 id="我看了哪些书"><a href="#我看了哪些书" class="headerlink" title="我看了哪些书"></a>我看了哪些书</h1><h2 id="HTML相关书籍"><a href="#HTML相关书籍" class="headerlink" title="HTML相关书籍"></a>HTML相关书籍</h2><ol>
<li>Head First HTML5 Programming</li>
<li>Head First HTML and CSS</li>
</ol>
<p>这两本书通俗易懂，是我刚开始学前端时看的，入门强推哦。</p>
<h2 id="CSS相关书籍"><a href="#CSS相关书籍" class="headerlink" title="CSS相关书籍"></a>CSS相关书籍</h2><ol>
<li>CSS权威指南</li>
<li>CSS揭秘</li>
</ol>
<p>CSS权威指南是CSS入门书籍，CSS看的书不太多，我时间真的不够啊，每天还有电视剧要追，还要时不时锻炼身体怕猝死，还不敢熬夜太晚怕长痘，想哭。</p>
<h2 id="JavaScript相关书籍"><a href="#JavaScript相关书籍" class="headerlink" title="JavaScript相关书籍"></a>JavaScript相关书籍</h2><ol>
<li>JavaScript DOM编程艺术</li>
<li>JavaScript高级程序设计</li>
<li>JavaScript语言精粹</li>
<li>JavaScript设计模式</li>
<li>ES6标准入门</li>
</ol>
<p>《Javascript DOM编程艺术》是我看的第一本关于JavaScript的书，这本书讲了一个网站从简单到复杂是怎么一步步完成的，适合入门，但不能止步于此哦。这两周我抽出时间把《JavaScript高级程序设计》又看了一遍，对JavaScript又有了进一步的理解。《JavaScript语言精粹》这本书看的时候对JavaScript的理解还不够，看的云里雾里，过完年打算再看一遍。《JavaScript设计模式》这本书之前有总结过，可参考我博客：<a href="http://hyuhan.com/2016/12/23/javascript-design-patterns/" target="_blank" rel="external">《JavaScript设计模式》读后感 觉很复杂</a>。</p>
<p>学习JavaScript还推荐codecademy这个网站上面的课程，这也是之前知乎上看别人推荐的。JQuery的学习嘛，并没有看书，看的都是网上的教程。</p>
<h2 id="Node-js相关书籍"><a href="#Node-js相关书籍" class="headerlink" title="Node.js相关书籍"></a>Node.js相关书籍</h2><ol>
<li>Nodejs开发实战详解</li>
<li>NodeJS实战</li>
<li>NodeJS开发指南</li>
<li>深入浅出nodejs</li>
</ol>
<p>自学前端真的很痛苦呐，木有啥项目，没有后台跟你联调，只能自己去学Node，什么都得自己弄。其实我并不想搞全栈啊，但是学了之后感觉真的挺有意思的，嘿嘿。前面三本书偏实战，比较好理解。《深入浅出nodejs》这本书自己还需要再看一遍，争取把里面的原理都弄懂。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>PhoneGap实战</li>
<li>白帽子讲Web安全</li>
<li>大型网站技术架构</li>
<li>图解HTTP</li>
<li>鸟哥的Linux私房菜（基础学习篇）</li>
</ol>
<p>《PhoneGap实战》这本书是7月份的时候自己练手做一个记事本app的时候学的。《大型网站技术架构》这本书强推，前端也需要了解一下这方面的知识。《HTTP权威指南》那本书实在是太厚了，我就看了《图解HTTP》这本书，嘻嘻。        </p>
<p>计算机基础课程本科的时候基本都学了，过完年准备把计算机网络、数据库和数据结构算法相关的再回顾一遍。</p>
<h2 id="Vue的学习"><a href="#Vue的学习" class="headerlink" title="Vue的学习"></a>Vue的学习</h2><p>Vue都是看官方文档学的，然后动手做小项目，项目中遇到问题再学习再理解。现在觉得没有人带我也不错，这段时间自学前端感觉自己独立解决问题的能力比以前真的强了很多很多。</p>
<h1 id="开年计划看的书"><a href="#开年计划看的书" class="headerlink" title="开年计划看的书"></a>开年计划看的书</h1><h2 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h2><ol>
<li>HTML5高级程序设计</li>
</ol>
<h2 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h2><ol>
<li>精通CSS：高级Web标准解决方案</li>
<li>CSS禅意花园</li>
</ol>
<h2 id="JavaScript相关书籍-1"><a href="#JavaScript相关书籍-1" class="headerlink" title="JavaScript相关书籍"></a>JavaScript相关书籍</h2><ol>
<li>JavaScript权威指南</li>
<li>你不知道的JavaScript</li>
<li>JavaScript设计模式与开发实践</li>
</ol>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Unix编程艺术</li>
<li>HTTP权威指南</li>
<li>程序员实用算法</li>
<li>程序员的数学</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在学习前端的大半年时间里，真的收获很多，最让我开心的是找到了一个自己喜欢的方向，不再像以前那样漫无目的，什么都懂一点但是什么都不精，想着以后能做自己喜欢的工作就很激动。我是2018届应届生，距离找工作还剩下半年时间了，这半年里要尽可能多的学习，找到一份自己心仪的工作。</p>
<p>每个月我都会给自己制定一个学习计划，目前我的学习计划已经制定到2017年6月份了，哈哈。如果能踏踏实实按照自己的计划走，我相信能找到一个不错的工作，加油！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼已经2017年了，我2016年4月份开始接触前端，到现在也有大半年了，马上就要过年了，准备好好休息休息，就想着把这大半年所读的前端书籍整理一下，顺便制定一下年后的学习计划。有些书看了很久也不记得多少了，年后还得再好好回味一遍。&lt;/p&gt;
&lt;h1 id=&quot;我看了哪些书&quot;&gt;&lt;
    
    </summary>
    
      <category term="总结" scheme="http://yuhan.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yuhan.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="书" scheme="http://yuhan.com/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript设计模式》读后感 觉很复杂</title>
    <link href="http://yuhan.com/2016/12/23/javascript-design-patterns/"/>
    <id>http://yuhan.com/2016/12/23/javascript-design-patterns/</id>
    <published>2016-12-23T12:23:51.000Z</published>
    <updated>2017-03-04T12:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触前端两三个月的时候，那时候只是听说设计模式很重要，然后我就去读了一本设计模式的书，读了一部分，也不知道这些设计模式到底设计出来干嘛的，然后就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有一些启发。于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事串起了一整本书，看了一部分发现原来我平时写代码的时候无意之中就用到了一些设计模式，然后就忍不住都看完了。看完整本书，让我完全改变了以前对设计模式的看法，也学到了很多在实际项目开发中的经验。这里就简单总结下这本书，也算是做个笔记，供自己以后参考。（定义一般都比较晦涩难懂，可以先看看使用场景再回来理解相关定义）<br>先给个书的链接: <a href="https://www.amazon.cn/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%A0%E5%AE%B9%E9%93%AD/dp/B013HO6DNS/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1482324196&amp;sr=1-2&amp;keywords=javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">JavaScript设计模式-张容铭</a></p>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是代码设计经验的总结，为了可重用代码，保证代码的可靠性等。设计模式主要分为三大类型，创建型模式，结构型模式和行为型模式，本书还额外写了另两类设计模式，技巧型模式和架构型模式。JavaScript设计模式是以面向对象编程为基础的，JavaScript的面向对象编程和传统的C++、Java的面向对象编程有些差别，这让我一开始接触JavaScript的时候感到十分痛苦，但是这只能靠自己慢慢积累慢慢思考。想继续了解JavaScript设计模式必须要先搞懂JavaScript面向对象编程，否则只会让你自己更痛苦。</p>
<h1 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h1><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。创建型设计模式主要有简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式和单例模式，下面一一道来。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>作者把简单工厂模式比喻成一个神奇的魔术师。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>看完上面的定义一定很不解，说的到底是啥，现在就举个例子来解释一下。比如体育商品店卖体育器材，里面有很多体育用品及其相关介绍。当你来到体育用品店买一个篮球，只需问售货员，他就会帮你找到你所要的东西。用程序实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 篮球基类</span></div><div class="line"><span class="keyword">var</span> Basketball = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intro = <span class="string">'篮球盛行于美国'</span>;</div><div class="line">&#125;;</div><div class="line">Basketball.prototype = &#123;</div><div class="line">    <span class="attr">getMember</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'每个队伍需要5名队员'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getBallSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'篮球很大'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 足球基类</span></div><div class="line"><span class="keyword">var</span> Football = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intro = <span class="string">'足球盛行于美国'</span>;</div><div class="line">&#125;;</div><div class="line">Football.prototype = &#123;</div><div class="line">    <span class="attr">getMember</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'每个队伍需要11名队员'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getBallSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'篮球很大'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 运动工厂</span></div><div class="line"><span class="keyword">var</span> SportsFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(name) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'NBA'</span>: </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Basketball();</div><div class="line">        <span class="keyword">case</span> <span class="string">'wordCup'</span>: </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Football();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当你使用这个运动工厂时只需要记住SportsFactory这个工厂对象就好了，它会帮你找到你想要的。<br>简单工厂模式的理念是创建对象，上面例子是将不同的类实例化，但是简单工厂模式还可以创建相似对象，将相似的东西提取，不相似的针对性处理即可。这样只需创建一个对象就可以替代多个类了。</p>
<h3 id="收获与总结"><a href="#收获与总结" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>团队开发不同于个人，对全局变量的限制很大，要尽量少得创建全局变量。如果有同一类对象在不同需求中重复使用，那么大部分是不需要重复创建的，要学会代码复用。用简单工厂来创建对象，可以减少全局变量创建提高代码复用率，它的使用场合限制在创建单一对象。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>作者把工厂方法模式比喻成一张名片。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际开发中，需求的变更是很正常的，开始需求简单可以直接创建对象，类似的需求多了可以用简单工厂方法重构，但是如果需求不停变化，那么不仅要修改工厂函数还要添加类，这样就没完了。而工厂方法模式本意是将实际创建对象的工作推迟到子类中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 工厂类</span></div><div class="line"><span class="keyword">var</span> Factory = <span class="function"><span class="keyword">function</span>(<span class="params">type, content</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Factory) &#123;</div><div class="line">        <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="keyword">this</span>[type](content);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 防止使用者不知道这是一个类，忘了加new操作符创建，导致全局变量污染</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Factory(type, content);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Factory.prototype = &#123;</div><div class="line">    <span class="attr">Java</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">JavaScript</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">php</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样以后如果想添加其他类，只需要在Factory的原型里添加就可以了。</p>
<h3 id="收获与总结-1"><a href="#收获与总结-1" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>对于创建很多类的对象，简单工厂模式就不适合了，通过工厂模式可以轻松创建多个类的实例对象，而且避免了使用者与对象类之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式让你感觉出现的都是幻觉。</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责某一类产品的实例。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种声明但不能使用的类，当你使用的时候就会报错。JavaScript中的抽象类不能像传统面向对象语言那样轻松地创建，我们可以在类的方法中手动抛出错误来模拟抽象类。你可能会想，这样的类什么都不能做能有什么用？其实它在继承上是很有用的。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>抽象工厂模式不能用来创建具体对象，一般用它作为父类类创建一些子类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象工厂方法</span></div><div class="line"><span class="keyword">var</span> VehicleFactory = <span class="function"><span class="keyword">function</span>(<span class="params">subType, superType</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断抽象工厂中是否有该抽象类</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="comment">// 缓存类</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">        <span class="comment">// 继承父类属性和方法</span></div><div class="line">        F.prototype = <span class="keyword">new</span> VehicleFactory[superType]();</div><div class="line">        <span class="comment">// 将子类构造函数指向子类</span></div><div class="line">        subType.constructor = subType;</div><div class="line">        <span class="comment">// 子类原型继承父类</span></div><div class="line">        subType.prototype = <span class="keyword">new</span> F();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不存在该抽象类抛出错误</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'未创建该抽象类'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 小汽车抽象类</span></div><div class="line">VehicleFactory.Car = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">'car'</span>;</div><div class="line">&#125;;</div><div class="line">VehicleFactory.Car.prototype = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 公交车抽象类</span></div><div class="line">VehicleFactory.Bus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">'bus'</span>;</div><div class="line">&#125;;</div><div class="line">VehicleFactory.Bus.prototype = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>抽象工厂实际上是一个子类继承父类的方法，在该方法中需要通过传递子类以及继承父类的名称。</p>
<h3 id="收获与总结-2"><a href="#收获与总结-2" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式。该模式创建出的结果不是一个真实的对象实例，而是一个类簇，指定了类的结构。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式告诉我们分即是合。</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>现在有一个发布简历的需求，就是帮别人在公司网站上发布简历，但是这些简历有一个需求，除了将兴趣爱好以及一些特长发布在页面里，其他信息如联系方式等不要发布在网站上，而且每个人想找的工作是可以分类的。这样一些需求我们需要创建的东西就多了，这时候前面的三种工厂模式都不适合了，这里就可以用建造者模式。<br>建造者模式和只关心创建结果的工厂模式不同，虽然其目的也是创建一个对象，但是更多关心的是创建这个对象的整个过程。在本例中，我们需要的不仅仅是应聘者的实例还要在创建过程中注意这位应聘者有哪些兴趣爱好等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一位人类</span></div><div class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="comment">// 技能</span></div><div class="line">    <span class="keyword">this</span>.skill = param &amp;&amp; param.skill || <span class="string">'保密'</span>;</div><div class="line">    <span class="comment">// 兴趣爱好</span></div><div class="line">    <span class="keyword">this</span>.hobby = param &amp;&amp; param.hobby || <span class="string">'保密'</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 类人原型方法</span></div><div class="line">Human.prototype = &#123;</div><div class="line">    <span class="attr">getSkill</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.skill;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getHobby</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例化姓名类</span></div><div class="line"><span class="keyword">var</span> Named = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 构造器，解析姓名的姓与名</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">name, that</span>) </span>&#123;</div><div class="line">        that.wholeName = name;</div><div class="line">        <span class="keyword">if</span>(name.indexOf(<span class="string">' '</span>) &gt; <span class="number">-1</span>) &#123;</div><div class="line">            that.FirstName = name.slice(<span class="number">0</span>, name.indexOf(<span class="string">' '</span>));</div><div class="line">            that.FirstName = name.slice(name.indexOf(<span class="string">' '</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;)(name, that);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例化职位类</span></div><div class="line"><span class="keyword">var</span> Work = <span class="function"><span class="keyword">function</span>(<span class="params">work</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 构造器，通过传入的职位特征来设置相应职位及描述</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">work, that</span>) </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(work) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'code'</span>:</div><div class="line">                that.work = <span class="string">'工程师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'UI'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'UE'</span>:</div><div class="line">                that.work = <span class="string">'设计师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'teach'</span>:</div><div class="line">                that.work = <span class="string">'教师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                that.work = work;</div><div class="line">        &#125;</div><div class="line">    &#125;)(work, that);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 更换期望的职位</span></div><div class="line">Work.prototype.changeWork = <span class="function"><span class="keyword">function</span>(<span class="params">work</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.work = work;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面来创建一位应聘者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 应聘者创建类</span></div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, work</span>) </span>&#123;</div><div class="line">    <span class="comment">// 创建应聘者缓存对象</span></div><div class="line">    <span class="keyword">var</span> _person = <span class="keyword">new</span> Human();</div><div class="line">    <span class="comment">// 创建应聘者姓名解析对象</span></div><div class="line">    _person.name = <span class="keyword">new</span> Named(name);</div><div class="line">    <span class="comment">// 创建应聘者期望职位</span></div><div class="line">    _person.work = <span class="keyword">new</span> Work(work);</div><div class="line">    <span class="comment">// 返回创建的应聘者对象</span></div><div class="line">    <span class="keyword">return</span> _person;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-3"><a href="#收获与总结-3" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>建造者模式和前面几种创建型设计模式不同，它关心对象的整个创建过程，因此通常将创建对象的类模块化，这样使创建类的每一个模块都可以得到灵活的运用与高质量的复用。这种方式对于整个对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低，不建议使用建造者模式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是JavaScript语言之魂。</p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>还是关于子类继承父类的问题，为了提高性能，对于每次创建的一些简单的而又有差异化的属性可以放在构造函数中，将一些消耗资源比较大的方法放在基类的原型中，这样就可以避免不必要的消耗，这就是原型模式的雏形。<br>原型模式更多的是用在对象的创建上，比如创建一个实例对象的构造函数比较复杂或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，可以通过对这些对象属性或者方法进行复制来实现创建。首先要有一个原型对象的复制方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型对象复制方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototypeExtend</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        args = <span class="built_in">arguments</span>,</div><div class="line">        i = <span class="number">0</span>,</div><div class="line">        len = args.length;</div><div class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</div><div class="line">        <span class="comment">// 遍历每个模板对象中的属性</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">in</span> args[i]) &#123;</div><div class="line">            F.prototype[j] = args[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回缓存类实例</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>企鹅游戏中创建一个企鹅对象，如果没有企鹅基类，只提供了一些动作模板对象，可以通过实现这些模板对象的继承来创建一个企鹅实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> penguin = prototypeExtend(&#123;</div><div class="line">    <span class="attr">speed</span>: <span class="number">20</span>,</div><div class="line">    <span class="attr">swim</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'游泳速度'</span> + <span class="keyword">this</span>.speed);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">run</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'奔跑速度'</span> + <span class="keyword">this</span>.speed);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样通过prototypeExtend创建的就是一个对象，不用再用new去创建一个新的实例对象。</p>
<h3 id="收获与总结-4"><a href="#收获与总结-4" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>原型模式实际上也是一种继承，可以让多个对象分享同一个原型对象的属性和方法，这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象。原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>哈哈，让你感受下一个人的寂寞。</p>
<h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>又被称为单体模式，只允许实例化一次的对象类。有时也可以用一个对象来规划一个命名空间，井井有条地管理对象上的属性和方法。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>单例模式应该是JavaScript中最常见的一种设计模式了，经常为我们提供一个命名空间，来防止不同的人命名变量的冲突。还可以用它来创建一个小型的代码库。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = &#123;</div><div class="line">    <span class="attr">Util</span>: &#123;</div><div class="line">        <span class="attr">util_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">util_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Tool</span>: &#123;</div><div class="line">        <span class="attr">tool_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">tool_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Ajax</span>: &#123;</div><div class="line">        <span class="attr">ajax_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">ajax_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想使用这个代码库，像下面这样访问即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.Util.util_method1();</div><div class="line">A.Tool.tool_method2();</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-5"><a href="#收获与总结-5" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>单例模式有时也被称为单体模式，它是只允许实例化一次的对象类，有时这么做也是为了节省系统资源。JavaScript中单例模式经常作为命名空间对象来实现，通过单例对象，我们可以将各个模块的代码井井有条地梳理在一起。</p>
<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计。主要有外观模式，适配器模式，代理模式，装饰者模式，桥接模式，组合模式和享元模式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>作者把这种模式比喻成一种套餐服务。</p>
<h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更加容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>
<h3 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h3><p>为页面文档document对象添加点击事件时，如果直接用onclick来绑定事件，那么如果团队中再有人要为document绑定click事件时，就会把之前绑定的那个时间覆盖，因为这是DOM0级事件。我们应该用DOM2级事件处理程序提供的addEventListener来实现，然而老版本IE是不支持这个方法的，必须用attachEvent，这样如果我们写一个能兼容所有浏览器的方式操作起来就会更方便，这时候就可以用到外观模式。为功能统一但方法不统一的接口提供一个统一的接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 外观模式实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">dom, type, fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// 对于支持DOM2级事件处理程序的浏览器</span></div><div class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</div><div class="line">        dom.addEventListener(type, fn, <span class="literal">false</span>);</div><div class="line">    <span class="comment">// 对于不支持addEventListener但支持attachEvent的浏览器</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</div><div class="line">        dom.attachEvent(<span class="string">'on'</span> + type, fn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dom[<span class="string">'on'</span> + type] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解决浏览器兼容问题只是外观模式应用的一部分，很多代码库中都是通过外观模式来封装多个功能，简化底层造作方法的。</p>
<h3 id="收获与总结-6"><a href="#收获与总结-6" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用及其复杂。通过外观模式，对接口进行二次封装可以隐藏其复杂性。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>听到这个模式的名字，有没有想到水管弯弯的场景呢？</p>
<h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>将一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>
<h3 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h3><p>公司有个活动页面正在使用公司内部开发的A框架，可是很多新来的同事使用A框架开发新的功能需求时总是感觉很吃力，而且能用的方法有限，为了让新同事尽快融入项目的开发，可以引入jQuery框架，由于A框架和jQuery框架很像，这样就可以写一个适配器而不需要将之前的代码全用jQuery写一遍。<br>适配器模式不仅在编程中很常见，在生活中这种模式也很常见，比如三角插头充电器对于两项插头是不能用的，此时就需要一个三项转两项插头电源适配器，这就是一种适配器模式，其实它就是为了两个代码库所写的代码兼容运行而书写的额外代码。<br>JavaScript中适配器模式还能适配两个代码库，适配参数，适配数据，适配服务端数据等。以参数适配为例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">name, title, age, color, size, prize</span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>记住这些参数的顺序是很困难的，所以我们经常是以一个参数对象方式传入的，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * obj.name: name</div><div class="line"> * obj.title: title</div><div class="line"> * obj.age: age</div><div class="line"> * obj.color: color</div><div class="line"> * obj.size: size</div><div class="line"> * obj.prize: prize</div><div class="line">***/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">obj</span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>然而当调用的时候也不能确定传递的参数是否完整，如有一些必须得参数没有传入，一些参数有默认值等，这个时候就可以用适配器来适配传入的参数对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _adapter = &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">'雨夜清荷'</span>,</div><div class="line">        <span class="attr">title</span>: <span class="string">'设计模式'</span>,</div><div class="line">        <span class="attr">age</span>: <span class="number">24</span>,</div><div class="line">        <span class="attr">color</span>: <span class="string">'pink'</span>,</div><div class="line">        <span class="attr">size</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">prize</span>: <span class="number">50</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> _adapter) &#123;</div><div class="line">        _adapter[i] = obj[i] || _adapter[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-7"><a href="#收获与总结-7" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>JavaScript中的适配器更多应用在对象之间，为了使对象可用，通常会将对象拆分并重新包装，这样就要了解适配器对象的内部结构，这也是与外观模式的区别所在。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>有没有想到牛郎织女鹊桥相会的场景？</p>
<h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。</p>
<h3 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h3><p>跨域问题应该是使用代理模式解决的一个最典型的问题。由于用户模块上传的照片量越来越大，导致服务器需要将上传模块重新部署到另外一个域中，这就导致了跨域问题。我们可以将相册页面和上传模块所在的服务器抽象成两个对象，想让跨域两端的对象之间实现通信，就需要找个代理对象来实现他们之间的通信。<br>代理对象有很多种，简单一点的如img之类的标签通过src可以向其他域下的服务器发送请求。不过这类请求是get请求，是单向的，不会有响应数据。另外一种代理对象的形式是通过script标签。而我们需要的代理对象，是对页面与浏览器间通信的，JSONP就实现了一种代理模式。我们知道src属性可以实现get请求，因此可以在src指向的url地址上添加一些字段信息，服务器获取这些字段信息，相应生成一分内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 前端浏览器页面</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="comment">// 回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallBack</span>(<span class="params">res,req</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(res,req);</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost/test/jsonp.php?callback=jsonp CallBack&amp;data=getJsonPData"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 另一个域下的服务器请求接口</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/* 后端获取请求字段数据，并生成返回内容 */</span></div><div class="line">$data = $_GET[<span class="string">"data"</span>];</div><div class="line">$callback = $_GET[<span class="string">"callback"</span>];</div><div class="line"><span class="keyword">echo</span> $callback.<span class="string">"('success', '"</span>.$data.<span class="string">"')"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>这种方式可以想象成合理的一只小船，通过小船将你的请求发送给对岸，然后对岸的人们将数据放在小船里为你带回来。</p>
<h3 id="收获与总结-8"><a href="#收获与总结-8" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>代理模式除了在跨域问题中有很多应用外，有时对对象的实例化对资源的开销很大，如页面加载初期加载文件有很多，此时能够延迟加载一些图片对页面首屏加载时间收益是很大的，通过代理可以先加载预览图片然后再加载开销大的图片。<br>由此可见，代理模式可以解决系统之间耦合度以及系统资源开销大的问题，通过代理对象可以保护被代理对象，使被代理对象不受外界的影响。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>显然房子装修就是一种典型的装饰者模式。</p>
<h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>
<h3 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h3><p>静止是相对的，运动是绝对的，所以没有一成不变的需求。在实际项目开发中需求总在不断变化，当原有的功能已经不能满足用户的需求时，我们要做的就是在这个基础上添砖加瓦，设置新功能和属性来满足用户提出的需求，这就是装饰者模式要做的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 装饰者</span></div><div class="line"><span class="keyword">var</span> decorator = <span class="function"><span class="keyword">function</span>(<span class="params">input, fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// 获取事件源</span></div><div class="line">    <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(input);</div><div class="line">    <span class="comment">// 若事件源已经绑定事件</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> input.onclick === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="comment">// 缓存事件源原有回调函数</span></div><div class="line">        <span class="keyword">var</span> oldClickFn = input.onclick;</div><div class="line">        <span class="comment">// 为事件源定义新的事件</span></div><div class="line">        input.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 事件源原有回调函数</span></div><div class="line">            oldClickFn();</div><div class="line">            <span class="comment">// 执行事件源新增回调函数</span></div><div class="line">            fn();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        input.onclick = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-9"><a href="#收获与总结-9" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>除了装饰者模式，适配器模式也可以对原有对象进行扩展，所不同的是适配器进行扩展很多时候是对对象内部结构的重组，因此了解其自身结构是必须的。而装饰者模式对对象的扩展是一种良性扩展，不用了解其具体实现，只是在外部进行了一次封装扩展。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>作者把这种模式比喻成城市间的公路。</p>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>
<h3 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h3><p>有时候，页面中一些小小细节的改变常常因逻辑相似而导致大片臃肿的代码，让页面苦涩不堪。现在项目有一个需求，是要把页面上部的用户信息添加一些鼠标划过的特效，但是用户信息由很多小组件组成，对于用户名，鼠标划过直接改变背景色，但是像用户等级、用户消息这类部件只能改变里面的数字内容，处理逻辑不太一样。这样就需要写不少代码，但是又会感觉很冗余。这时候，我们首先要提取共同点，对想的抽象逻辑做抽象提取处理。<br>对于用户信息模块的每一部分鼠标滑过与鼠标离开两个事件的执行函数有很大一部分是相似的，比如它们都处理每个部件中的某个元素，它们都是处理元素的字体颜色和背景颜色。可以创建下面这样一个函数，解除this耦合。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">dom, color, bg</span>) </span>&#123;</div><div class="line">    <span class="comment">// 设置元素的字体颜色</span></div><div class="line">    dom.style.color = color;</div><div class="line">    <span class="comment">// 设置元素的背景颜色</span></div><div class="line">    dom.style.background = bg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是对具体元素绑定事件了，但是仅仅知道元素事件绑定与抽象提取的设置样式方法changeColor是不够的，需要用一个方法将他们链接起来，这个方法就是桥接方法，这种模式就是桥接模式。就像你开着车去沈阳，那么你就需要找到一条连接北京与沈阳的公路，才能顺利往返两地。<br>对于事件的桥接方法，可以用一个匿名函数来代替。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spans = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</div><div class="line">spans[<span class="number">0</span>].onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    changeColor(<span class="keyword">this</span>, <span class="string">'red'</span>, <span class="string">'#ddd'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-10"><a href="#收获与总结-10" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>桥接模式最主要的特点是将实现层（如元素绑定事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，桥接模式主要是对结构之间的解耦。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>作者把组合模式比喻成超值午餐，感觉很形象。</p>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层级结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h3 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h3><p>为强化首页用户体验，项目经理准备在用户首页添加一个新闻模块，当然新闻的内容是根据用户平时关注的内容挖掘的，因此有的人可能会显示文字新闻，有的人可能会是图片新闻等等。<br>我们先来仔细分析下这个需求，需求中的这些新闻大致可以分为相互独立的几种类型，对某类新闻做修改时不会影响到其他类的新闻，这样可以将每一类新闻抽象成面向对象编程中的一个类，然后在这些新闻类中挑选一些组合成需要的模块，这时候就可以用组合模式了。<br>在页面中，组合模式更常用在创建表单上，比如注册页面可能有不同的表单提交模块。对于这些需求，我们只需要有一个基本的个体，然后通过一定的组合即可实现。</p>
<h3 id="收获与总结-11"><a href="#收获与总结-11" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>组合模式能够给我们提供一个清晰的组成结构，组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了统一管理与使用。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>作者把享元模式比喻成城市公交车，可以仔细思考一番。</p>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>
<h3 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h3><p>现在有新闻的内容太多，我们有了一个分页显示所有新闻的需求。一个简单直观的做法就是页面加载后异步请求新闻数据，然后创建所有条新闻插入页面中，需要显示哪一页就显示哪一页。但是这样做有一个很大的问题，这样一下子创建几百条新闻同时插入页面会造成多页的开销严重影响网页的性能。这里的所有新闻都有相似的结构，只是内容不同罢了，对于这种相同结构造成多余开销的问题，可以用享元模式来解决。<br><strong>享元模式</strong> 主要是对其数据、方法共享分离，将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或共有的数据和方法，所以将其提取出来减少开销。上面例子中，所有新闻个体都有共同的结构，应该作为内部数据，而下一页按钮绑定的事件则是外部方法。同时为了使用内部数据还需要提供一个操作方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Flyweight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 已创建的元素</span></div><div class="line">    <span class="keyword">var</span> created = [];</div><div class="line">    <span class="comment">// 创建一个新闻包装容器</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">        <span class="comment">// 将容器插入新闻列表容器中</span></div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).appendChild(dom);</div><div class="line">        <span class="comment">// 缓存新创建的元素</span></div><div class="line">        created.push(dom);</div><div class="line">        <span class="comment">// 返回创建的新元素</span></div><div class="line">        <span class="keyword">return</span> dom;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 获取创建新闻元素方法</span></div><div class="line">        getDiv: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果已创建的元素小于当前页元素总个数(5个)，则创建</span></div><div class="line">            <span class="keyword">if</span>(created.length &lt; <span class="number">5</span>) &#123;</div><div class="line">                <span class="keyword">return</span> created();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 获取第一个元素，并插入去后面</span></div><div class="line">                <span class="keyword">var</span> div = created.shift();</div><div class="line">                created.push(div);</div><div class="line">                <span class="keyword">return</span> div;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面创建一个享元类，由于每页只能显示5条新闻，所以创建5个元素，保存在享元类内部，可以通过getDiv方法来获取创建的元素。下面就要实现外部数据和外部方法，外部数据就是我们要显示的所有新闻内容，由于每个内容都不一样肯定不能共享。首先，我们要根据新闻内容实例化页面，然后，对下一页绑定一个点击事件，显示下一页。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> paper = <span class="number">0</span>,</div><div class="line">    num = <span class="number">5</span>,</div><div class="line">    len = article.length;</div><div class="line"><span class="comment">// 添加五条新闻</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(article[i])</div><div class="line">        <span class="comment">// 通过享元类获取创建的元素并写入新闻内容</span></div><div class="line">        Flyweight.getDiv().innerHTML = article[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下一页按钮绑定事件</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'next_page'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果新闻内容不足5条则返回</span></div><div class="line">    <span class="keyword">if</span>(article.length &lt; <span class="number">5</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> n = ++paper * num % len,  <span class="comment">// 获取当前页的第一条新闻索引</span></div><div class="line">        j = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 插入5条新闻</span></div><div class="line">    <span class="keyword">for</span>(; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">        <span class="comment">// 如果存在n+j条则插入</span></div><div class="line">        <span class="keyword">if</span>(article[n + j]) &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = article[n + j];</div><div class="line">        <span class="comment">// 否则插入起始位置第n+j-len条</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(article[n + j - len]) &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = article[n + j - len];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样用享元模式对页面重构之后每次操作只需要操作5个元素，这样性能可以提高很多。</p>
<h3 id="收获与总结-12"><a href="#收获与总结-12" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>享元模式的应用是为了提高程序的执行效率与系统性能，因此在大型系统开发中应用比较广泛，可以避免程序中的数据重复。应用时一定要找准内部状态与外部状态，这样才能更合理地提取分离。</p>
<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。行为型设计模式主要有模板方法模式，观察者模式，状态模式，策略模式，职责链模式，命令模式，访问者模式，中介者模式，备忘录模式，迭代器模式和解释器模式，这么多的模式真得好好消化一阵子了。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>作者把这种模式比喻成照猫画虎。</p>
<h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类，使得子类可以不改变父类算法结构的同时可重新定义算法中某些实现步骤。</p>
<h3 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h3><p>提示框归一化，一个网站有很多页面，如果每个页面的弹出框样式不太一致就会显得不是很和谐，需要将他们的样式统一。新手最直观的想法就是去每个页面一个个修改，当然这样的代价是很大的，我们需要写一个弹出框插件，将这些弹出框封装好，然后再各个页面调用即可。这是在这个插件中就可以使用模板方法模式了，不需要重复写多个样式。<br>模板方法模式就是将多个模型抽象画归一，从中抽象出一个最基本的模板，这个模板可以作为实体也可以作为抽象对象，其他模块只需要继承这个模板方法，也可以扩展某些方法。<br>打个比方，我们生活中用蛋糕做模具做蛋糕，做出的蛋糕是外形相同的，因为他们都用同一个模具。然而商店里面卖的蛋糕是各式各样的，这都是对蛋糕的二次加工。我们的需求中基本提示框就是我们抽象出来的模具，其他提示框比这个提示框要多一些功能，我们只需要对他们做一些二次加工就能满足需求了。<br>模板方法不仅在归一化组件时使用，有时候创建页面时也是很常用的，比如创建三类导航，第一类是基础的，第二类是多了消息提醒功能的，第三类多了后面显示网址功能。这也可以用模板方法实现，此时抽象出来的基类是最简单的基础导航类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式化字符串方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formateString</span>(<span class="params">str, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\&#123;#(\w+)#\&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> data[key] === <span class="literal">undefined</span> ? <span class="string">''</span>: data[key]</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 基础导航</span></div><div class="line"><span class="keyword">var</span> Nav = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 基础导航样式模板</span></div><div class="line">    <span class="keyword">this</span>.item = <span class="string">'&lt;a href="&#123;#href#&#125;" title="&#123;#title#&#125;"&gt;&#123;#name#&#125;&lt;/a&gt;'</span>;</div><div class="line">    <span class="comment">// 创建字符串</span></div><div class="line">    <span class="keyword">this</span>.html = <span class="string">''</span>;</div><div class="line">    <span class="comment">// 格式化数据</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">this</span>.html += formateString(<span class="keyword">this</span>.item, data[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回字符串数据</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于消息提醒导航类，只需额外添加消息提醒组件模板，并与消息提醒组件模板对传入的网址数据进行装饰，得到所需的字符串，在调用从基类继承的方法处理这些字符串即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> NumNav = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 消息提醒信息组件模板</span></div><div class="line">    <span class="keyword">var</span> tpl = <span class="string">'&lt;b&gt;&#123;#num#&#125;&lt;/b&gt;'</span>;</div><div class="line">    <span class="comment">// 装饰数据</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        data[i].name += data[i].name + formateString(tpl, data[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 继承基础导航类</span></div><div class="line">    <span class="keyword">return</span> Nav.call(<span class="keyword">this</span>, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-13"><a href="#收获与总结-13" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>模板方法的核心在于对方法的重用，将核心方法封装在基类中，让子类继承基类的方法，实现基类方法的共享，达到方法共用。子类继承的方法是可扩展的，这就需要对基类继承的方法进行重写。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>作者把这种模式比喻成通信卫星。</p>
<h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>
<h3 id="使用场景-13"><a href="#使用场景-13" class="headerlink" title="使用场景"></a>使用场景</h3><p>在团队开发中，经常是一个人负责一个模块，那么每人负责的模块之间要如何进行沟通呢？比如你实现一些需求需要添加一些代码，但是这个需求需要其他模块配合，但是每个模块都是不同人写的，你不想因为新添加的代码影响到他人实现的功能，这个时候就需要用到观察者模式了。<br>观察者模式就是为了解决主体对象与观察者之间的耦合。打个比方，目前每个国家都在研发并发射卫星，发射这些卫星是为了监控一些信息，那么它就可以被看做一个观察者或者说是一个消息系统，如果让这颗卫星为飞机导航，那么这架飞机就是一个被观察者或者说是一个主体对象。那么如果地面上的中转站或者其他飞机需要知道这架飞机的信息，于是每当飞机到达一个地方时就会向卫星发出位子信息，然后卫星又将信息广播到已经订阅这架飞机的中转站，这样就可以避免一些飞机事故发生。<br>这时候，观察者至少需要有两个方法，一个是接收某架飞机发来的消息，一个是向订阅的中转站发送响应消息。但是，并不是每个中转站都要时刻监控飞机状态的，所以还需要一个取消注册的方法。当然这些消息还需要保存，就需要一个保存消息的容器。这时候观察者雏形就出来了，他有一个消息容器和三个方法，订阅消息方法，取消订阅消息方法，发送订阅消息方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Observer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 防止消息队列暴露而被篡改，故将消息容器作为静态私有变量保存</span></div><div class="line">    <span class="keyword">var</span> __messages = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 注册信息接口</span></div><div class="line">        regist: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 发布信息接口</span></div><div class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 移除信息接口</span></div><div class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>下面就是可以自己具体实现这些接口了。</p>
<h3 id="收获与总结-14"><a href="#收获与总结-14" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>观察者模式最主要是解决类或对象之间的耦合，解耦两个互相依赖的对象，使其依赖于观察者的消息机制。这样对于任何一个订阅者来说，其他订阅者对象的改变不会影响到自身，其自身既可以是消息的发出者也可以是消息的执行者，这都依赖于调用观察者对象中的三种方法（订阅，注销，发布消息）中的哪一种。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>作者把这种模式比喻成超级玛丽。</p>
<h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对像。</p>
<h3 id="使用场景-14"><a href="#使用场景-14" class="headerlink" title="使用场景"></a>使用场景</h3><p>平时写代码的时候经常会遇到要写很多条件判断语句的情况，那么怎么减少代码中的条件判断语句呢？对于这类分支条件内部独立结果的管理，可以使用状态模式，每一种条件作为对象的一种状态，面对不同的判断结果，其实就是选择对象内的一种状态。<br>将不同的判断结果封装在状态对象内，然后该状态对象返回一个可被调用的接口方法，用于调用状态对象内部的某种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 投票结果状态对象</span></div><div class="line"><span class="keyword">var</span> ResultState = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断结果保存在内部状态中</span></div><div class="line">    <span class="keyword">var</span> States = &#123;</div><div class="line">        <span class="comment">// 每种状态作为一种独立方法保存</span></div><div class="line">        state0: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第一种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第二种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第三种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第四种情况'</span>)：</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取某种状态并执行对应方法</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">        States[<span class="string">'state'</span> + result] &amp;&amp; States[<span class="string">'state'</span> + result]();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 返回调用状态方法接口</span></div><div class="line">        show: show</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>想调用第三种结果就可以如下调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResultState.show(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>对于状态模式，主要目的就是将条件判断的不同结果转化为状态对象的内部状态，这个内部状态一般作为状态对象的私有变量，然后提供一个能够调用状态对象内部状态的接口方法对象即可。</p>
<h3 id="收获与总结-15"><a href="#收获与总结-15" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>状态模式既是解决程序中臃肿的分支判断语句问题，将每一个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次只需时遍历所有分支。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>作者把这种模式比喻成活诸葛。</p>
<h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><p>将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。</p>
<h3 id="使用场景-15"><a href="#使用场景-15" class="headerlink" title="使用场景"></a>使用场景</h3><p>年底的时候，公司商品展销页都要开展大促销活动。在圣诞节，一部分商品5折出售，一部分商品8折出售，一部分商品9折出售，到元旦搞个幸运反馈活动，普通用户满100返30，高级VIP用户满100返50。这个时候上面的状态模式就不适用了，因为每一天每一个商品只有一种促销情况，这个时候可以用策略模式。<br>结构上看，它与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现实现对内部对象的调用，不同点是，策略模式不需要管理状态、状态间没有依赖关系、策略之剑可以相互替换、在策略对象内部保存的是相互独立的一些算法。看看策略对象的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 价格策略对象</span></div><div class="line"><span class="keyword">var</span> PriceStrategy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 内部算法对象</span></div><div class="line">    <span class="keyword">var</span> strategy = &#123;</div><div class="line">        <span class="comment">// 100返30</span></div><div class="line">        return30: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 100返50</span></div><div class="line">        return50: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 9折</span></div><div class="line">        percent90: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 8折</span></div><div class="line">        percent80: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 5折</span></div><div class="line">        percent50: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;&#125;,</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 策略算法调用接口</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">algorithm, price</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> strategy[algorithm] &amp;&amp; strategy[algorithm](price);</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-16"><a href="#收获与总结-16" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>策略模式主要特色是创建一系列策略算法，每组算法处理业务都是相同的，只是处理的过程或者处理的结果不一样，所以它们是可以相互替换的，这样就解决了算法与使用者之间的耦合。</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>作者把这种模式比喻成一个有序车站。</p>
<h3 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h3><p>解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，知道最后一个对象完成请求的处理。</p>
<h3 id="使用场景-16"><a href="#使用场景-16" class="headerlink" title="使用场景"></a>使用场景</h3><p>项目经理准备改善页面中的输入验证与提示交互体验。如用户在输入框输入信息后，在输入框的下面提示出一些备选项，当用户输入完成后，则要对用户输入信息进行验证等，页面中很多模块需要用户提交信息，为增强用户体验，这些输入框大部分需要具备以上两种功能。现在需要完成这个需求，但是以后可能要对原有表单交互体验做一些修改，也就是这是一个半成品需求。这种情况下，我们需要将需求里面需要做的每一件事情独立出来，这样完整的需求就变成一个个相互独立的模块需求，这样就不会因为以后需求的改变而影响我们项目的进展，这样还有利于以后的单元测试。这其实就是一种职责链模式。<br>对于上面的需求，对输入框绑定事件是第一部分，第二部分是创建xhr进行异步数据获取，第三部分就是适配响应数据，将接收到的数据格式化成可处理的形式，最后一部分是向组件创建器传入相应数据生成组件。</p>
<h3 id="收获与总结-17"><a href="#收获与总结-17" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>职责链模式定义了请求的传递方向，通过多个对象对请求的传递，实现一个复杂的逻辑操作。因此职责链模式将负责的需求颗粒化逐一实现每个最小分内的需求，并将请求顺序地传递。对于职责链上的每一个对象来说，它可能是请求的发起者也可能是请求的接收者，通过这种方式不仅仅简化原对象的复杂度，而且解决原请求的发起者与原请求的接收者之间的耦合。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h3><p>将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。</p>
<h3 id="使用场景-17"><a href="#使用场景-17" class="headerlink" title="使用场景"></a>使用场景</h3><p>现在的需求是要做一个活动页面，平铺式的结构，不过页面的每个模块都有些相似的地方，比如每个预览产品图片区域，都有一行标题，然后标题下面是产品图片，只是图片的数量与排列不同。我们需要一种自由创建视图模块的方法，有时候创建多张图片有时候只创建一张图片，这时候可以试试命令模式。<br>命令模式是将创建模块的逻辑封装在一个对象里，这个对象提供一个参数化的请求接口，通过调用这个接口并传递一些参数实现调用命令对象内部中的一些方法。请求部分很简单，只需要按照给定参数格式书写指令即可，所以实现部分的封装才是重点，因为它要为请求部分提供所需方法。<br>那么哪些对象需要被命令化呢？既然需要动态展示不同模块，所以创建元素这一需求就是变化的，因此创建元素方法、展示方法应该被命令化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模块实现模块</span></div><div class="line"><span class="keyword">var</span> viewCommand = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tpl = &#123;</div><div class="line">        <span class="comment">// 展示图片结构模块</span></div><div class="line">        product: [</div><div class="line">            <span class="string">'&lt;div&gt;'</span>,.....,<span class="string">'&lt;/div&gt;'</span></div><div class="line">        ].join(<span class="string">''</span>),</div><div class="line">        <span class="comment">// 展示标题结构模块</span></div><div class="line">        title: [</div><div class="line">        <span class="string">'&lt;div&gt;'</span>,.....,<span class="string">'&lt;/div&gt;'</span></div><div class="line">        ].join(<span class="string">''</span>),</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 格式化字符串缓存字符串</span></div><div class="line">    html = <span class="string">''</span>;</div><div class="line">    <span class="comment">// 格式化字符串</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">formateString</span>(<span class="params">str, obj</span>) </span>&#123;&#125;</div><div class="line">    <span class="comment">// 方法集合</span></div><div class="line">    <span class="keyword">var</span> Action = &#123;</div><div class="line">        <span class="comment">// 创建方法</span></div><div class="line">        create: <span class="function"><span class="keyword">function</span>(<span class="params">data, view</span>) </span>&#123;</div><div class="line">            <span class="comment">// 解析数据</span></div><div class="line">            <span class="keyword">if</span>(data.length) &#123;</div><div class="line">                <span class="comment">// 遍历</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</div><div class="line">                    html += formateString(tpl[view], data[i]);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                html += formateString(tpl[view], data);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 展示方法</span></div><div class="line">        display: <span class="function"><span class="keyword">function</span>(<span class="params">container, data, vuew</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果传入数据</span></div><div class="line">            <span class="keyword">if</span>(data) &#123;</div><div class="line">                <span class="comment">// 根据给的数据创建视图</span></div><div class="line">                <span class="keyword">this</span>.create(data, view);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 展示模块</span></div><div class="line">            <span class="built_in">document</span>.getElementById(container).innerHTML = html;</div><div class="line">            <span class="comment">// 展示后清空缓存字符串</span></div><div class="line">            html = <span class="string">''</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 命令接口</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">excute</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">        <span class="comment">// 解析命令，如果msg.param不是数组则将其转化为数组</span></div><div class="line">        msg.param = <span class="built_in">Object</span>.prototype.toString.call(msg.param) === <span class="string">"[object Array]"</span> ? msg.param : [msg.param];</div><div class="line">        <span class="comment">// Action内部调用的方法引用this，此处保证作用域this执行传入Action</span></div><div class="line">        Action[msg.command].apply(Action, msg.param)</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>下面就可以测试这个命令对象了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> productData = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">src</span>: <span class="string">'command/02.jpg'</span>,</div><div class="line">        <span class="attr">text</span>: <span class="string">'绽放的桃花'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">src</span>: <span class="string">'command/03.jpg'</span>,</div><div class="line">        <span class="attr">text</span>: <span class="string">'阳光下的温馨'</span></div><div class="line">    &#125;</div><div class="line">],</div><div class="line"><span class="comment">// 模块标题数据</span></div><div class="line">titleData = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">'夏日里的一片温馨'</span>,</div><div class="line">    <span class="attr">tips</span>: <span class="string">'暖暖的温情带给人们家的感觉'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用命令对象</span></div><div class="line">viewCommand(&#123;</div><div class="line">    <span class="attr">command</span>: <span class="string">'display'</span>,</div><div class="line">    <span class="attr">param</span>: [<span class="string">'title'</span>, titleData, <span class="string">'title'</span>]</div><div class="line">&#125;);</div><div class="line">viewCommand(&#123;</div><div class="line">    <span class="attr">command</span>: <span class="string">'create'</span>,</div><div class="line">    <span class="attr">param</span>: [<span class="string">'product'</span>, productData, <span class="string">'product'</span>]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>有了命令模式，想创建任何页面视图都是一件很简单的事情。</p>
<h3 id="收获与总结-18"><a href="#收获与总结-18" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>命令模式是将执行的命令封装，解决命令发起者与命令执行者之间的耦合，每一条命令实质上是一个操作。命令的是使用者不必了解命令执行者的命令接口是如何实现的，只需要知道如何调用。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>作者把这种模式比喻成驻华大使。</p>
<h3 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h3><p>针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的新方法。</p>
<h3 id="使用场景-18"><a href="#使用场景-18" class="headerlink" title="使用场景"></a>使用场景</h3><p>用DOM2级事件为页面中元素绑定事件时，为css设置一些样式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params">dom, type, fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</div><div class="line">        dom.addEventListener(type, fn, <span class="literal">false</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</div><div class="line">        dom.attachEvent(<span class="string">'on'</span> + type, fn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dom[<span class="string">'on'</span> + type] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> demo = <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>);</div><div class="line">bindEvent(demo, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.style.background = <span class="string">'red'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个在IE浏览器中会出问题，因为IE的attachEvent事件中this指向的竟然是window而不是这个元素，所以如果想获取事件对象必须用window.e来获取。这个问题可以借用访问者模式来解决。<br>访问者模式的思想是我们在不改变操作对象的同时，为它添加新的操作方法，来实现对操作对象的访问。下面看看IE的实现方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindIEEvent</span>(<span class="params">dom, type, fn, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = data || &#123;&#125;;</div><div class="line">    dom.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        fn.call(dom, e, data);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面实现方法的核心就是调用call方法，call方法的作用就是更改函数执行时的作用域，这正是访问者模式的精髓。</p>
<h3 id="收获与总结-19"><a href="#收获与总结-19" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>访问者模式解决数据与数据操作方法之间的耦合，将数据的操作方法独立于数据，使其可以自由化演变。访问者更适合那些数据稳定但是数据的操作方法易变的环境下。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>作者把这种模式比喻成媒婆，好吧，我笑了这里。</p>
<h3 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h3><p>通过中介者对象封装一系列对象之间的交互，是对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可以改变对象之间的交互。</p>
<h3 id="使用场景-19"><a href="#使用场景-19" class="headerlink" title="使用场景"></a>使用场景</h3><p>项目经理准备在用户首页上的导航模块添加一个设置层，让用户可以通过设置层来设置导航展开样式。但是页面中好多模块都有导航，这要改起来工作量也很大，上面讲的观察者模式虽然能解决模块之间的耦合，但是这里我们并没有需要向设置层发送请求的需求，设置层只是单向控制导航模块内导航的样式。这样的单向通信就可以使用中介者模式。<br>观察者模式和中介者模式都是通过消息收发机制实现，不过在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，而中介者模式中消息的发送方只有一个就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象（订阅者）才能订阅中介者消息。<br>如果用中介者模式来解决上面的问题，那么中介者对象就是设置层模块对象，它负责向各个导航模块对象发送用户设置消息，而各个导航模块则应该作为消息的订阅者存在，实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 中介者对象</span></div><div class="line"><span class="keyword">var</span> Mediator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 消息对象</span></div><div class="line">    <span class="keyword">var</span> _msg = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 订阅消息方法，type:消息名称 action:消息回调函数</span></div><div class="line">        register: <span class="function"><span class="keyword">function</span>(<span class="params">type, action</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果消息存在</span></div><div class="line">            <span class="keyword">if</span>(_msg[type])</div><div class="line">                <span class="comment">// 存入回调函数</span></div><div class="line">                _msg[type].push(action);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不存在则建立消息容器</span></div><div class="line">                _msg[type] = [];</div><div class="line">                _msg[type].push(action);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 发布消息方法</span></div><div class="line">        send: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果该消息已经被订阅</span></div><div class="line">            <span class="keyword">if</span>(_msg[type]) &#123;</div><div class="line">                <span class="comment">// 遍历已存储的消息回调函数</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = _msg[type].length; i &lt; len; i++) &#123;</div><div class="line">                    <span class="comment">// 执行回调函数</span></div><div class="line">                    _msg[type][i] &amp;&amp; _msg[type][i]();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>这样就创建了一个中介者对象，下面就可以利用这个中介者对象完成我们的需求了。</p>
<h3 id="收获与总结-20"><a href="#收获与总结-20" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>同观察者模式一样，中介者模式的主要业务也是通过模块间或者对象间的复杂通信，来解决模块间或对象间的耦合。在中介者模式中，订阅者是单向的，只能是订阅者而不能是发布者。而消息统一由中介者对象发布。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h3><p>在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部状态以便日后对象使用或者对象恢复到以前的某个状态。</p>
<h3 id="使用场景-20"><a href="#使用场景-20" class="headerlink" title="使用场景"></a>使用场景</h3><p>在前面提到的新闻页面中，有上一页和下一页的按钮，页面的内容是用异步请求获取的。如果点击下一页按钮接着再点击上一页那么之前那一页又要进行一次异步请求，这是多余的操作。因为第一次已经获取了数据，不需要再发送多余的请求。这个时候可以用备忘录模式来缓存请求过的数据。也就是说每次发生请求的时候对当前状态做一次记录，将请求到的数据以及对应得页码缓存下来，如果之后返回到之前浏览过的页面，直接在缓存中查询即可，不用发生异步请求。先创建一个新闻缓存器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Page备忘录类</span></div><div class="line"><span class="keyword">var</span> Page = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 信息缓存对象</span></div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">page, fn</span>) </span>&#123;</div><div class="line">        <span class="comment">// 判断该页数据是否在缓存中</span></div><div class="line">        <span class="keyword">if</span>(cache[page]) &#123;</div><div class="line">            <span class="comment">// 显示该页内容</span></div><div class="line">            showPage(page, cache[page]);</div><div class="line">            <span class="comment">// 执行成功回调函数</span></div><div class="line">            fn &amp;&amp; fn();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 否则异步请求</span></div><div class="line">            $.post(<span class="string">'./data/getNewsData.php'</span>, &#123;</div><div class="line">                <span class="attr">page</span>: page</div><div class="line">            &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">                <span class="comment">// 成功返回</span></div><div class="line">                <span class="keyword">if</span>(res.errNo == <span class="number">0</span>) &#123;</div><div class="line">                    showPage(page, res.data);</div><div class="line">                    cache[page] = res.data;</div><div class="line">                    fn &amp;&amp; fn();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 处理异常</span></div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码可以看出Page缓存器内部缓存了每次请求回来的新闻数据，这样以后如果用户想回看某页新闻数据就不需要发送不必要的请求了。</p>
<h3 id="收获与总结-21"><a href="#收获与总结-21" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>备忘录模式最主要的任务是对现有的数据或状态进行缓存，为将类某个时刻使用或恢复做准备。但是当数据量过大时，会严重占用系统提供的资源，此时对缓存器的优化是很有必要的，复用率低的数据缓存下来是不值得的。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>作者把这种模式比喻成一个点钞机。</p>
<h3 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h3><p>在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。</p>
<h3 id="使用场景-21"><a href="#使用场景-21" class="headerlink" title="使用场景"></a>使用场景</h3><p>迭代器模式主要是解决重复循环迭代的问题，之前接触过面向对象语言的应该都对迭代器有所了解。迭代器就是用来顺序地访问一个聚合对象内部元素的，它可以简化我们遍历操作，就行银行里的点钞机，有了它可以大幅度降低我们的点钞成本。下面创建一个常用的迭代器对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Iterator = <span class="function"><span class="keyword">function</span>(<span class="params">items, container</span>) </span>&#123;</div><div class="line">    <span class="comment">// 获取父元素</span></div><div class="line">    <span class="keyword">var</span> container = container &amp;&amp; <span class="built_in">document</span>.getElementById(container) || <span class="built_in">document</span>,</div><div class="line">    <span class="comment">// 获取元素</span></div><div class="line">        items = container.getElementsByTagName(items),</div><div class="line">    <span class="comment">// 获取元素长度</span></div><div class="line">        length = items.length,</div><div class="line">    <span class="comment">// 当前索引值</span></div><div class="line">        index = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 缓存原生数组splice方法</span></div><div class="line">    <span class="keyword">var</span> splice = [].splice;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 获取第一个元素</span></div><div class="line">        first: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取最后一个元素</span></div><div class="line">        second: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取前一个元素</span></div><div class="line">        pre: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取后一个元素</span></div><div class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 获取某一个元素</span></div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 对每一个元素执行某一个方法</span></div><div class="line">        dealEach: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 对某一个元素执行某一个方法</span></div><div class="line">        dealItem: <span class="function"><span class="keyword">function</span>(<span class="params">num, fn</span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 排他方式处理某一个元素</span></div><div class="line">        exclusive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面具体实现迭代器里面的这些方法，然后就可以用这个迭代器对象啦。</p>
<h3 id="收获与总结-22"><a href="#收获与总结-22" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>通过迭代器我们可以顺序地访问一个聚合对象中的每一个元素。在开发中，迭代器极大简化了代码中的循环语句，使代码结构清晰紧凑。用迭代器去处理一个对象时，只需要提供处理的方法，而不必去关心对象的内部结构，这也解决了对象的使用者与对象内部结构之间的耦合。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h3><p>对于一种语言，给出其文法表示，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。</p>
<h3 id="使用场景-22"><a href="#使用场景-22" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个页面中的某些功能好坏有时是靠一定的数据依据支撑的。项目经理想看看用户对最近新增的功能使用情况，前后端要给出统计数据，然而前端交互统计项中要给出交互元素路径。这件事情与冒泡事件类似，只不过在这个路径中还要关心同一层级中当前元素的兄弟元素。比如下面的结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"link-inner"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button-inner"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>要获取button相对于class为wrap的div元素的Xpath路径，那么可以表示为DIV&gt;DIV2&gt;SPAN。<br>上面对需求的描述是一种文法，描述的是一组规则，现在要做的事实现一个规则解释器来解释上面的规则。首先要分析给出的文法，查找他们的相似点，然后该清楚我们要先实现什么再实现什么，基本上问题就能解决了。</p>
<h3 id="收获与总结-23"><a href="#收获与总结-23" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>一些描述性语句，几次功能的提取抽象，形成了一套语法法则，这就是解释器模式要处理的事情。是否能应用解释器模式的一条重要准则是能否根据需求解析出一套完整的语法规则，不论该语法规则简单或是复杂都是必须的。</p>
<h1 id="技巧型设计模式"><a href="#技巧型设计模式" class="headerlink" title="技巧型设计模式"></a>技巧型设计模式</h1><p>技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。这本书中总结了8种技巧型设计模式，分别是链模式，委托模式，数据访问对象模式，节流模式，简单模板模式，惰性模式，参与者模式和等待者模式。有兴趣的同学可以去买书来看哦，这里就不一一解释了。</p>
<h1 id="架构型设计模式"><a href="#架构型设计模式" class="headerlink" title="架构型设计模式"></a>架构型设计模式</h1><p>架构型设计模式是一类框架结构，通过提供一些子系统，指定它们的职责，并将它们条理清晰地组织在一起。现在流行的前端框架都用了这种类型的设计模式。本书总结了6种架构型设计模式，分别是同步模块模式，异步模块模式，Widget模式，MVC模式，MVP模式和MVVM模式。</p>
<p>学习设计模式的学习对于我们来说任重而道远，我们需要在实践中不断思考不断总结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触前端两三个月的时候，那时候只是听说设计模式很重要，然后我就去读了一本设计模式的书，读了一部分，也不知道这些设计模式到底设计出来干嘛的，然后就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://yuhan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli#2.0项目结构分析</title>
    <link href="http://yuhan.com/2016/12/20/vue-cli-2-0/"/>
    <id>http://yuhan.com/2016/12/20/vue-cli-2-0/</id>
    <published>2016-12-20T11:17:06.000Z</published>
    <updated>2017-03-04T08:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触过vue的同学应该都知道，用vue-cli开发vue的项目十分方便，它可以帮你快速构建一个具有强大构建能力的Vue.js项目。今天不谈什么是vue-cli，而是来说说用vue-cli构建的项目结构是什么样的并分析部分文件。这里以我之前写的一个小项目为参考，项目是用vue-cli的webpack模板构建的，项目地址：<a href="https://github.com/hieeyh/tong2-family" target="_blank" rel="external">https://github.com/hieeyh/tong2-family</a>。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">|-- build                            // 项目构建(webpack)相关代码</div><div class="line">|   |-- build.js                     // 生产环境构建代码</div><div class="line">|   |-- check-version.js             // 检查node、npm等版本</div><div class="line">|   |-- dev-client.js                // 热重载相关</div><div class="line">|   |-- dev-server.js                // 构建本地服务器</div><div class="line">|   |-- utils.js                     // 构建工具相关</div><div class="line">|   |-- webpack.base.conf.js         // webpack基础配置</div><div class="line">|   |-- webpack.dev.conf.js          // webpack开发环境配置</div><div class="line">|   |-- webpack.prod.conf.js         // webpack生产环境配置</div><div class="line">|-- config                           // 项目开发环境配置</div><div class="line">|   |-- dev.env.js                   // 开发环境变量</div><div class="line">|   |-- index.js                     // 项目一些配置变量</div><div class="line">|   |-- prod.env.js                  // 生产环境变量</div><div class="line">|   |-- test.env.js                  // 测试环境变量</div><div class="line">|-- src                              // 源码目录</div><div class="line">|   |-- components                     // vue公共组件</div><div class="line">|   |-- store                          // vuex的状态管理</div><div class="line">|   |-- App.vue                        // 页面入口文件</div><div class="line">|   |-- main.js                        // 程序入口文件，加载各种公共组件</div><div class="line">|-- static                           // 静态文件，比如一些图片，json数据等</div><div class="line">|   |-- data                           // 群聊分析得到的数据用于数据可视化</div><div class="line">|-- .babelrc                         // ES6语法编译配置</div><div class="line">|-- .editorconfig                    // 定义代码格式</div><div class="line">|-- .gitignore                       // git上传需要忽略的文件格式</div><div class="line">|-- README.md                        // 项目说明</div><div class="line">|-- favicon.ico </div><div class="line">|-- index.html                       // 入口页面</div><div class="line">|-- package.json                     // 项目基本信息</div><div class="line">.</div></pre></td></tr></table></figure>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。</p>
<h2 id="scripts字段"><a href="#scripts字段" class="headerlink" title="scripts字段"></a>scripts字段</h2><p>package.json文件里有一个scripts字段。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在开发环境下，在命令行中运行<code>npm run dev</code>就相当于在执行<code>node build/dev-server.js</code>。所以script字段是用来指定npm相关命令的缩写的。</p>
<h2 id="dependencies字段和devDependencies字段"><a href="#dependencies字段和devDependencies字段" class="headerlink" title="dependencies字段和devDependencies字段"></a>dependencies字段和devDependencies字段</h2><p>dependencies字段指定了项目运行时所依赖的模块，devDependencies字段指定了项目开发时所依赖的模块。在命令行中运行npm install命令，会自动安装dependencies和devDependencies字段中的模块。<br>package.json还有很多配置相关项，想进一步了解package.json的可参考：<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></p>
<h1 id="webpack配置相关"><a href="#webpack配置相关" class="headerlink" title="webpack配置相关"></a>webpack配置相关</h1><p>上面说到在命令行中<code>npm run dev</code>就相当于在执行<code>node build/dev-server.js</code>，想必dev-server.js这个文件是十分重要的，它是在开发环境下构建时第一个要运行的文件。掘金上已经有一篇对vue-cli#2.0 webpack配置的分析文章，里面详细讲解了webpack相关配置文件的每行代码的意思，我只做一些补充。链接在此（一定要仔细阅读，收获会很大）：<a href="https://gold.xitu.io/post/584e48b2ac502e006c74a120" target="_blank" rel="external">https://gold.xitu.io/post/584e48b2ac502e006c74a120</a>。</p>
<h2 id="dev-server-js"><a href="#dev-server-js" class="headerlink" title="dev-server.js"></a>dev-server.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line"><span class="comment">// http-proxy可以实现转发所有请求代理到后端真实API地址，以实现前后端开发完全分离</span></div><div class="line"><span class="comment">// 在config/index.js中可以对proxyTable想进行配置</span></div><div class="line"><span class="keyword">var</span> proxyMiddleware = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</div><div class="line">...</div><div class="line">...</div><div class="line"><span class="comment">// 热加载要使用webpack-dev-middleware在没有webpack-dev-server的时候进行热加载</span></div><div class="line"><span class="keyword">var</span> hotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>)(compiler)</div><div class="line"><span class="comment">// 当html-webpack-plugin模板改变是强制进行页面重新加载</span></div><div class="line">compiler.plugin(<span class="string">'compilation'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;</div><div class="line">  compilation.plugin(<span class="string">'html-webpack-plugin-after-emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data, cb</span>) </span>&#123;</div><div class="line">    hotMiddleware.publish(&#123; <span class="attr">action</span>: <span class="string">'reload'</span> &#125;)</div><div class="line">    cb()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line">module.export = &#123;</div><div class="line">    <span class="comment">// 编译入口文件</span></div><div class="line">    entry: &#123;&#125;,</div><div class="line">    <span class="comment">// 编译输出路径</span></div><div class="line">    output: &#123;&#125;,</div><div class="line">    <span class="comment">// 一些解决方案配置</span></div><div class="line">    resolve: &#123;&#125;,</div><div class="line">    <span class="attr">resolveLoader</span>: &#123;&#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="comment">// 各种不同类型文件加载器配置</span></div><div class="line">        loaders: &#123;</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        <span class="comment">// js文件用babel转码</span></div><div class="line">        &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">            <span class="attr">include</span>: projectRoot,</div><div class="line">            <span class="comment">// 哪些文件不需要转码</span></div><div class="line">            exclude: <span class="regexp">/node_modules/</span></div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// vue文件一些相关配置</span></div><div class="line">    vue: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="check-version-js"><a href="#check-version-js" class="headerlink" title="check-version.js"></a>check-version.js</h2><p>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载语义化版本测试库</span></div><div class="line"><span class="keyword">var</span> semver = <span class="built_in">require</span>(<span class="string">'semver'</span>)</div><div class="line"><span class="comment">// 定制控制台日志的输入样式</span></div><div class="line"><span class="keyword">var</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)</div><div class="line"><span class="comment">// 引入package.json文件</span></div><div class="line"><span class="keyword">var</span> packageConfig = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</div><div class="line"><span class="keyword">var</span> exec = <span class="function"><span class="keyword">function</span> (<span class="params">cmd</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'child_process'</span>)</div><div class="line">    .execSync(cmd).toString().trim()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义node和npm版本需求所组成的数组</span></div><div class="line"><span class="keyword">var</span> versionRequirements = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'node'</span>,</div><div class="line">    <span class="attr">currentVersion</span>: semver.clean(process.version),</div><div class="line">    <span class="attr">versionRequirement</span>: packageConfig.engines.node</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'npm'</span>,</div><div class="line">    <span class="attr">currentVersion</span>: exec(<span class="string">'npm --version'</span>),</div><div class="line">    <span class="attr">versionRequirement</span>: packageConfig.engines.npm</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> warnings = []</div><div class="line">  <span class="comment">// 依次判断版本是否符合要求</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; versionRequirements.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> mod = versionRequirements[i]</div><div class="line">    <span class="keyword">if</span> (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</div><div class="line">      warnings.push(mod.name + <span class="string">': '</span> +</div><div class="line">        chalk.red(mod.currentVersion) + <span class="string">' should be '</span> +</div><div class="line">        chalk.green(mod.versionRequirement)</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想把webpack完全搞懂还是需要费很大功夫的，我感觉自己也只是入了一个门而已，要想深入了解webpack还是要去官网看说明文档。</p>
<ol>
<li><a href="http://webpack.github.io/docs/" target="_blank" rel="external">http://webpack.github.io/docs/</a></li>
<li><a href="https://webpack.js.org/configuration/" target="_blank" rel="external">https://webpack.js.org/configuration/</a></li>
<li><a href="https://github.com/wangning0/Autumn_Ning_Blog/blob/master/blogs/3-12/webpack.md" target="_blank" rel="external">webpack学习之路</a></li>
</ol>
<h1 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h1><p>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。这里有一篇阮一峰老师写的相关文章供参考：<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">Babel 入门教程</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设定转码规则</span></div><div class="line"><span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"stage-2"</span>],</div><div class="line"><span class="comment">// 转码的一些插件</span></div><div class="line"><span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>],</div><div class="line"><span class="string">"comments"</span>: <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h1 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h1><p>该文件定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = true</div><div class="line"></div><div class="line">[*]    // 对所有文件应用下面的规则</div><div class="line">charset = utf-8                    // 编码规则用utf-8</div><div class="line">indent_style = space               // 缩进用空格</div><div class="line">indent_size = 2                    // 缩进数量为2个空格</div><div class="line">end_of_line = lf                   // 换行符格式</div><div class="line">insert_final_newline = true        // 是否在文件的最后插入一个空行</div><div class="line">trim_trailing_whitespace = true    // 是否删除行尾的空格</div></pre></td></tr></table></figure></p>
<p>了解更多请参考官方配置文档<a href="http://editorconfig.org/" target="_blank" rel="external">http://editorconfig.org/</a></p>
<p>接触vue并不久，很多东西也不是特别清楚，文章里有什么问题欢迎指出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触过vue的同学应该都知道，用vue-cli开发vue的项目十分方便，它可以帮你快速构建一个具有强大构建能力的Vue.js项目。今天不谈什么是vue-cli，而是来说说用vue-cli构建的项目结构是什么样的并分析部分文件。这里以我之前写的一个小项目为参考，项目是用vue
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="vue-cli" scheme="http://yuhan.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>vue-router2.0学习笔记</title>
    <link href="http://yuhan.com/2016/12/12/vue-router/"/>
    <id>http://yuhan.com/2016/12/12/vue-router/</id>
    <published>2016-12-12T02:30:18.000Z</published>
    <updated>2016-12-22T06:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="external">官方文档</a>。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。</p>
<h1 id="先上例子"><a href="#先上例子" class="headerlink" title="先上例子"></a>先上例子</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- html部分，省略head --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/goods"</span>&gt;</span>商品<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/ratings"</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/seller"</span>&gt;</span>商家<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path-to-vue"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path-to-vue-router"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先定义或者引入路由的组件</span></div><div class="line"><span class="comment">// 方法一：直接定义路由组件</span></div><div class="line"><span class="keyword">const</span> goods = &#123; <span class="attr">template</span>: <span class="string">'&lt;p&gt;goods&lt;/p&gt;'</span> &#125;;</div><div class="line"><span class="keyword">const</span> ratings = &#123; <span class="attr">template</span>: <span class="string">'&lt;p&gt;ratings&lt;/p&gt;'</span> &#125;;</div><div class="line"><span class="keyword">const</span> seller = &#123; <span class="attr">template</span>: <span class="string">'&lt;p&gt;seller&lt;/p&gt;'</span> &#125;;</div><div class="line"><span class="comment">// 方法二：import引入路由组件</span></div><div class="line"><span class="keyword">import</span> goods <span class="keyword">from</span> <span class="string">'components/goods/goods'</span>;</div><div class="line"><span class="keyword">import</span> ratings <span class="keyword">from</span> <span class="string">'components/ratings/ratings'</span>;</div><div class="line"><span class="keyword">import</span> seller <span class="keyword">from</span> <span class="string">'components/seller/seller'</span>;</div><div class="line"><span class="comment">// 然后定义路由(routes)，components还可以是Vue.extend()创建的</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/goods'</span>, <span class="attr">component</span>: goods &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/ratings'</span>, <span class="attr">component</span>: ratings &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/seller'</span>, <span class="attr">component</span>: seller &#125;</div><div class="line">];</div><div class="line"><span class="comment">// 接着创建路由实例</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  <span class="comment">// ES6缩写语法，相当于routes:routes</span></div><div class="line">  routes  </div><div class="line">&#125;);</div><div class="line"><span class="comment">// 最后创建vue实例并挂载</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  router</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure>
<p>到这里就可以用vue-router轻松搭建一个单页面应用了。我一般都是使用模块化编程的形式，用.vue单文件，不知道在模块化编程里怎么加载vue-router的可以参考我的<a href="https://github.com/hieeyh/tong2-family" target="_blank" rel="external">某个项目源码</a>。</p>
<h1 id="router-link和router-view"><a href="#router-link和router-view" class="headerlink" title="router-link和router-view"></a>router-link和router-view</h1><p>看了上面的例子，一定对router-link和router-view很感兴趣。</p>
<h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><p>从上面例子中的书写形式就可以看出，router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址。<br><strong>注意</strong>：被选中的router-link将自动添加一个class属性值<code>.router-link-active</code>。</p>
<h3 id="router-link属性配置"><a href="#router-link属性配置" class="headerlink" title="router-link属性配置"></a>router-link属性配置</h3><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><p>这是一个必须设置的属性，否则路由无法生效。它表示路由的链接，可以是一个字符串也可以是一个描述目标位置的对象。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"goods"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123;path='goods'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>一个布尔类型，默认为false。如果replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"goods"</span> <span class="attr">replace</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>router-link默认渲染成a标签，也有方法让它渲染成其他标签，tag属性就用来设置router-link渲染成什么标签的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 渲染成li标签 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"goods"</span> <span class="attr">tag</span>=<span class="string">"li"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h4><p>上面说了被选中的router-link将自动添加一个class属性值<code>.router-link-active</code>，这个属性就是来修改这个class值的。</p>
<h2 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h2><p>这个组件十分关键，它就是用来渲染匹配到的路由的。<br>可以给router-view组件设置transition过渡，具体用法见<a href="http://hyuhan.com/2016/12/08/vue-transition/" target="_blank" rel="external">Vue2.0 Transition常见用法全解惑</a>。<br>还可以配合<code>&lt;keep-alive&gt;</code>使用，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，之前那个路由组件的数据被清除了。比如对当前的路由组件a进行了一些DOM操作之后，点击进入另一个路由组件b，再回到路由组件a的时候之前的DOM操作还保存在，如果不加keep-alive再回到路由组件a时，之前的DOM操作就没有了，得重新进行。如果你的应用里有一个购物车组件，就需要用到keep-alive。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="一些小需求怎么实现"><a href="#一些小需求怎么实现" class="headerlink" title="一些小需求怎么实现"></a>一些小需求怎么实现</h1><h2 id="不同路由不同页面标题"><a href="#不同路由不同页面标题" class="headerlink" title="不同路由不同页面标题"></a>不同路由不同页面标题</h2><p>多页面应用我们可以给每一个页面都设置一个不同的标题，但是如果是单页面应用的路由呢？其实也是可以实现的，实现的方法不止一种，我之前用的是结合命名路由和导航钩子函数的方法。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义路由的时候如下定义，name也可为中文</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/goods'</span>, <span class="attr">component</span>: goods, <span class="attr">name</span>: <span class="string">'goods'</span> &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/ratings'</span>, <span class="attr">component</span>: ratings, <span class="attr">name</span>: <span class="string">'ratings'</span> &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/seller'</span>, <span class="attr">component</span>: seller, <span class="attr">name</span>: <span class="string">'seller'</span> &#125;</div><div class="line">];</div><div class="line"><span class="comment">// 创建路由实例</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  <span class="attr">routes</span>: routes</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 关键在这里，设置afterEach钩子函数</span></div><div class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">document</span>.title = to.name;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>既然用到了命名路由，这里就提一下吧。命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'seller'&#125;"</span>&gt;</span>seller<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="导航钩子"><a href="#导航钩子" class="headerlink" title="导航钩子"></a>导航钩子</h3><p>这个我还没怎么用过，它主要是用来拦截导航的，想使用的参考<a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank" rel="external">官方文档</a>吧。</p>
<h2 id="怎么刚进入应用就渲染某个路由组件"><a href="#怎么刚进入应用就渲染某个路由组件" class="headerlink" title="怎么刚进入应用就渲染某个路由组件"></a>怎么刚进入应用就渲染某个路由组件</h2><p>刚进入应用都是进入到“/”这个路由的，如果想直接进入到“/goods”怎么办，这里提供两种方法。一种是利用重定向，另一种是利用vue-router的导航式编程。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/goods'</span>&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>是不是很简单呢？重定向的目标也可以是一个命名的路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'goods'</span> &#125;&#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="导航式编程"><a href="#导航式编程" class="headerlink" title="导航式编程"></a>导航式编程</h3><p>利用vue-router的导航式编程的router.push方法也可以实现上面的需求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在创建vue实例并挂载后调用</span></div><div class="line">router.push(<span class="string">'/goods'</span>)</div></pre></td></tr></table></figure></p>
<p>router.push方法就是用来动态导航到不同的链接的。它会向history栈添加一个新的记录，点击<code>&lt;router-link :to=&quot;...&quot;&gt;</code>等同于调用router.push(…)。</p>
<p>vue-router中还有router.replace方法和router.go方法，概念及用法可参考<a href="https://router.vuejs.org/zh-cn/essentials/navigation.html" target="_blank" rel="external">https://router.vuejs.org/zh-cn/essentials/navigation.html</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看&lt;a href=&quot;h
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="vue-router" scheme="http://yuhan.com/tags/vue-router/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0 Transition常见用法全解惑</title>
    <link href="http://yuhan.com/2016/12/08/vue-transition/"/>
    <id>http://yuhan.com/2016/12/08/vue-transition/</id>
    <published>2016-12-08T00:48:41.000Z</published>
    <updated>2016-12-08T05:43:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue2.0的过渡系统（transition）有了很大的改变，想把1.0的项目迁移到2.0，着实需要费一些功夫，今天我就要把vue2.0的过渡系统的用法搞清楚，因为之前确实踩了不少坑。这里只涉及单元素/组件的过渡实现，<a href="http://cn.vuejs.org/v2/guide/transitions.html#初始渲染的过渡" target="_blank" rel="external">vue2.0的文档</a>中还讲到了初始渲染的过渡、多个元素的过渡、多个组件的过渡和列表过渡，他们的过渡效果实现方式和单元素/组件的类似，我感觉实际项目中用的不太多吧，有兴趣的同学可以去了解一下，文档这里说的多个元素和多个组件<strong>和我们的理解可能不太一样</strong>，一定要仔细阅读文档，搞清楚到底说的是什么样的情况。</p>
<h1 id="什么是过渡"><a href="#什么是过渡" class="headerlink" title="什么是过渡"></a>什么是过渡</h1><p>Vue只有在插入，更新或者移除DOM元素时才会应用过渡效果，过渡效果的应用可以通过不同方式实现，官方文档中提到了如下几种：</p>
<ol>
<li>在CSS过渡和动画中自动应用class；</li>
<li>配合使用第三方的CSS动画库，如Animate.css；</li>
<li>在过渡钩子函数中使用JavaScript直接操作DOM；</li>
<li>配合使用第三方JavaScript动画库，如Velocity；</li>
</ol>
<p>上面四种方式其实主要就是两种，一个是利用CSS过渡或者动画，另一个是利用JavaScript钩子函数。</p>
<h2 id="怎么应用过渡到元素-组件上"><a href="#怎么应用过渡到元素-组件上" class="headerlink" title="怎么应用过渡到元素/组件上"></a>怎么应用过渡到元素/组件上</h2><p>要想使元素或者组件应用到我们所写的过渡动画，需要使用vue提供的transition来封装组件成为过渡组件，transition需要与如下情景中的任一种一起使用：</p>
<ul>
<li>v-if（条件渲染）</li>
<li>v-show（条件展示）</li>
<li>动态组件</li>
<li>在组建的根节点上，并且被vue实例DOM方法触发，如appendTo方法把组件添加到某个根节点上</li>
</ul>
<p>当需要插入或者删除封装成过渡元素的元素时，vue将做如下事情：</p>
<ol>
<li>查找目标元素是否有CSS过渡或者动画，如果有就在适当的时候进行处理；</li>
<li>如果过渡组件设置了JavaScript钩子函数，vue会在相应阶段调用钩子函数；</li>
<li>如果以上两者都没有，DOM操作（插入或者删除）就在下一帧立即执行。</li>
</ol>
<h1 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h1><p>先举一个典型的CSS过渡的例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 首先将要过渡的元素用transition包裹，并设置过渡的name，然后添加触发这个元素过渡的按钮（实际项目中不一定是按钮，任何能触发过渡组件的DOM操作的操作都可以） --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 接着为过渡类名添加规则</div><div class="line">&amp;.fade-enter-active, &amp;.fade-leave-active</div><div class="line">  transition: all 0.5s ease     </div><div class="line">&amp;.fade-enter, &amp;.fade-leave-active</div><div class="line">  opacity: 0</div></pre></td></tr></table></figure>
<p>封装上面的代码，就可以实现一个简单的动画了，CSS的transition属性是用来设置过渡总体效果的，具体可参考：<a href="http://www.w3cplus.com/content/css3-transition" target="_blank" rel="external">http://www.w3cplus.com/content/css3-transition</a>。</p>
<h2 id="CSS过渡类名"><a href="#CSS过渡类名" class="headerlink" title="CSS过渡类名"></a>CSS过渡类名</h2><p>组件过渡过程中，会有四个CSS类名进行切换，这四个类名与上面transition的name属性有关，比如name=”fade”，会有如下四个CSS类名：</p>
<ol>
<li>fade-enter：进入过渡的开始状态，元素被插入时生效，只应用一帧后立即删除；</li>
<li>fade-enter-active：进入过渡的结束状态，元素被插入时就生效，在过渡过程完成之后移除；</li>
<li>fade-leave：离开过渡的开始状态，元素被删除时触发，只应用一帧后立即删除；</li>
<li>fade-leave-active：离开过渡的结束状态，元素被删除时生效，离开过渡完成之后被删除；</li>
</ol>
<p>从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。<br>上面示例中，fade-enter和fade-leave-active类设置CSS为opacity:0，说明过渡刚进入和离开的时候透明度为0，即不显示。当然还可以设置其他的CSS属性，transform属性是除了opacity之外经常在这里被用到的，transform用法可参考<a href="http://www.w3cplus.com/content/css3-transition" target="_blank" rel="external">http://www.w3cplus.com/content/css3-transition</a></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>组件过渡的实现不仅可以通过CSS过渡还可以通过CSS动画(animation)实现，建议先了解一下<a href="http://www.w3cplus.com/content/css3-animation" target="_blank" rel="external">CSS3 Animation</a>，这里还是给个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fold"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.fold-enter-active</span> &#123;</div><div class="line">  <span class="attribute">animation-name</span>: fold-in;</div><div class="line">  <span class="attribute">animation-duration</span>: .<span class="number">5s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.fold-leave-active</span> &#123;</div><div class="line">  <span class="attribute">animation-name</span>: fold-out;</div><div class="line">  <span class="attribute">animation-duration</span>: .<span class="number">5s</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> fold-in &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 100%, 0);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 50%, 0);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> fold-out &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 50%, 0);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 100%, 0);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果预先了解了CSS动画（上面给了链接），上面代码还是很好理解的，要注意的是CSS动画中，fold-enter类名在节点插入DOM后不会立即删除，而是在animationed事件触发时删除。</p>
<h2 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h2><p>上面的四个过渡类名都是根据transition的name属性自动生成的，那么能否自己定义这四个类名呢？答案是可以的，通过enter-class、enter-active-class、leave-class、leave-active-class这四个特性来定义。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> </span></div><div class="line">    <span class="attr">name</span>=<span class="string">"fade"</span></div><div class="line">    <span class="attr">enter-class</span>=<span class="string">"fade-in-enter"</span></div><div class="line">    <span class="attr">enter-active-class</span>=<span class="string">"fade-in-active"</span></div><div class="line">    <span class="attr">leave-class</span>=<span class="string">"fade-out-enter"</span></div><div class="line">    <span class="attr">leave-active-class</span>=<span class="string">"fade-out-active"</span></div><div class="line">  &gt;</div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&amp;.fade-in-active, &amp;.fade-out-active</div><div class="line">  transition: all 0.5s ease     </div><div class="line">&amp;.fade-in-enter, &amp;.fade-out-active</div><div class="line">  opacity: 0</div></pre></td></tr></table></figure>
<p>上面代码中，原来默认的fade-enter类对应fade-in-enter，fade-enter-active类对应fade-in-active，依次类推。</p>
<h1 id="JavaScript钩子函数"><a href="#JavaScript钩子函数" class="headerlink" title="JavaScript钩子函数"></a>JavaScript钩子函数</h1><p>除了用CSS过渡的动画来实现vue的组件过渡，还可以用JavaScript的钩子函数来实现，在钩子函数中直接操作DOM。我们可以在属性中声明以下钩子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span></span></div><div class="line">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></div><div class="line">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></div><div class="line">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></div><div class="line">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></div><div class="line">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></div><div class="line">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></div><div class="line">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></div><div class="line">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></div><div class="line">&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">methods: &#123;</div><div class="line">  <span class="comment">// 过渡进入</span></div><div class="line">  <span class="comment">// 设置过渡进入之前的组件状态</span></div><div class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡进入完成时的组件状态</span></div><div class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    done()</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡进入完成之后的组件状态</span></div><div class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">enterCancelled</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 过渡离开</span></div><div class="line">  <span class="comment">// 设置过渡离开之前的组件状态</span></div><div class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡离开完成时地组件状态</span></div><div class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    done()</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 设置过渡离开完成之后的组件状态</span></div><div class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// leaveCancelled 只用于 v-show 中</span></div><div class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的钩子函数中可以进行任何你想做的DOM操作。<br><strong>小技巧</strong>：如果你只想设置组件过渡进入的效果而不想有组件过渡离开的效果，这时你就可以用钩子函数，只设置beforeEnter、enter、afterEnter这几个钩子函数就可以了。</p>
<p>目前接触到的关于vue transition相关的就这么多了，当然vue transition的用法可不止这么点，这需要我以后的慢慢积累。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue2.0的过渡系统（transition）有了很大的改变，想把1.0的项目迁移到2.0，着实需要费一些功夫，今天我就要把vue2.0的过渡系统的用法搞清楚，因为之前确实踩了不少坑。这里只涉及单元素/组件的过渡实现，&lt;a href=&quot;http://cn.vuejs.org
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="transition" scheme="http://yuhan.com/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之Generator函数</title>
    <link href="http://yuhan.com/2016/12/06/ES6-Generator/"/>
    <id>http://yuhan.com/2016/12/06/ES6-Generator/</id>
    <published>2016-12-06T13:27:34.000Z</published>
    <updated>2016-12-08T00:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前断断续续接触到了一些ES6的知识，异步编程方面听得比较多的就是Promise，直到最近比较系统地学习了ES6的新特性才发现Generator这个神奇的存在，它可以实现一些前所未有的事情，让我顿时对它充满了兴趣。</p>
<h1 id="为什么需要Generator？"><a href="#为什么需要Generator？" class="headerlink" title="为什么需要Generator？"></a>为什么需要Generator？</h1><p>JavaScript异步编程是为解决JavaScript执行环境是“单线程”这个问题的。在JavaScript中，异步编程的使用非常频繁，也经常会出现需要逐步完成多个异步操作的情况。之前用回调函数实现异步编程如果碰到了这种问题就需要嵌套使用回调函数，异步操作越多，嵌套得就越深，这样非常不利于代码的维护，代码阅读起来也很困难。Generator函数是ES6提出的一种异步编程解决方案，它可以避免回调的嵌套，但是它的用处可不仅仅如此哦，待我细细道来。</p>
<h1 id="举个小例子"><a href="#举个小例子" class="headerlink" title="举个小例子"></a>举个小例子</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g1 = gen1();</div><div class="line">g1.next();  <span class="comment">// Object &#123;value: 1, done: false&#125;</span></div><div class="line">g1.next();  <span class="comment">// Object &#123;value: "hello", done: false&#125;</span></div><div class="line">g1.next();  <span class="comment">// Object &#123;value: true, done: true&#125;</span></div><div class="line">g1.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>上面的代码就定义了一个Generator函数，Generator函数的定义跟普通函数差不多，只是在function关键字后面加了一个星号。调用Generator函数后和普通函数不同的是，该函数并不立即执行，也不返回函数执行结果，而是返回一个指向内部状态的generator对象，也可以看作是一个遍历器对象。然后必须调用该对象的next方法，让函数继续走下去，是指针移向下一个状态。每当碰到yield语句,内部指针就停下来，直到下一次调用next()才开始执行。<br>上面代码调用了四次next方法，遍历才结束。next方法会返回一个有两个属性的对象，value属性的值为当前yield语句的值，done属性的值表示遍历是否结束，即最后一次调用next方法时，再也碰不到yield或者return语句了。<br><strong>星号写在哪</strong>：<br>function关键字和函数名之间的星号写在哪都可以，只要在两者之间即可，但是一般都采取我上面代码的那种写法。</p>
<h2 id="Generator函数本质"><a href="#Generator函数本质" class="headerlink" title="Generator函数本质"></a>Generator函数本质</h2><p>上面说了那么多，想必大家已经知道Generator函数是怎么用的了，那么Generator本质上到底是个啥呢？Generator函数的理解有多种：</p>
<ol>
<li>Generator函数可以被理解成一个状态机，里面封装了多种状态，有兴趣的同学可以去了解一下状态机，操作系统的书里都会讲到。</li>
<li>Generator函数还可以被理解成一个遍历器对象生成器，它返回的遍历器对象可以依次遍历Generator函数内部的每一个状态。这就是为什么之前说Generator函数不仅是为了解决回调函数嵌套问题。Generator函数是生成一个对象，但是调用的时候前面<strong>不能加new命令</strong>。</li>
</ol>
<h1 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h1><p>yield语句是Generator函数内部可以暂停执行程序的语句，yield语句后面的值可以是各种数据类型，字符串，整数，布尔值等等都可以。这里主要想说说Generator函数中yield语句和return语句的区别。</p>
<h2 id="和return语句区别"><a href="#和return语句区别" class="headerlink" title="和return语句区别"></a>和return语句区别</h2><p>从上面的例子可以看出，函数不仅是碰到yield语句才会停止执行，碰到return语句也会停止执行。这很容易理解，不管怎样Generator函数也是一个函数，碰到return语句必然会停止执行，返回值。那么，两者的区别是什么呢？先来看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g2 = gen2();</div><div class="line">g2.next();  <span class="comment">// Object &#123;value: true, done: true&#125;</span></div><div class="line">g2.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>从上面例子可以看出，当碰到return语句时，返回对象的done属性值就为true，遍历结束，不管后面是否还有yield或者return语句。这种区别本质上是因为yield语句具备位置记忆功能而return语句则没有该功能。</p>
<h2 id="再说一点"><a href="#再说一点" class="headerlink" title="再说一点"></a>再说一点</h2><p>Generator函数，不管内部有没有yield语句，调用函数时都不会执行任何语句，只有当调用next(),内部语句才会执行，只要调用next()，就会返回一个对象。yield语句只是函数暂停执行的一个标记。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了么？'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g3 = gen3();  <span class="comment">// 没有任何输出</span></div><div class="line">g3.next();</div><div class="line"><span class="comment">// 执行了么？</span></div><div class="line"><span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：yield函数不能在普通函数中使用，否则会报错。</p>
<h1 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h1><p>除了yield语句，next方法也是Generator函数实现中很重要的特性。既然next()是一个函数，那么这个函数可以带参数么，当然可以。上面的例子比较简单，都只是一些单纯的yield语句，其实Generator函数和普通函数一样里面是可以进行各种复杂的计算和操作的，也可以有各种循环语句，不仅next方法可以传参数，Generator函数也是可以传参数的，立马上例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen4</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> (a + <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> b * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g4 = gen4(<span class="number">1</span>);</div><div class="line">g4.next();  <span class="comment">//  Object &#123;value: 2, done: false&#125;</span></div><div class="line">g4.next();  <span class="comment">//  Object &#123;value: NaN, done: true&#125;</span></div><div class="line"><span class="keyword">let</span> g5 = gen4(<span class="number">1</span>);</div><div class="line">g5.next();  <span class="comment">//  Object &#123;value: 2, done: false&#125;</span></div><div class="line">g5.next(<span class="number">3</span>);  <span class="comment">//  Object &#123;value: 6, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面例子中，Generator函数需要接收一个参数a，表面上变量b是用yield语句赋值了，但是遗憾的是这个赋值好像并没有成功，当第二次调用next方法（没有传参数）时，返回的对象value值居然为NaN，而不是我们想的 2 *（1+1）= 4。但是如果第二次调用next方法时，传入一个参数3，返回对象的value值就为6。这可以说明两点：</p>
<ol>
<li>yield语句没有返回值，或者总是返回undefined；</li>
<li>next方法如果带上一个参数，这个参数就是作为上一个yield语句的返回值。</li>
</ol>
<p><strong>注意</strong>：因为next方法表示上一个yield语句的返回值，所以必须有上一个yield语句的存在，那么第一次调用next方法时就不能传参数。第一个next只是用来启动Generator函数内部的遍历器，传参也没有多大意义。</p>
<h1 id="再说Generator函数与普通函数区别"><a href="#再说Generator函数与普通函数区别" class="headerlink" title="再说Generator函数与普通函数区别"></a>再说Generator函数与普通函数区别</h1><h2 id="可以用prototype么？"><a href="#可以用prototype么？" class="headerlink" title="可以用prototype么？"></a>可以用prototype么？</h2><p>虽然Generator函数和普通函数区别很大，但是Generator函数的实例也可以继承Generator函数的prototype对象上的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen5</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">gen5.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'有generator?'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g6 = gen5();</div><div class="line">g6.say();  <span class="comment">// 有generator?</span></div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出，Generator函数返回的g6，继承了gen5.prototype。</p>
<h2 id="this咋用？"><a href="#this咋用？" class="headerlink" title="this咋用？"></a>this咋用？</h2><p>大家都知道普通函数都会有一个this对象，那么Generator的this对象怎么用呢？还是例子更直观：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen6</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> g7 = gen6();</div><div class="line">g7.a;  <span class="comment">//  undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，Generator函数在this对象上添加了一个属性a，g7实例并不能取到这个属性。那么怎么让Generator函数返回一个可以正常使用this对象的实例呢？阮一峰老师提供了一种方法，首先，生成一个空对象，使用call方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。参考代码在这：<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/generator</a></p>
<h1 id="Generator函数与Iterator"><a href="#Generator函数与Iterator" class="headerlink" title="Generator函数与Iterator"></a>Generator函数与Iterator</h1><p>Generator函数返回的是一个遍历器对象，那么它在遍历这方面肯定有用武之地。实际上遍历器最简单的实现就是使用Generator函数。遍历器（Iterator）也是ES6种一个很重要的新特性，参考资料：<a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/iterator</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前断断续续接触到了一些ES6的知识，异步编程方面听得比较多的就是Promise，直到最近比较系统地学习了ES6的新特性才发现Generator这个神奇的存在，它可以实现一些前所未有的事情，让我顿时对它充满了兴趣。&lt;/p&gt;
&lt;h1 id=&quot;为什么需要Generator？&quot;&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://yuhan.com/tags/ES6/"/>
    
      <category term="generator" scheme="http://yuhan.com/tags/generator/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记之Symbol</title>
    <link href="http://yuhan.com/2016/12/05/ES6-symbol/"/>
    <id>http://yuhan.com/2016/12/05/ES6-symbol/</id>
    <published>2016-12-05T09:03:43.000Z</published>
    <updated>2017-03-04T07:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术日新月异，不断有新技术出现，我们就需要不断地学习新知识，虽然ES6已经提出很久了，但是最近我才有时间静下心来好好学习一下里面提出的新规则。今天总结下ES6提出的这个新的原始数据类型–Symbol。</p>
<h1 id="为啥需要Symbol"><a href="#为啥需要Symbol" class="headerlink" title="为啥需要Symbol"></a>为啥需要Symbol</h1><p>一个新规则的提出，必然是因为有需求，熟悉ES5的人都知道，ES5里面对象的属性名都是字符串，如果你需要使用一个别人提供的对象，你对这个对象有哪些属性也不是很清楚，但又想为这个对象新增一些属性，那么你新增的属性名就很可能和原来的属性名发送冲突，显然我们是不希望这种情况发生的。所以，我们需要确保每个属性名都是独一无二的，这样就可以防止属性名的冲突了。因此，ES6里就引入了Symbol，用它来产生一个独一无二的值。</p>
<h1 id="Symbol是什么"><a href="#Symbol是什么" class="headerlink" title="Symbol是什么"></a>Symbol是什么</h1><p>我们已经知道ES6中引入了一个叫Symbol的东西，但是这个东西到底是什么呢？是一个函数还是一个对象或者是其他什么？Symbol实际上是ES6引入的一种原始数据类型，除了Symbol，JavaScript还有其他5种数据类型，分别是Undefined、Null、Boolean、String、Number，这5种数据类型都是ES5中就有的。</p>
<h1 id="怎么生成一个Symbol类型的值"><a href="#怎么生成一个Symbol类型的值" class="headerlink" title="怎么生成一个Symbol类型的值"></a>怎么生成一个Symbol类型的值</h1><p>既然我们已经知道了Symbol是一种原始的数据类型，那么怎么生成这种数据类型的值呢？Symbol值是通过Symbol函数生成的，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// Symbol()</span></div><div class="line"><span class="keyword">typeof</span> s;  <span class="comment">// "symbol"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，s就是一个Symbol类型的值，它是独一无二的。</p>
<h2 id="Symbol函数前不能用new"><a href="#Symbol函数前不能用new" class="headerlink" title="Symbol函数前不能用new"></a>Symbol函数前不能用new</h2><p>Symbol函数不是一个构造函数，前面不能用new操作符。所以Symbol类型的值也不是一个对象，不能添加任何属性，它只是一个类似于字符型的数据类型。如果强行在Symbol函数前加上new操作符，会报错，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Symbol</span>();</div><div class="line"><span class="comment">// Uncaught TypeError: Symbol is not a constructor(…)</span></div></pre></td></tr></table></figure></p>
<h2 id="Symbol函数的参数"><a href="#Symbol函数的参数" class="headerlink" title="Symbol函数的参数"></a>Symbol函数的参数</h2><h3 id="字符串作为参数"><a href="#字符串作为参数" class="headerlink" title="字符串作为参数"></a>字符串作为参数</h3><p>用上面的方法生成的Symbol值不好进行区分，Symbol函数还可以接受一个字符串参数，来对产生的Symbol值进行描述，方便我们区分不同的Symbol值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>);</div><div class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>);</div><div class="line"><span class="built_in">console</span>.log(s1);  <span class="comment">// Symbol(s1)</span></div><div class="line"><span class="built_in">console</span>.log(s2);  <span class="comment">// Symbol(s2)</span></div><div class="line">s1 === s2;  <span class="comment">//  false</span></div><div class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>);</div><div class="line">s2 === s3;  <span class="comment">//  false</span></div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出：</p>
<ol>
<li>给Symbol函数加了参数之后，控制台输出的时候可以区分到底是哪一个值；</li>
<li>Symbol函数的参数只是对当前Symbol值的描述，因此相同参数的Symbol函数返回值是不相等的；</li>
</ol>
<h3 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h3><p>如果Symbol函数的参数是一个对象，就会调用该对象的toString方法，将其转化为一个字符串，然后才生成一个Symbol值。所以，说到底，Symbol函数的参数只能是字符串。</p>
<h3 id="Symbol值可以进行运算么？"><a href="#Symbol值可以进行运算么？" class="headerlink" title="Symbol值可以进行运算么？"></a>Symbol值可以进行运算么？</h3><p>既然Symbol是一种数据类型，那我们一定想知道Symbol值是否能进行运算。告诉你，Symbol值是不能进行运算的,不仅不能和Symbol值进行运算，也不能和其他类型的值进行运算，否则会报错。<br>Symbol值可以显式转化为字符串和布尔值，但是不能转为数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mysym1 = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</div><div class="line">mysym1.toString() <span class="comment">//  'Symbol('my symbol')'</span></div><div class="line"><span class="built_in">String</span>(mysym1)  <span class="comment">//  'Symbol('my symbol')'</span></div><div class="line"><span class="keyword">var</span> mysym2 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">Boolean</span>(mysym2);  <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>(mysym2)  <span class="comment">// TypeError: Cannot convert a Symbol value to a number(…)</span></div></pre></td></tr></table></figure></p>
<h3 id="Symbol如何作为属性名"><a href="#Symbol如何作为属性名" class="headerlink" title="Symbol如何作为属性名"></a>Symbol如何作为属性名</h3><p>Symbol就是为对象的属性名而生，那么Symbol值怎么作为对象的属性名呢？有下面几种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="comment">// 第一种写法</span></div><div class="line">a[s4] = <span class="string">'mySymbol'</span>;</div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line">a = &#123;</div><div class="line">    [s4]: <span class="string">'mySymbol'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 第三种写法</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(a, s4, &#123;<span class="attr">value</span>: <span class="string">'mySymbol'</span>&#125;);</div><div class="line">a.s4;  <span class="comment">//  undefined</span></div><div class="line">a.s4 = <span class="string">'mySymbol'</span>;</div><div class="line">a[s4]  <span class="comment">//  undefined</span></div><div class="line">a[<span class="string">'s4'</span>]  <span class="comment">// 'mySymbol'</span></div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出：</p>
<ol>
<li>使用对象的Symbol值作为属性名时，获取相应的属性值不能用点运算符；</li>
<li>如果用点运算符来给对象的属性赋Symbol类型的值，实际上属性名会变成一个字符串，而不是一个Symbol值；</li>
<li>在对象内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中，否则只是一个字符串。</li>
</ol>
<h2 id="Symbol值作为属性名的遍历"><a href="#Symbol值作为属性名的遍历" class="headerlink" title="Symbol值作为属性名的遍历"></a>Symbol值作为属性名的遍历</h2><p>使用for…in和for…of都无法遍历到Symbol值的属性，Symbol值作为对象的属性名，也无法通过Object.keys()、Object.getOwnPropertyNames()来获取了。但是，不同担心，这种平常的需求肯定是会有解决办法的。我们可以使用Object.getOwnPropertySymbols()方法获取一个对象上的Symbol属性名。也可以使用Reflect.ownKeys()返回所有类型的属性名，包括常规属性名和 Symbol属性名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>(<span class="string">'s5'</span>);</div><div class="line"><span class="keyword">let</span> s6 = <span class="built_in">Symbol</span>(<span class="string">'s6'</span>);</div><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    [s5]: <span class="string">'s5'</span>,</div><div class="line">    [s6]: <span class="string">'s6'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(a);   <span class="comment">// [Symbol(s5), Symbol(s6)]</span></div><div class="line">a.hello = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">Reflect</span>.ownKeys(a);  <span class="comment">//  ["hello", Symbol(s5), Symbol(s6)]</span></div></pre></td></tr></table></figure></p>
<p>利用Symbol值作为对象属性的名称时，不会被常规方法遍历到这一特性，可以为对象定义一些非私有的但是又希望只有内部可用的方法。</p>
<h2 id="Symbol-for-和Symbol-keyFor"><a href="#Symbol-for-和Symbol-keyFor" class="headerlink" title="Symbol.for()和Symbol.keyFor()"></a>Symbol.for()和Symbol.keyFor()</h2><p>Symbol.for()函数也可以用来生成Symbol值，但该函数有一个特殊的用处，就是可以重复使用一个Symbol值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s7 = <span class="built_in">Symbol</span>.for(<span class="string">'s7'</span>);</div><div class="line"><span class="built_in">console</span>.log(s7); <span class="comment">// Symbol(s7)</span></div><div class="line">s7.toString(); <span class="comment">// "Symbol(s7)"</span></div><div class="line"><span class="keyword">let</span> s8 = <span class="built_in">Symbol</span>.for(<span class="string">'s7'</span>);</div><div class="line">s7 === s8 <span class="comment">//  true</span></div><div class="line"><span class="keyword">let</span> s9 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s9); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">Symbol</span>.keyFor(s8); <span class="comment">// "s8"</span></div></pre></td></tr></table></figure></p>
<p><strong>Symbol.for()</strong>函数要接受一个字符串作为参数，先搜索有没有以该参数作为名称的Symbol值，如果有，就直接返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。上面代码中，s7和s8实际上就是同一个Symbol值，所以两者是相等的。<br><strong>Symbol.keyFor()</strong>函数是用来查找一个Symbol值的登记信息的，Symbol()写法没有登记机制，所以返回undefined；而Symbol.for()函数会将生成的Symbol值登记在全局环境中，所以Symbol.keyFor()函数可以查找到用Symbol.for()函数生成的Symbol值。</p>
<h2 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h2><p>ES6提供了11个内置的Symbol值，分别是Symbol.hasInstance 、Symbol.isConcatSpreadable 、Symbol.species 、Symbol.match 、Symbol.replace 、Symbol.search 、Symbol.split 、Symbol.iterator 、Symbol.toPrimitive 、Symbol.toStringTag 、Symbol.unscopables 等。<br>有兴趣的可以自行了解：<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/symbol</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端技术日新月异，不断有新技术出现，我们就需要不断地学习新知识，虽然ES6已经提出很久了，但是最近我才有时间静下心来好好学习一下里面提出的新规则。今天总结下ES6提出的这个新的原始数据类型–Symbol。&lt;/p&gt;
&lt;h1 id=&quot;为啥需要Symbol&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://yuhan.com/tags/ES6/"/>
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="symbol" scheme="http://yuhan.com/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>echarts画图实例讲解</title>
    <link href="http://yuhan.com/2016/11/19/how-to-use-echarts/"/>
    <id>http://yuhan.com/2016/11/19/how-to-use-echarts/</id>
    <published>2016-11-19T11:16:22.000Z</published>
    <updated>2016-12-05T13:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天分享了一个项目(<a href="http://hyuhan.com/2016/11/17/A-data-display-platform/" target="_blank" rel="external">http://hyuhan.com/2016/11/17/A-data-display-platform/</a>)，里面用到了echarts（一个纯Javascript的图表库）来画图，项目中用到了它的字符云图，地图，柱状图，饼图等，今天就给大家分享一些一些实现的细节。建议先去看看<a href="http://echarts.baidu.com/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="external">五分钟上手Echarts</a>再来看这篇博客。</p>
<h1 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h1><p>Echarts百度地图扩展，可以在百度地图上进一步展现点图，线图，热力图等，我主要在百度地图上展现的是气泡图。</p>
<h2 id="引入百度地图"><a href="#引入百度地图" class="headerlink" title="引入百度地图"></a>引入百度地图</h2><ul>
<li>首先引入百度地图的jssdk，需要使用在百度地图开发者平台申请的ak</li>
<li>然后引入Echarts</li>
<li>最后引入百度地图扩展bmap（已经打包在echarts包中）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak=你的ak"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts/dist/echarts.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts/dist/extension/bmap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h2><p>百度地图引入之后，主要就是设置参数了，以我画的最喜爱建筑分布图为例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    <span class="comment">// 设置标题样式</span></div><div class="line">    title: &#123;</div><div class="line">        <span class="comment">// 标题文本</span></div><div class="line">        text: <span class="string">'学生最喜爱学校建筑分布'</span>,</div><div class="line">        <span class="comment">// 标题离容器左侧的距离，center表示水平居中</span></div><div class="line">        left: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">15</span>, </div><div class="line">        <span class="comment">// 标题文本的样式设置</span></div><div class="line">        textStyle: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">24</span>,</div><div class="line">            <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">            <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 提示框设置为由数据项图形触发</span></div><div class="line">    tooltip: &#123;</div><div class="line">        <span class="attr">trigger</span>: <span class="string">'item'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 添加保存为图片和数据视图工具工具栏</span></div><div class="line">    toolbox: &#123;</div><div class="line">        <span class="attr">feature</span>: &#123;</div><div class="line">            <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">            <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: <span class="number">15</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">10</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 加载bmap组件</span></div><div class="line">    bmap: &#123;</div><div class="line">        <span class="comment">// 百度地图中心经纬度（设置为你需要的地图中心即可）</span></div><div class="line">        center: [<span class="number">114.427877</span>, <span class="number">30.517249</span>],</div><div class="line">        <span class="comment">// 百度地图缩放比例（按需配置）</span></div><div class="line">        zoom: <span class="number">15</span>,</div><div class="line">        <span class="comment">// 是否开启拖拽缩放</span></div><div class="line">        roam: <span class="literal">true</span>,</div><div class="line">        <span class="comment">// 设置百度地图样式（可参考http://developer.baidu.com/map/jsdevelop-11.htm）</span></div><div class="line">        mapStyle: &#123;</div><div class="line">            <span class="attr">style</span>: <span class="string">'light'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">series</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'最喜爱建筑'</span>,</div><div class="line">            <span class="comment">// 图标类型设置为气泡图</span></div><div class="line">            type: <span class="string">'scatter'</span>,</div><div class="line">            <span class="comment">// 设置坐标系为前面提到的bmap</span></div><div class="line">            coordinateSystem: <span class="string">'bmap'</span>,</div><div class="line">            <span class="comment">// 数据</span></div><div class="line">            data: [&#123;&#125;],</div><div class="line">            <span class="comment">// 气泡标记大小</span></div><div class="line">            symbolSize: ,</div><div class="line">            <span class="attr">label</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                    <span class="attr">formatter</span>: <span class="string">'&#123;b&#125;'</span>,</div><div class="line">                    <span class="attr">position</span>: <span class="string">'right'</span>,</div><div class="line">                    <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                    <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">itemStyle</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                    <span class="attr">color</span>: <span class="string">'rgba(11, 110, 72, 1)'</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    ]    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外给大家推荐一个百度的<a href="http://api.map.baidu.com/lbsapi/getpoint/index.html" target="_blank" rel="external">拾取坐标系统</a>，挺好用的。</p>
<h1 id="字符云图"><a href="#字符云图" class="headerlink" title="字符云图"></a>字符云图</h1><p>之前一直觉得字符云是个很酷炫的东西，所以这次也就强行把它用上了，嘿嘿。里面的数据是我根据群聊记录分析出来的高频词汇。Echarts的字符云是基于<a href="https://github.com/timdream/wordcloud2.js" target="_blank" rel="external">wordcloud2.js</a>的。  </p>
<h2 id="引入字符云"><a href="#引入字符云" class="headerlink" title="引入字符云"></a>引入字符云</h2><h3 id="直接下载js文件并引入"><a href="#直接下载js文件并引入" class="headerlink" title="直接下载js文件并引入"></a>直接下载js文件并引入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts-wordcloud.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="webpack引入"><a href="#webpack引入" class="headerlink" title="webpack引入"></a>webpack引入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install echarts-wordcloud</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import echarts from &apos;echarts&apos;</div><div class="line">import &apos;echarts-wordcloud&apos;</div></pre></td></tr></table></figure>
<h2 id="设置参数-1"><a href="#设置参数-1" class="headerlink" title="设置参数"></a>设置参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    <span class="attr">title</span>: &#123;</div><div class="line">        <span class="attr">text</span>: title,</div><div class="line">        <span class="attr">textStyle</span>: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">26</span>,</div><div class="line">            <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">            <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">20</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toolbox</span>: &#123;</div><div class="line">        <span class="attr">feature</span>: &#123;</div><div class="line">            <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">            <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: <span class="number">20</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">20</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">series</span>: [&#123;</div><div class="line">        <span class="comment">// 设置图表类型为'wordCloud'</span></div><div class="line">        type: <span class="string">'wordCloud'</span>,</div><div class="line">        <span class="comment">// 设置cloud的形状</span></div><div class="line">        shape: <span class="string">'cardioid'</span>,</div><div class="line">        <span class="comment">// shape: 'pentagon',</span></div><div class="line">        <span class="comment">// shape: 'circle',</span></div><div class="line">        left: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">30</span>,</div><div class="line">        <span class="attr">width</span>: <span class="string">'75%'</span>,</div><div class="line">        <span class="attr">height</span>: <span class="string">'80%'</span>,</div><div class="line">        <span class="comment">// 设置字符字体大小的范围</span></div><div class="line">        sizeRange: [<span class="number">12</span>, <span class="number">75</span>],</div><div class="line">        <span class="comment">// 设置字符旋转的角度范围</span></div><div class="line">        rotationRange: [<span class="number">-90</span>, <span class="number">90</span>],</div><div class="line">        <span class="attr">rotationStep</span>: <span class="number">45</span>,</div><div class="line">        <span class="comment">// 字符间距</span></div><div class="line">        gridSize: <span class="number">8</span>,</div><div class="line">        <span class="comment">// 字符字体样式</span></div><div class="line">        textStyle: &#123;</div><div class="line">            <span class="attr">normal</span>: &#123;</div><div class="line">                <span class="attr">fontFamily</span>: <span class="string">'Microsoft Yahei'</span>,</div><div class="line">                <span class="attr">fontWeight</span>: <span class="string">'bold'</span>,</div><div class="line">                <span class="comment">// 字符字体颜色用一个函数随机设置</span></div><div class="line">                color: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">'rgb('</span> + [</div><div class="line">                        <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">160</span>),</div><div class="line">                        <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">160</span>),</div><div class="line">                        <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">160</span>)</div><div class="line">                    ].join(<span class="string">','</span>) + <span class="string">')'</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">emphasis</span>: &#123;</div><div class="line">                <span class="attr">shadowBlur</span>: <span class="number">10</span>,</div><div class="line">                <span class="attr">shadowColor</span>: <span class="string">'#333'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// data必选包含name和value选项,name即为显示的字符，value越大字符字体大小越大</span></div><div class="line">        data: [&#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">''</span>,</div><div class="line">            <span class="attr">value</span>: ,   </div><div class="line">            <span class="attr">textStyle</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;&#125;,</div><div class="line">                <span class="attr">emphasis</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,&#123;...&#125;,...]</div><div class="line">    &#125;]   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="画热力图"><a href="#画热力图" class="headerlink" title="画热力图"></a>画热力图</h1><p>根据班级群聊数据分析出来的同学之间亲密度，思前想后最后决定用热力图。热力图不需要额外的插件，直接讲参数设置。</p>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    <span class="attr">title</span>: &#123;</div><div class="line">        <span class="attr">text</span>: <span class="string">'通信1502班同学关系密切度分析图（仅通过群聊数据分析）'</span>,</div><div class="line">        <span class="comment">// 子标题</span></div><div class="line">        subtext: <span class="string">'数值越大两者越亲密'</span>,</div><div class="line">        <span class="attr">subtextStyle</span>: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">16</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">top</span>: <span class="number">4</span>,</div><div class="line">        <span class="attr">textStyle</span>: &#123;</div><div class="line">            <span class="attr">fontSize</span>: <span class="number">22</span>,</div><div class="line">            <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">            <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">tooltip</span>: &#123;</div><div class="line">        <span class="attr">trigger</span>: <span class="string">'item'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toolbox</span>: &#123;</div><div class="line">        <span class="attr">feature</span>: &#123;</div><div class="line">            <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">            <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: <span class="number">15</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">grid</span>: &#123;</div><div class="line">        <span class="attr">height</span>: <span class="string">'78%'</span>,</div><div class="line">        <span class="attr">bottom</span>: <span class="string">'14%'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// x轴设置</span></div><div class="line">    xAxis: &#123;</div><div class="line">        <span class="comment">// 坐标轴为类目轴</span></div><div class="line">        type: <span class="string">'category'</span>,</div><div class="line">        <span class="comment">// 数组，x轴显示的刻度标签</span></div><div class="line">        data: [...],</div><div class="line">        <span class="comment">// 刻度标签相关设置</span></div><div class="line">        axisLabel: &#123;</div><div class="line">            <span class="comment">// 如果水平放不下，可以旋转</span></div><div class="line">            rotate: <span class="number">60</span>,</div><div class="line">            <span class="comment">// 刻度标签显示间隔</span></div><div class="line">            interval: <span class="number">0</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">splitArea</span>: &#123;</div><div class="line">            <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">yAxis</span>: &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">'category'</span>,</div><div class="line">        <span class="attr">data</span>: [...],</div><div class="line">        <span class="attr">splitArea</span>: &#123;</div><div class="line">            <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">        &#125;  </div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 视觉映射组件，也就是项目展示中热力图最小面现实的那个组件</span></div><div class="line">    visualMap: &#123;</div><div class="line">        <span class="comment">// 组件允许的最小值和最大值</span></div><div class="line">        min: <span class="number">0</span>,</div><div class="line">        <span class="attr">max</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">calculable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="comment">// 组件高度</span></div><div class="line">        itemheight: <span class="number">300</span>,</div><div class="line">        <span class="comment">// 组件水平放置</span></div><div class="line">        orient: <span class="string">'horizontal'</span>,</div><div class="line">        <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">bottom</span>: <span class="string">'3%'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">series</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'亲密度'</span>,</div><div class="line">            <span class="comment">// 图标类型为heatmap</span></div><div class="line">            type: <span class="string">'heatmap'</span>,</div><div class="line">            <span class="comment">// 二维数组，每个数据项都是一个一维的数组，前两个值表示直角坐标系上的x,y，第三个至表示大小。</span></div><div class="line">            data: [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>],[]...],</div><div class="line">            <span class="attr">label</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                  <span class="attr">show</span>: <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">itemStyle</span>: &#123;</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                    <span class="attr">shadowBlur</span>: <span class="number">10</span>,</div><div class="line">                    <span class="attr">shadowColor</span>: <span class="string">'rgba(0, 0, 0, 0.5)'</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饼图和条形图比较基础，可以参考<a href="http://echarts.baidu.com/examples.html" target="_blank" rel="external">官方实例</a>,建议仔细阅读官方<a href="http://echarts.baidu.com/option.html" target="_blank" rel="external">配置文档</a>，可以自己画出各种有趣的图形来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天分享了一个项目(&lt;a href=&quot;http://hyuhan.com/2016/11/17/A-data-display-platform/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hyuhan.com/2016/11/17/A-
    
    </summary>
    
      <category term="echarts" scheme="http://yuhan.com/categories/echarts/"/>
    
    
      <category term="echarts" scheme="http://yuhan.com/tags/echarts/"/>
    
      <category term="可视化" scheme="http://yuhan.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基于vue、vuex、vue-router、echarts搭建的数据展示平台</title>
    <link href="http://yuhan.com/2016/11/17/A-data-display-platform/"/>
    <id>http://yuhan.com/2016/11/17/A-data-display-platform/</id>
    <published>2016-11-17T01:14:05.000Z</published>
    <updated>2016-12-05T13:10:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的好久没有更新博客了，但是我最近并没有偷懒哦，一直在学习vue这个框架，并且用它做了一个小项目，现在就给大家分享一下我的这个还比较有意思的小项目，项目是基于vue2.0开发的。</p>
<h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>这是一个数据可视化相关的项目，作为一个学生班主任，需要对班上同学的各方面的情况都有所了解，于是我便做了一个问卷调查来了解学生各方面的情况。然后我又想到可以分析我们班的群聊记录呀，根据群聊记录可以得到班上同学之间的亲密度和班级群聊活跃度等信息。自然而然，我就想着可以搭建一个平台来展示这些数据，既然是数据当然是以图表的方式来展示更加直观，然后折中选择了echarts这个图表库。至于为什么要选择用vue这个插件，之前只是觉得学习了vue刚好可以练练手，做完之后发现vue真的很轻量也很好上手，结合vuex和vue-router基本能完成我项目中的所有需求。      </p>
<blockquote>
<p>在线展示：<a href="http://119.29.57.165:8080/family" target="_blank" rel="external">http://119.29.57.165:8080/family</a>  （请用电脑打开，还没适配移动端）<br>源码：<a href="https://github.com/hieeyh/tong2-family" target="_blank" rel="external">https://github.com/hieeyh/tong2-family</a><br><strong>本教程是基于你已经有一定vue基础之上的，如果你还不了解什么是vue建议先去学习一下</strong></p>
</blockquote>
<h2 id="项目初始构建"><a href="#项目初始构建" class="headerlink" title="项目初始构建"></a>项目初始构建</h2><p>首先全局安装vue-cli，vue-cli是vue自己的项目构建工具，几个简单的步骤就可以帮助你快速构建一个vue项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g vue-cli</div></pre></td></tr></table></figure></p>
<p>然后，利用vue-cli构建一个vue项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 创建一个基于 &quot;webpack&quot; 模板的新项目</div><div class="line">$ vue init webpack family</div><div class="line"># 安装项目依赖</div><div class="line">$ cd family</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<h3 id="项目文件解释"><a href="#项目文件解释" class="headerlink" title="项目文件解释"></a>项目文件解释</h3><ul>
<li>build中是webpack基本配置文件，开发环境配置文件，生产环节配置文件</li>
<li>node_modules是各种依赖模块</li>
<li>src中是vue组件及入口文件</li>
<li>static中放置静态文件（群聊分析之后得到的json数据就放在这里）</li>
<li>index.html是页面入口文件</li>
</ul>
<h2 id="基本页面实现"><a href="#基本页面实现" class="headerlink" title="基本页面实现"></a>基本页面实现</h2><p>项目创建好之后，就开始实现自己想要的页面了，修改src文件夹下的App.vue文件，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 导航栏 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-head</span>&gt;</span><span class="tag">&lt;/<span class="name">my-head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-nav</span>&gt;</span><span class="tag">&lt;/<span class="name">my-nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-foot</span>&gt;</span><span class="tag">&lt;/<span class="name">my-foot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">import myHead from './components/header'</div><div class="line">import myNav from './components/nav'</div><div class="line">import myFoot from './components/foot'</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  name: 'app',</div><div class="line">  components: &#123;</div><div class="line">    myHead,</div><div class="line">    myNav,</div><div class="line">    myFoot</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>myHead组件是页面头部，myNav组件是页面左侧导航栏，myFoot是页面底部，router-view组件是vue-router中渲染路径匹配到的视图组件。每个组件的具体实现可以去github项目地址去看源码。</p>
<h2 id="创建配置路由"><a href="#创建配置路由" class="headerlink" title="创建配置路由"></a>创建配置路由</h2><p>显然，我要做的是一个单页面应用，要用到vue-router，先安装vue-router，输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save vue-router</div></pre></td></tr></table></figure></p>
<p>然后，在src文件夹下面的main.js文件中添加路由相关的代码，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"></div><div class="line">Vue.use(VueRouter) </div><div class="line"><span class="comment">// 定义路由组件</span></div><div class="line"><span class="keyword">const</span> Worldcloud = <span class="built_in">require</span>(<span class="string">'./components/cloud.vue'</span>)</div><div class="line"><span class="keyword">const</span> Building = <span class="built_in">require</span>(<span class="string">'./components/building.vue'</span>)</div><div class="line"><span class="keyword">const</span> Canteen = <span class="built_in">require</span>(<span class="string">'./components/canteen.vue'</span>)</div><div class="line"><span class="keyword">const</span> Selfstudy = <span class="built_in">require</span>(<span class="string">'./components/selfstudy.vue'</span>)</div><div class="line"><span class="keyword">const</span> Difficult = <span class="built_in">require</span>(<span class="string">'./components/difficult.vue'</span>)</div><div class="line"><span class="keyword">const</span> Interest = <span class="built_in">require</span>(<span class="string">'./components/interest.vue'</span>)</div><div class="line"><span class="keyword">const</span> Bedroom = <span class="built_in">require</span>(<span class="string">'./components/bedroom.vue'</span>)</div><div class="line"><span class="keyword">const</span> Graduate = <span class="built_in">require</span>(<span class="string">'./components/graduate.vue'</span>)</div><div class="line"><span class="keyword">const</span> Getup = <span class="built_in">require</span>(<span class="string">'./components/getup.vue'</span>)</div><div class="line"><span class="keyword">const</span> Gotobed = <span class="built_in">require</span>(<span class="string">'./components/gotobed.vue'</span>)</div><div class="line"><span class="keyword">const</span> Eat = <span class="built_in">require</span>(<span class="string">'./components/eat.vue'</span>)</div><div class="line"><span class="keyword">const</span> Amuse = <span class="built_in">require</span>(<span class="string">'./components/amuse.vue'</span>)</div><div class="line"><span class="keyword">const</span> Single = <span class="built_in">require</span>(<span class="string">'./components/single.vue'</span>)</div><div class="line"><span class="keyword">const</span> Chat = <span class="built_in">require</span>(<span class="string">'./components/chat.vue'</span>)</div><div class="line"><span class="keyword">const</span> Onlyme = <span class="built_in">require</span>(<span class="string">'./components/onlyme.vue'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 定义路由，配置路由映射</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/wordcloud'</span> &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/wordcloud'</span>, <span class="attr">component</span>: Worldcloud &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/building'</span>, <span class="attr">component</span>: Building &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/canteen'</span>, <span class="attr">component</span>: Canteen &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/selfstudy'</span>, <span class="attr">component</span>: Selfstudy &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/difficult'</span>, <span class="attr">component</span>: Difficult &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/interest'</span>, <span class="attr">component</span>: Interest &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/bedroom'</span>, <span class="attr">component</span>: Bedroom &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/graduate'</span>, <span class="attr">component</span>: Graduate &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/getup'</span>, <span class="attr">component</span>: Getup &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/gotobed'</span>, <span class="attr">component</span>: Gotobed &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/eat'</span>, <span class="attr">component</span>: Eat &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/amuse'</span>, <span class="attr">component</span>: Amuse &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/single'</span>, <span class="attr">component</span>: Single &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/chat'</span>, <span class="attr">component</span>: Chat &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/onlyme'</span>, <span class="attr">component</span>: Onlyme &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; App &#125;,</div><div class="line">  router</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>从路由映射的配置中可以看出，访问网站的根路由会直接跳转到/wordcloud。路由映射的组件中用到了百度的<a href="http://echarts.baidu.com/" target="_blank" rel="external">echarts</a>库来画图，这是一个很好用的图表库。</p>
<h2 id="怎么画图"><a href="#怎么画图" class="headerlink" title="怎么画图"></a>怎么画图</h2><p>怎么用echarts画图呢？其实官网上有很多实例，下面以bedroom.vue组件为例来简单说明，bedroom.vue代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main_content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bedroom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    data() &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">chart</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">opinion</span>: [<span class="string">'学习氛围差'</span>, <span class="string">'学习氛围一般'</span>, <span class="string">'学习氛围很好'</span>],</div><div class="line">        <span class="attr">opinionData</span>: [</div><div class="line">          &#123;<span class="attr">value</span>:<span class="number">26</span>, <span class="attr">name</span>:<span class="string">'学习氛围差'</span>&#125;,</div><div class="line">          &#123;<span class="attr">value</span>:<span class="number">31</span>, <span class="attr">name</span>:<span class="string">'学习氛围一般'</span>&#125;,</div><div class="line">          &#123;<span class="attr">value</span>:<span class="number">8</span>, <span class="attr">name</span>:<span class="string">'学习氛围很好'</span>&#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">      drawPie (id) &#123;</div><div class="line">        <span class="keyword">this</span>.chart = echarts.init(<span class="built_in">document</span>.getElementById(id))</div><div class="line">        <span class="keyword">this</span>.chart.setOption(&#123;</div><div class="line">          <span class="attr">title</span>: &#123;</div><div class="line">            <span class="attr">text</span>: <span class="string">'寝室学习氛围情况调查'</span>,</div><div class="line">            <span class="attr">left</span>: <span class="string">'center'</span>,</div><div class="line">            <span class="attr">top</span>: <span class="number">10</span>,</div><div class="line">            <span class="attr">textStyle</span>: &#123;</div><div class="line">              <span class="attr">fontSize</span>: <span class="number">24</span>,</div><div class="line">              <span class="attr">fontFamily</span>: <span class="string">'Helvetica'</span>,</div><div class="line">              <span class="attr">fontWeight</span>: <span class="number">400</span></div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">tooltip</span>: &#123;</div><div class="line">            <span class="attr">trigger</span>: <span class="string">'item'</span>,</div><div class="line">            <span class="attr">formatte</span>: <span class="string">"&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)"</span></div><div class="line">          &#125;,</div><div class="line">          <span class="attr">toolbox</span>: &#123;</div><div class="line">            <span class="attr">feature</span>: &#123;</div><div class="line">              <span class="attr">saveAsImage</span>: &#123;&#125;,</div><div class="line">              <span class="attr">dataView</span>: &#123;&#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">right</span>: <span class="number">15</span>,</div><div class="line">            <span class="attr">top</span>: <span class="number">10</span></div><div class="line">          &#125;,</div><div class="line">          <span class="attr">legend</span>: &#123;</div><div class="line">              <span class="attr">orient</span>: <span class="string">'vertical'</span>,</div><div class="line">              <span class="attr">left</span>: <span class="number">5</span>,</div><div class="line">              <span class="attr">top</span>: <span class="number">10</span>,</div><div class="line">              <span class="attr">data</span>: <span class="keyword">this</span>.opinion,</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">series</span>: [</div><div class="line">            &#123;</div><div class="line">              <span class="attr">name</span>: <span class="string">'寝室学习氛围'</span>,</div><div class="line">              <span class="attr">type</span>: <span class="string">'pie'</span>,</div><div class="line">              <span class="attr">radius</span>: [<span class="string">'50%'</span>, <span class="string">'70%'</span>],</div><div class="line">              <span class="attr">center</span>: [<span class="string">'50%'</span>, <span class="string">'60%'</span>],</div><div class="line">              <span class="attr">avoidLabelOverlap</span>: <span class="literal">false</span>,</div><div class="line">              <span class="attr">label</span>: &#123;</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                  <span class="attr">show</span>: <span class="literal">true</span>,</div><div class="line">                  <span class="attr">textStyle</span>: &#123;</div><div class="line">                    <span class="attr">fontSize</span>: <span class="string">'24'</span>,</div><div class="line">                    <span class="attr">fontWeight</span>: <span class="string">'bold'</span></div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">labelLine</span>: &#123;</div><div class="line">                <span class="attr">normal</span>: &#123;</div><div class="line">                  <span class="attr">show</span>: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">data</span>: <span class="keyword">this</span>.opinionData,</div><div class="line">              <span class="attr">itemStyle</span>: &#123;</div><div class="line">                <span class="attr">emphasis</span>: &#123;</div><div class="line">                  <span class="attr">shadowBlur</span>: <span class="number">10</span>,</div><div class="line">                  <span class="attr">shadowOffset</span>: <span class="number">0</span>,</div><div class="line">                  <span class="attr">shadowColor</span>: <span class="string">'rgba(0, 0, 0, 0.5)'</span></div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted() &#123;</div><div class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.drawPie(<span class="string">'bedroom'</span>)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line">#bedroom &#123;</div><div class="line">  position: relative;</div><div class="line">  left: 50%;</div><div class="line">  margin-left: -400px;</div><div class="line">  margin-bottom: 70px;</div><div class="line">  width: 800px;</div><div class="line">  height: 600px;</div><div class="line">  border: solid #D01257 1px;</div><div class="line">  box-shadow: 0 0 8px #FB90B7;</div><div class="line">  border-radius: 10px;</div><div class="line">&#125;   </div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这是一个vue的单文件组件，script中，首先导入echarts库，前提是已经安装了echarts库，输入以下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save echarts</div></pre></td></tr></table></figure></p>
<p>data对象中是画图要用到的一些数据，drawpie方法用来画图，接收一个DOM对象，然后在mounted构子函数中调用drawpie即可。</p>
<h4 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h4><ol>
<li>drawpie方法接收的DOM对象需要有确定的宽高，否则图像不显示</li>
<li>mounted中要包含vm.$nextTick才能保证该实例已经插入文档</li>
<li>想要进一步了解echarts画图相关的可以看看我的另一篇博客<a href="http://hyuhan.com/2016/11/19/how-to-use-echarts/" target="_blank" rel="external">echarts画图实例讲解</a></li>
</ol>
<h2 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h2><p>登录功能基于vuex（vue状态管理）和浏览器的sessionStorage实现的。首先在src文件夹下新建store文件夹，存放vuex的store（仓库）,新建三个文件store.js、login.js、user.js。login.js中存储登录状态，user.js中存储用户登录信息，store.js加载login和user模块。</p>
<p><strong>注意</strong>：在store.js中要引入babel-polyfill（先安装），否则会报错，报错原因是Babel默认只转换新的JavaScript句法，而不转换新的API，比如Iterator、Generator、Set、Maps、Promise等全局对象，以及一些定义在全局对象上的方法。所以必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<p>然后修改main.js文件，引入store：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/store'</span></div><div class="line">...</div><div class="line">...</div><div class="line">new Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; App &#125;,</div><div class="line">  router,</div><div class="line">  store</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>修改App.vue文件，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 导航栏 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-head</span>&gt;</span><span class="tag">&lt;/<span class="name">my-head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-nav</span>&gt;</span><span class="tag">&lt;/<span class="name">my-nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-mask</span> <span class="attr">v-if</span>=<span class="string">"canlogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-mask</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-login</span> <span class="attr">v-if</span>=<span class="string">"canlogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-login</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-foot</span>&gt;</span><span class="tag">&lt;/<span class="name">my-foot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">...</div><div class="line">import myMask <span class="keyword">from</span> <span class="string">'./components/mask'</span></div><div class="line"><span class="keyword">import</span> myLogin <span class="keyword">from</span> <span class="string">'./components/login'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  ...</div><div class="line">  data() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">canlogin</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    canlogin() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.login.islogin</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>到此，就基本上大功告成了，在命令行中输入 npm run dev预览一下。</p>
<h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><p>项目可以在本地预览了，但是要怎么发布到网上呢？首先，在命令行中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure></p>
<p>会生成一个dist文件夹，该文件夹中就是我们可以用来发布的代码，直接将代码上传到你的服务器上就可以啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的好久没有更新博客了，但是我最近并没有偷懒哦，一直在学习vue这个框架，并且用它做了一个小项目，现在就给大家分享一下我的这个还比较有意思的小项目，项目是基于vue2.0开发的。&lt;/p&gt;
&lt;h2 id=&quot;灵感来源&quot;&gt;&lt;a href=&quot;#灵感来源&quot; class=&quot;header
    
    </summary>
    
      <category term="vue" scheme="http://yuhan.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="vuex" scheme="http://yuhan.com/tags/vuex/"/>
    
      <category term="vue-router" scheme="http://yuhan.com/tags/vue-router/"/>
    
      <category term="echarts" scheme="http://yuhan.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>webpack+vue项目中常用ES6语法小结</title>
    <link href="http://yuhan.com/2016/10/25/some-ES6-grammer-I-used-in-my-project/"/>
    <id>http://yuhan.com/2016/10/25/some-ES6-grammer-I-used-in-my-project/</id>
    <published>2016-10-25T09:24:57.000Z</published>
    <updated>2016-10-25T12:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客啦，最近入了阴阳师的坑，纯种非洲人，都没心情写博客了。这段时间在接触vue这个框架，用vue+webpack做一些小项目的时候经常会用到ES6的语法，用起来确实比较方便，今天就总结下在vue+webpack项目中经常会用到的一些ES6语法吧。首先来谈谈什么是ES6。</p>
<h2 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h2><p>首先要说说ECMAScript是什么，ECMAScript是JavaScript的规格，而JavaScript是ECMAScript的一种实现，ECMAScript的实现还有Jscript和ActionScript等。ES6（ECMAScript6）一般指ECMAScript2015标准，它是JavaScript语言的下一代标准。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>ES6标准虽然已经发布了，但是很多浏览器环境都还不支持，webpack是通过Babel这个转码器将ES6代码转为ES5，从而在现有环境执行。babel是在webpack的配置文件webpack.config.js的module参数中的loaders中配置，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	...</div><div class="line">	module: &#123;</div><div class="line">		<span class="attr">loaders</span>: [</div><div class="line">		&#123;</div><div class="line">			<span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">			<span class="attr">loader</span>: <span class="string">'babel'</span>,</div><div class="line">			<span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">		&#125;,</div><div class="line">		...</div><div class="line">		]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置完成后还需要安装”babel-loader”模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>然后webpack就可以对用了ES6语法的js文件进行转码了。下面总结一些常用到的ES6语法。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>ES6中let命令用来声明变量，用法类似于var，但是let所声明的变量是局部变量，只在let命令所在的代码块内有效。所以在for循环中很适合用let变量做计数器。<br>let变量不会像var变量那样会进行变量提升，变量一定要在声明后使用，否则会报错。<br>只要块级作用域内存在let命令，它所声明的所有变量都绑定这个作业域，不收外部变量的影响，即形成了一个封闭的作用域。<br>let不允许在相同作用域内重复声明同一个变量。可以看出，let变量实际上为JavaScript新增了块级作用域</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>const声明一个只读的常量，一旦声明，值就不能改变。所以，const一旦声明就必须立即初始化，不能只声明不初始化。<br>const作用域和let命令相同，只在声明所在的块级作用域中有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>在ES6之前不能直接为函数的参数指定默认值，只能采用变通的方法。ES6允许为函数参数设置默认值，直接写在参数定义的后面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y=<span class="string">'World'</span></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></div><div class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></div></pre></td></tr></table></figure></p>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常定义了默认值的参数应该是函数的尾参数，如果是非尾部的参数设置默认值，实际上这个参数是没法省略的。除非显式输入undefined。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6允许使用“箭头”（=&gt;）定义函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</div></pre></td></tr></table></figure></p>
<p>上述箭头定义的函数等同于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> v;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>若箭头函数不需要参数或者需要多于一个参数，就使用一个圆括号代表参数部分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若箭头函数的代码部分多于一条语句，就要使用大括号将他们括起来，并且使用return语句返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</div></pre></td></tr></table></figure></p>
<p><strong>使用注意点</strong></p>
<ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可当做构造函数，不可以使用new命令，否则会抛出错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在，可以用Rest参数代替。</li>
</ol>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>ES6之前，JavaScript一直没有模块（module）体系，ES6在语言规格的层面上，实现了模块功能，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。<br>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时采用静态命令的形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;stat, exists, readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码就是从fs模块加载3个方法，其他方法不加载。这种加载成为“编译时加载”。ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。</p>
<h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>模块功能主要由两个命令构成，export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</div></pre></td></tr></table></figure></p>
<p>还可以如下书写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure></p>
<p>export除了输出变量通用可以输出函数或者类，export输出的变量还可以用as关键字重命名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  v1 <span class="keyword">as</span> streamV1,</div><div class="line">  v2 <span class="keyword">as</span> streamV2,</div><div class="line">  v2 <span class="keyword">as</span> streamLatestVersion</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。用法上面已经有介绍，如果想为输入的变量重命名，使用as关键字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div></pre></td></tr></table></figure></p>
<h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><p>从前面的例子可以看出，使用import命令的时候，需要知道所要加载的变量名或函数名，否则无法加载。export default命令，为模块指定默认输出，其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<p>我在项目中目前用到的ES6语法就这些了，以后有机会再进一步学习ES6的新语法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有更新博客啦，最近入了阴阳师的坑，纯种非洲人，都没心情写博客了。这段时间在接触vue这个框架，用vue+webpack做一些小项目的时候经常会用到ES6的语法，用起来确实比较方便，今天就总结下在vue+webpack项目中经常会用到的一些ES6语法吧。首先来谈谈什么是
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="vue" scheme="http://yuhan.com/tags/vue/"/>
    
      <category term="ES6" scheme="http://yuhan.com/tags/ES6/"/>
    
      <category term="webpack" scheme="http://yuhan.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化小结</title>
    <link href="http://yuhan.com/2016/09/13/about-module/"/>
    <id>http://yuhan.com/2016/09/13/about-module/</id>
    <published>2016-09-13T06:10:03.000Z</published>
    <updated>2016-11-17T06:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着我们的项目越来越复杂，参与项目的人员越来越多，将项目划分模块就变得十分重要，开发者只需要实现自己负责的功能，其他部分可以加载别人已经写好的模块。但是JavaScript不是一种模块化的编程语言，所以JavaScript开发人员做了很多努力，在现有的运行环境中实现了模块化的功能。</p>
<p>前端的模块化开发主要解决两个问题：命名冲突和文件依赖。在前端领域探究模块化开发的过程中，产生了不同的js模块规范，目前通用的JavaScript模块规范主要是：<strong>CommonJS</strong>和<strong>AMD</strong>，先从CommonJS说起。</p>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>CommonJS是服务器端的模块的规范，NodeJS将其发扬光大，标志着JavaScript模块化编程正式登上舞台。</p>
<ol>
<li>定义模块：CommonJS规范规定一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在该模块内部的变量无法被其它模块读取，除非定义为global对象的属性。</li>
<li>模块输出：想要输出模块中的变量使用module.exports对象，该对象是模块外部与内部通信的桥梁。</li>
<li>加载模块：使用require方法加载模块，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。</li>
</ol>
<p>下面举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义模块 module.js</span></div><div class="line"><span class="keyword">var</span> age = <span class="number">23</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(age);</div><div class="line">&#125;</div><div class="line"><span class="comment">//模块输出</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">printAge</span>: printAge</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加载模块</span></div><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule.printAge();</div></pre></td></tr></table></figure>
<p>加载模块时，一般可以省略js扩展名，可以使用相对路径也可以使用绝对路径。</p>
<p>然而CommonJS模块加载是同步的，这在服务器端很容易实现，但是在浏览器端实现起来会出现很多问题。</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>AMD(Asynchronous Module Definition)翻译成中文是异步模块定义，它是一个在浏览器端模块化开发的规范。由于不是JavaScript原生支持的，使用AMD规范进行页面开发需要用对应的库，RequireJS就是其中最出名的一个，实际上，AMD是RequireJS在推广过程中对模块定义的规范化的产出。</p>
<p>RequireJS主要解决了两个问题：</p>
<ol>
<li>实现js文件的异步加载，避免网页失去响应。</li>
<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
</ol>
<h2 id="define函数"><a href="#define函数" class="headerlink" title="define函数"></a>define函数</h2><p>RequireJS定义了一个define函数，它是一个全局变量，用来定义模块，描述如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(id?, dependencies?, factory);</div></pre></td></tr></table></figure></p>
<ol>
<li>id：可选参数，定义中模块的名字，若没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。</li>
<li>dependencies：一个当前模块依赖的，已被模块定义的模块标识的数组字面量。该参数可选，若忽略该参数，它默认为[“require”, “exports”, “module”]。</li>
<li>factory：模块初始化要执行的函数或对象。若为函数，它应该只被执行一次。若为对象，该对象应该为模块的输出值。</li>
</ol>
<h2 id="require函数"><a href="#require函数" class="headerlink" title="require函数"></a>require函数</h2><p>RequireJS还定义了一个require函数用来加载模块，描述如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([dependencies], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>require函数接受两个参数，第一个参数是一个数组，表示所依赖的模块。第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块要以参数形式传入该函数，在回调函数内部才可以使用这些模块。</p>
<p>require函数在加载依赖模块的时候是异步加载的，这样浏览器就不会失去响应，它指定的回调函数，也只有在前面的模块都加载成功后，才会运行，这样就解决了依赖性的问题。</p>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD(Common Module Definition)翻译成中文就是通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。和AMD一样，使用CMD规范也需要相应的库函数，SeaJS就是其中一个。实际上，CMD是SeaJS在推广过程中对模块定义的规范化的产出。SeaJS要解决的问题和RequireJS一样，只不过在模块定义方式和模块加载的时机上有些区别。</p>
<h2 id="define函数-1"><a href="#define函数-1" class="headerlink" title="define函数"></a>define函数</h2><p>CMD规范的define函数和AMD规范的描述相同，也是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(id?, dependencies?, factory);</div></pre></td></tr></table></figure></p>
<p>但是CMD推崇一个文件一个模块，所以经常用文件名作为模块id。同时，CMD推崇就近依赖，所以一般不在define函数的参数中写依赖，而是在factory函数中就近写。</p>
<p>factory函数有三个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factory(<span class="built_in">require</span>, exports, <span class="built_in">module</span>)</div></pre></td></tr></table></figure></p>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>require是一个方法，它接受模块标识作为唯一的参数，用来导入其他的模块，获取其它模块提供的接口。</p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>exports是一个对象，用来向外部提供接口。</p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module是一个对象，存储了去模块相关联的一些属性和方法。</p>
<h1 id="AMD与CMD的区别"><a href="#AMD与CMD的区别" class="headerlink" title="AMD与CMD的区别"></a>AMD与CMD的区别</h1><p>首先我们知道，AMD是RequireJS 在推广过程中对模块定义的规范化产出。CMD是SeaJS在推广过程中对模块定义的规范化产出。他们的区别主要有以下四点。</p>
<p>1、对于依赖的模块，AMD是提前执行（<strong>注意是执行不是加载</strong>），CMD是延迟执行。RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。AMD和CMD都是异步加载的，只是AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样就会导致依赖模块的执行顺序和书写顺序不一定一致，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才会执行。而CMD在加载完某个依赖模块后并不执行，只是下载下来，在所有依赖模块加载完成后再进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</p>
<p>2、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。CMD推崇就近依赖，只有在用到某个模块的时候再去require。对比如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AMD</span></div><div class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></div><div class="line">    a.doSomething()</div><div class="line">    b.doSomething()</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;) </div><div class="line"><span class="comment">// CMD</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</div><div class="line">    a.doSomething()</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写，需要用到的时候才require</span></div><div class="line">    b.doSomething()</div><div class="line">    <span class="comment">// ... </span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>3、AMD的API根据使用范围有区别，但使用同一个API接口。CMD的API严格区分，推崇职责单一。</p>
<p>4、AMD是异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。而CMD的机制不同，这种加载方式会产生错误，但是如果能规范化模块的内容形式，也可以异步并行加载。</p>
<h1 id="RequireJS与SeaJS的区别"><a href="#RequireJS与SeaJS的区别" class="headerlink" title="RequireJS与SeaJS的区别"></a>RequireJS与SeaJS的区别</h1><p>两者遵循的规范不同，RequireJS遵循AMD规范，SeaJS遵循CMD规范。两者的区别可以参考<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="external">SeaJS与RequireJS的异同</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着我们的项目越来越复杂，参与项目的人员越来越多，将项目划分模块就变得十分重要，开发者只需要实现自己负责的功能，其他部分可以加载别人已经写好的模块。但是JavaScript不是一种模块化的编程语言，所以JavaScript开发人员做了很多努力，在现有的运行环境中实现了模块化
    
    </summary>
    
      <category term="模块化" scheme="http://yuhan.com/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="总结" scheme="http://yuhan.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="模块" scheme="http://yuhan.com/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之XSS</title>
    <link href="http://yuhan.com/2016/09/09/client-script-security/"/>
    <id>http://yuhan.com/2016/09/09/client-script-security/</id>
    <published>2016-09-09T08:23:47.000Z</published>
    <updated>2016-12-05T13:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web安全是网站开发中我们经常容易忽视的一个问题，但一旦出现问题将会带来很大的影响。这几天读了<a href="https://book.douban.com/subject/10546925/" target="_blank" rel="external">白帽子讲Web安全</a>这本书的前半部分内容，目前还没有怎么接触过后端的东西，今天主要简单总结一下客户端脚本安全中的头号大敌——跨站脚本攻击。先说说浏览器的安全相关知识。</p>
<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>浏览器安全被越来越多的人所重视。首先，浏览器是一个客户端，如果具备了安全功能，就可以像安全软件一样对用户上网起到很好的保护作用。另外，浏览器安全也是各大浏览器厂商之间竞争的一张底牌。下面介绍一些浏览器具有的的安全功能。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器最核心最基本的安全功能。该策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。影响源的因素有：host（域名或IP地址，如果是IP地址则看做一个根域名）、子域名、端口、协议。</p>
<p><strong>注意：</strong>对于当前页面来说，页面内存放JavaScript文件的域并不重要，重要的是加载JavaScript页面所在的域。</p>
<h2 id="浏览器沙箱"><a href="#浏览器沙箱" class="headerlink" title="浏览器沙箱"></a>浏览器沙箱</h2><p>在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈被称为“挂马”。浏览器厂商根据挂马的特点研究出了一些对抗挂马的技术。与此同时，浏览器还发展出了多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。</p>
<p>Sandbox，即沙箱，已经成为泛指“资源隔离类模块”的代名词。其设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任代码访问隔离区之外的资源。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道。</p>
<h2 id="恶意网址拦截"><a href="#恶意网址拦截" class="headerlink" title="恶意网址拦截"></a>恶意网址拦截</h2><p>恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址拦黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。</p>
<p>常见的恶意网址分为两类：一类是挂马网站，这类网站通常有恶意的脚本，如JavaScript或Flash，通过利用浏览器的漏洞执行shellcode，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。</p>
<p>下面进入本文的正题，跨站脚本攻击（XSS).</p>
<h1 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h1><p>跨站脚本攻击（XSS）是客户端脚本安全中的头号大敌。通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。XSS主要有三种不同的类型，下面一一介绍。</p>
<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>第一种是反射型XSS，首先来举个例子，假设一个页面把用户输入的参数直接输出到页面上：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$input = $_GET[<span class="string">"param"</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;div&gt;"</span>.$input.<span class="string">"&lt;/div&gt;"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>在正常的情况下，用户向param提交的数据会展示到页面中，比如提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/phptest/index.php?param=this is a test</div></pre></td></tr></table></figure>
<p>会得到如下结果：<br><img src="/img/xss_test1.png" alt="xss1"></p>
<p>但是如果提交一段HTML代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/phptest/index.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>会发现alert在当前页面执行了：<br><img src="/img/xss_test2.png" alt="xss2"></p>
<p>再查看源代码会发现：<br><img src="/img/xss_test2.png" alt="xss3"></p>
<p><em>以上测试在IE中进行，有些浏览器对这种简单的XSS攻击做了防御</em></p>
<p>用户写入的script脚本已经被写入页面中。这就是XSS的第一种类型：反射型XSS。它只是简单地把用户输入的数据反射给浏览器。黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久性XSS”。</p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>第二种XSS类型是存储型XSS，它会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。</p>
<p>比较常见的场景是黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。黑客把恶意的脚本保存到服务器端，所以这种XSS攻击叫做“存储型XSS”。通常也叫做“持久型XSS”。</p>
<h2 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h2><p>第三种类型是DOM Based XSS，从效果上来说也是反射型XSS。它是通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。还是举个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">function test() &#123;</div><div class="line">    var str = document.getElementById("text").value;</div><div class="line">    document.getElementById("t").innerHTML = "&lt;a href = '"+str+"' &gt;testLink&lt;/a&gt;";</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id = "t"&gt;&lt;/div&gt;</div><div class="line">&lt;input type="text" id="text" value=""&gt;</div><div class="line">&lt;input type="button" id="s" value="write" onclick="test()"&gt;</div></pre></td></tr></table></figure>
<p>点击“write”按钮后，会在当前页面插入一个超链接，其地址为文本框的内容：<br><img src="/img/dom_xss1.png" alt="domxss1"></p>
<p>“write”按钮的onclick事件调用了test()函数，在test()函数中修改了页面的DOM节点，通过innerHTML把一段用户数据当作HTML写入到页面中，就造成了DOM Based XSS。</p>
<p>然后，我们构造如下数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">' onclick = alert(/xss/) //</span></div></pre></td></tr></table></figure>
<p>输入后，页面代码变成了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">''</span> <span class="attr">onclick</span>=<span class="string">alert(/xss/)</span> //' &gt;</span>testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>首先第一个单引号闭合掉href的第一个单引号，然后插入一个onclick事件，最后再用注释符“//”注释掉第二个单引号。点击这个新生成的连接，脚本将被执行。<br>此外，还可以通过闭合a标签，并插入一个新的HTML标签，来利用XSS攻击。例如，进行如下输入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">'&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">alert(/xss2/)</span> /&gt;</span><span class="tag">&lt;<span class="name">'</span></span></div></pre></td></tr></table></figure>
<p>会有什么效果可以自己下去实践一下！</p>
<h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><p>XSS防御是很复杂的，前文也只是浅显地介绍了XSS，这里也只简单介绍几种易懂的XSS防御方式。</p>
<h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>HttpOnly最早是由微软提出，并在IE6中实现的，现在已经逐渐成为一个标准。浏览器将禁止页面的JavaScript访问带有HttpOnly属性的Cookie。</p>
<h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>常见的Web漏洞如XSS，SQL注入等，都要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。</p>
<p>输入检查的逻辑必须放在服务端脚本代码中实现。如果只是在客户端使用JavaScript进行输入检查，是很容易被攻击者绕过的。目前Web开发的普遍做法，是同时在客户端JavaScript中和服务器端代码中实现相同的输入检查。客户端的JavaScript的输入检查可以阻挡大部分误操作的正常用户，从而节约服务器资源。</p>
<p>在XSS防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、”等。如果发现这些字符就将这些字符过滤或者编码。比较智能的“输入检查”，可能还会匹配XSS的特征。比如查找用户数据中是否包含了“script”、“javascript”等敏感字符。这种输入检查的方式可以称为“XSS Filter”。互联网上有许多开源的“XSS Filter”实现。</p>
<h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p>
<p>编码分为很多种，针对HTML代码的编码方式是HtmlEncode。它并非专用名词，只是一种函数实现，作用是将字符转换成HTMLEntities。在PHP中，有 htmlentities() 和 htmlspecialchars()两个函数可以满足安全要求。</p>
<h3 id="防御DOM-Based-XSS"><a href="#防御DOM-Based-XSS" class="headerlink" title="防御DOM Based XSS"></a>防御DOM Based XSS</h3><p>DOM Based XSS是一种比较特别的XSS漏洞，前文提到的几种防御方法都不太适用，需要特别对待。</p>
<p>先回头看看前面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">function test() &#123;</div><div class="line">    var str = document.getElementById("text").value;</div><div class="line">    document.getElementById("t").innerHTML = "&lt;a href = '"+str+"' &gt;testLink&lt;/a&gt;";</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id = "t"&gt;&lt;/div&gt;</div><div class="line">&lt;input type="text" id="text" value=""&gt;</div><div class="line">&lt;input type="button" id="s" value="write" onclick="test()"&gt;</div></pre></td></tr></table></figure>
<p>在button的onclick事件中，执行了test()函数，而该函数中最关键的一句是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).innerHTML = <span class="string">"&lt;a href = '"</span>+str+<span class="string">"' &gt;testLink&lt;/a&gt;"</span>;</div></pre></td></tr></table></figure>
<p>它将HTML代码写入了DOM节点，最后导致了XSS的发生。DOM Based XSS是从JavaScript中输出数据到HTML页面中。而前面提到的方法都是针对“从服务器应用直接输出到HTML页面”的XSS漏洞，因此不适用于DOM Based XSS。先举个例子看看正确的解决方法是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> x = <span class="string">"$var"</span>;</div><div class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;a href='"</span>+x+<span class="string">"' &gt;test&lt;/a&gt;"</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>变量“$var”输出在script标签内，可是最后又被 document.write输出到HTML页面中。假设为了保护“$var”直接在script标签内产生XSS，服务器端对其进行了javascriptEscape。可是，$var在document.write时，仍然能够产生XSS。原因在于，第一次执行javascriptEscape后，只保护了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var x = &quot;$var&quot;;</div></pre></td></tr></table></figure>
<p>但是当 document.write输出数据到HTML页面时，浏览器重新渲染了页面。在script标签执行时，已经对变量x进行了解码，其后 document.write再运行时，其参数就变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&apos; &apos;onclick=alert(1);//&apos;&apos; &gt;test&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>因此产生了XSS。</p>
<p>正确的防御方法应该是首先在“$var”输出到script时，应该执行一次javascriptEncode;其次，在 document.write输出到HTML页面时，要分具体情况：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode。也就是说从JavaScript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p>
<p>关于XSS的分享就这么多了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web安全是网站开发中我们经常容易忽视的一个问题，但一旦出现问题将会带来很大的影响。这几天读了&lt;a href=&quot;https://book.douban.com/subject/10546925/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;白帽子讲Web
    
    </summary>
    
      <category term="web安全" scheme="http://yuhan.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://yuhan.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>谈谈CSS预处理器</title>
    <link href="http://yuhan.com/2016/09/07/compares-less-sass-and-stylus/"/>
    <id>http://yuhan.com/2016/09/07/compares-less-sass-and-stylus/</id>
    <published>2016-09-07T11:21:41.000Z</published>
    <updated>2016-12-07T09:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写CSS的时候我们会发现，为了兼容浏览器等原因，我们往往需要写很多冗余的代码，CSS预处理器就是为了解决CSS的这些问题，简化CSS代码的编写。</p>
<p>目前最主流的CSS预处理器是LESS、SASS和Stylus，最近花了几天时间学习并使用了它们，于是就想对这三个预处理器做个比较。根据这三种语言的特性，主要从以下几个方面进行讨论：</p>
<ol>
<li>基本语法</li>
<li>变量</li>
<li>嵌套</li>
<li>混入(mixin)</li>
<li>继承</li>
<li>函数</li>
<li>@import</li>
<li>运算符</li>
<li>逻辑控制</li>
</ol>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>LESS的基本语法和CSS差不多，SASS和Stylus都可以利用缩进代替花括号，并且空格有重要的意义。SASS保存为”<em>.sass”是缩进格式，保存为”</em>.scss”是非缩进格式。SASS一般使用”.scss”扩展名。LESS的扩展名为”.less”，Stylus的扩展名为”.styl”。</p>
<p><strong>注意</strong>：SASS依赖于Ruby，安装前必须先安装Ruby。</p>
<p>LESS &amp; SCSS:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SASS:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span></div><div class="line">    <span class="selector-tag">list-style</span>: <span class="selector-tag">none</span></div></pre></td></tr></table></figure>
<p>Stylus:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span></div><div class="line">    <span class="selector-tag">list-style</span> <span class="selector-tag">none</span></div></pre></td></tr></table></figure></p>
<p><strong>注意：以下SASS代码都以扩展名为”.scss”的方式书写。</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>CSS预处理器中可以定义变量，并且可以在样式表中使用，变量类型没有限制，这样就可以一定程度上减少CSS中无法避免的重复问题。</p>
<p>LESS变量名必须以@符号开头，变量名和变量值之间以冒号隔开。有个问题是@规则在CSS中算是一种<strong>原生</strong>的扩展方式，变量名用@开头很可能会和以后CSS中的新@规则冲突。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@orange: #feb914；</div><div class="line">header &#123;</div><div class="line">    background-color: @orange;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SASS变量名必须以$开始，变量名和变量值之间以冒号隔开。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$orange: #feb914；</div><div class="line">header &#123;</div><div class="line">    background-color: $orange;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stylus对变量名没有任何限定，变量名与变量值之间可以用冒号、空格和等号隔开。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bgorange = #feb914；</div><div class="line">header</div><div class="line">    background-color bgorange</div></pre></td></tr></table></figure>
<p>上面三种不同的写法都会产生相同的结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#feb914</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stylus还有一个独特功能，它不需要分配值给变量就可以定义引用属性。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#logo</div><div class="line">    position: absolute</div><div class="line">    top: 50%</div><div class="line">    left: 50%</div><div class="line">    width: w = 150px</div><div class="line">    height: h = 80px</div><div class="line">    margin-left: -(w / 2)</div><div class="line">    margin-top: -(h / 2)</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#logo</span></div><div class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span></div><div class="line">    <span class="selector-tag">top</span>: 50%</div><div class="line">    <span class="selector-tag">left</span>: 50%</div><div class="line">    <span class="selector-tag">width</span>: 150<span class="selector-tag">px</span></div><div class="line">    <span class="selector-tag">height</span>: 80<span class="selector-tag">px</span></div><div class="line">    <span class="selector-tag">margin-left</span>: <span class="selector-tag">-</span>(@<span class="keyword">width</span> / <span class="number">2</span>)</div><div class="line">    margin-top: -(@height / <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>三种预处理器中定义的变量都是有作用域的，查找变量的顺序是先在局部定义中查找，如果找不到，则逐级向上查找。</p>
<p>如果我们在代码中重写某个已经定义的变量，Less的处理逻辑和其他两个有区别。Less中，这个行为叫懒加载（Lazy Loading）。<strong>注意</strong>Less中所有变量的计算，都是以这个变量最后一次被定义的值为准。</p>
<p>LESS：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@size: 40px;</div><div class="line">.content &#123;</div><div class="line">    width: @size;</div><div class="line">&#125;</div><div class="line">@size: 60px;</div><div class="line">.container &#123;</div><div class="line">    width: @size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译输出为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在SASS中情况如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$size: 40px;</div><div class="line">.content &#123;</div><div class="line">    width: $size;</div><div class="line">&#125;</div><div class="line">$size: 60px;</div><div class="line">.container &#123;</div><div class="line">    width: $size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译输出为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stylus和SASS行为相同，变量的计算以变量最近一次的定义为准。</p>
<h2 id="变量插值"><a href="#变量插值" class="headerlink" title="变量插值"></a>变量插值</h2><p>预处理器中定义的变量不仅可以用作属性值，还可以用作选择器，属性名等，这就是变量插值。</p>
<h3 id="变量名插值"><a href="#变量名插值" class="headerlink" title="变量名插值"></a>变量名插值</h3><p>Less中支持以@@var的形式引用变量，即该变量的名字是由@var的值决定的。</p>
<h3 id="选择器插值"><a href="#选择器插值" class="headerlink" title="选择器插值"></a>选择器插值</h3><p>以类选择器为例</p>
<p>LESS:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@way: new;</div><div class="line">.@&#123;way&#125;-task &#123;</div><div class="line">    font-size: 18px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SASS:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$way: new;</div><div class="line">.#&#123;$way&#125;-task &#123;</div><div class="line">    font-size: 18px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stylus:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">way: new;</div><div class="line">.&#123;way&#125;-task</div><div class="line">    font-size 18px</div></pre></td></tr></table></figure>
<p>解析结果都是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.new-task</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在Less中，通过选择器插值生成的规则无法被继承。</p>
<h3 id="import插值"><a href="#import插值" class="headerlink" title="@import插值"></a>@import插值</h3><p>Sass中只能在使用url()表达式时进行变量@import插值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$device: mobile;</div><div class="line">@import url(styles.#&#123;$device&#125;.css);</div></pre></td></tr></table></figure>
<p>Less中可以在字符串中进行插值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@device: mobile;</div><div class="line">@import "styles.@&#123;device&#125;.css";</div></pre></td></tr></table></figure>
<p>Stylus中没有@import插值，但是可以利用其字符串拼接的功能实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">device = "mobile"</div><div class="line">@import "styles." + device + ".css"</div></pre></td></tr></table></figure>
<h3 id="属性名插值"><a href="#属性名插值" class="headerlink" title="属性名插值"></a>属性名插值</h3><p>三个预处理器均支持属性名插值，使用方式且和上述插值类似。</p>
<h1 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h1><p>如果需要在相同的父元素中选择多个子元素，需要一遍又一遍地写父元素，如果用CSS预处理器就可以不用重复写父元素，并且父元素和子元素的关系一目了然。</p>
<p>三种预处理器的嵌套语法是一致的，引用父级选择器的标记&amp;也相同。除了&amp;，Sass和Stylus还分别用@at-root和”/“符号作为嵌套时根规则集的选择器引用。首先以LESS为例讨论嵌套语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#sort &#123;</div><div class="line">    margin-top: 24px;</div><div class="line">    ul &#123;</div><div class="line">        margin-left: 8px;</div><div class="line">        line-height: 36px;</div><div class="line">        vertical-align: middle;    </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">input &#123;</div><div class="line">    width: 80px;</div><div class="line">    &amp;:-ms-input-placeholder &#123;</div><div class="line">    font-size: 16px;</div><div class="line">    color: @white;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#sort</span> &#123;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">24px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#sort</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">8px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">36px</span>;</div><div class="line">    <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-ms-input-placeholder</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</div><div class="line">    <span class="attribute">color</span>: @white;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SASS还提出了属性嵌套，属性嵌套指的是有些属性拥有相同的开始单词，如border-width，border-color都是以border开头。官网的实例如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.fakeshadow</span> &#123;</div><div class="line">    <span class="attribute">border</span>: &#123;</div><div class="line">        style: solid;</div><div class="line">        <span class="attribute">left</span>: &#123;</div><div class="line">            width: <span class="number">4px</span>;</div><div class="line">            <span class="attribute">color</span>: <span class="number">#888</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="selector-tag">right</span>: &#123;</div><div class="line">            <span class="attribute">width</span>: <span class="number">2px</span>;</div><div class="line">            <span class="attribute">color</span>: <span class="number">#ccc</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的CSS为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.fakeshadow</span> &#123;</div><div class="line">    <span class="attribute">border-style</span>: solid;</div><div class="line">    <span class="attribute">border-left-width</span>: <span class="number">4px</span>;</div><div class="line">    <span class="attribute">border-left-color</span>: <span class="number">#888</span>;</div><div class="line">    <span class="attribute">border-right-width</span>: <span class="number">2px</span>;</div><div class="line">    <span class="attribute">border-right-color</span>: <span class="number">#ccc</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="混入-mixin"><a href="#混入-mixin" class="headerlink" title="混入(mixin)"></a>混入(mixin)</h1><p>mixins有点像C语言中的宏，当某段CSS经常需要在多个元素中使用时，可以为这些共用的CSS定义一个mixin，然后只需要在需要引用这些CSS地方调用该mixin即可。</p>
<p>三种预处理器的mixin使用方式的差异比较大，下面分别说明。</p>
<p>LESS混入方式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">.my-mixin &#123;</div><div class="line">    color: black;</div><div class="line">&#125;</div><div class="line">.my-other-mixin() &#123;</div><div class="line">    background: white;</div><div class="line">&#125;</div><div class="line">.my-hover-mixin() &#123;</div><div class="line">    &amp;:hover &#123;</div><div class="line">        border: 1px solid red;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">.border-radius(@radius: 5px) &#123;</div><div class="line">    -webkit-border-radius: @radius;</div><div class="line">        -moz-border-radius: @radius;</div><div class="line">            border-radius: @radius;</div><div class="line">&#125;</div><div class="line">.class &#123;</div><div class="line">    .my-mixin;</div><div class="line">    .my-other-mixin;</div><div class="line">&#125;</div><div class="line">button &#123;</div><div class="line">    .my-hover-mixin();</div><div class="line">&#125;</div><div class="line">#header &#123;</div><div class="line">    .border-radius(4px);</div><div class="line">&#125;</div><div class="line">.button &#123;</div><div class="line">    .border-radius;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译输出为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.my-mixin</span> &#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.class</span> &#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">    <span class="attribute">background</span>: white;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#header</span> &#123;</div><div class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">4px</span>;</div><div class="line">        <span class="attribute">-moz-border-radius</span>: <span class="number">4px</span>;</div><div class="line">            <span class="attribute">border-radius</span>: <span class="number">4px</span>;    </div><div class="line">&#125;</div><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">5px</span>;</div><div class="line">        <span class="attribute">-moz-border-radius</span>: <span class="number">5px</span>;</div><div class="line">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LESS的mixin需要注意的是同名的mixin不是后面的覆盖前面的，而是会累加输出。这就会产生一个问题，如果存在和mixin同名的class样式，并且mixin没有参数，则在调用时会把对应的class样式一起输出，这显然不是我们所需要的。</p>
<p>SASS的mixin用法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@mixin center-block &#123;</div><div class="line">    margin-left:auto;</div><div class="line">    margin-right:auto;</div><div class="line">&#125;</div><div class="line">.demo&#123;</div><div class="line">    @include center-block;</div><div class="line">&#125;</div><div class="line">@mixin horizontal-line($border:1px dashed #ccc, $padding:10px)&#123;</div><div class="line">    border-bottom:$border;</div><div class="line">    padding-top:$padding;</div><div class="line">    padding-bottom:$padding;  </div><div class="line">&#125;</div><div class="line">.imgtext-h li&#123;</div><div class="line">    @include horizontal-line(1px solid #ccc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.demo</span>&#123;</div><div class="line">    <span class="attribute">margin-left</span>:auto;</div><div class="line">    <span class="attribute">margin-right</span>:auto;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.imgtext-h</span> <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#cccccc</span>;</div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Sass用@mixin和@include两个指令清楚地说明了mixin的定义和引用方式。</p>
<p>Stylus的mixin和Sass的类似：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">border-radius</span>(<span class="selector-tag">n</span>)</div><div class="line">    <span class="selector-tag">-webkit-border-radius</span> <span class="selector-tag">n</span></div><div class="line">    <span class="selector-tag">-moz-border-radius</span> <span class="selector-tag">n</span></div><div class="line">    <span class="selector-tag">border-radius</span> <span class="selector-tag">n</span></div><div class="line"><span class="selector-tag">form</span> <span class="selector-tag">input</span><span class="selector-attr">[type=button]</span></div><div class="line">    <span class="selector-tag">border-radius</span> 5<span class="selector-tag">px</span></div></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承其实和混入的作用差不多，那为什么还需要继承呢？混入确实很好用，但是如果多个地方都混入同样的代码，会造成代码的重复。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.block &#123;</div><div class="line">    margin: 10px 5px;</div><div class="line">    padding: 2px;</div><div class="line">&#125;</div><div class="line">p &#123;</div><div class="line">    .block; </div><div class="line">    border: 1px solid #EEE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会输出：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.block</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">2px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">2px</span>; </div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#EEE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而我们期望的输出实际是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.block</span>,</div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">2px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#EEE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用继承就可以实现上面的输出，不会有重复的代码（以SASS为例）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.block &#123;</div><div class="line">    margin: 10px 5px;</div><div class="line">    padding: 2px;</div><div class="line">&#125;</div><div class="line">p &#123;</div><div class="line">    @extend .block; </div><div class="line">    border: 1px solid #EEE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stylus的继承来源于SASS，两者使用方式相同。而LESS则用伪类来实现继承：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.block &#123;</div><div class="line">    margin: 10px 5px;</div><div class="line">    padding: 2px;</div><div class="line">&#125;</div><div class="line">p &#123;</div><div class="line">    &amp;:extend(.block); </div><div class="line">    border: 1px solid #EEE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Less默认只继承父类本身的样式，如果要同时继承嵌套定义在父类作用域下的样式，得使用关键字all，比如&amp;:extend(.block all)。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>三种预处理器都有自己的内置函数，例如颜色处理，类型判断等。LESS中不能自定义函数，SASS和Stylus可以。</p>
<p>SASS自定义函数用法如下，需要使用@function，并用@return指令返回结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">function</span> pxToRem($px) &#123;</div><div class="line">    @<span class="keyword">return</span> $px / <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="built_in">pxToRem</span>(32px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stylus中则无需这些指令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pxToRem(n)</div><div class="line">    n / 2</div><div class="line">body</div><div class="line">    font-size: pxToRem(32px)</div></pre></td></tr></table></figure>
<h1 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h1><p>@import的作用是从其他样式表导入样式，三种预处理器的@import的使用方式各不相同。</p>
<p>除了基本的功能外，LESS引入了import选项来扩展@import的语法。语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> (keyword) <span class="string">"filename"</span>;</div></pre></td></tr></table></figure>
<p>其中keyword可以是如下几种选项（可以联合使用）。<br>1.<strong>reference:</strong>使用一个外部文件参与编译，但不输出其内容。<br>2.<strong>inline:</strong>直接将引入的文件放入输出文件中，但不处理这个引入的文件。<br>3.<strong>less:</strong>不管文件扩展名是什么都将该文件作为一个LESS文件处理。<br>4.<strong>css:</strong>不管文件扩展名是什么都将该文件作为一个CSS文件处理。<br>5.<strong>once:</strong>只引入文件一次（去重），这是默认方式。<br>6.<strong>multiple:</strong>可以引入文件多次。</p>
<p>SASS则没有LESS的这些扩展语法，它自己推断引入的方式。它的@import 不会被去重，多次引入会导致一个样式文件被多次输出到编译结果中。</p>
<p>Stylus的@import和SASS一样都是自己推断引入的方式，但是Stylus可以进行引入文件的去重，它有一个自定义的指令@require，用法和@import一样，但引入的文件只会编译一次。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>三种预处理器都具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。<br>Stylus的<a href="http://www.zhangxinxu.com/jq/stylus/operators.php" target="_blank" rel="external">中文文档</a>中，详细讨论了Stylus的运算符</p>
<h1 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h1><p>Sass中通过@if、@else 实现条件判断来提供语言的流控制，通过@for、@each、@while实现循环，然后配合map和list这两种数据类型可以实现多数编程语言提供的功能。<br>SASS中还实现了一个三目判断，语法为：if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值。</p>
<p>Stylus中通过if、else if、else、unless（基本与if相反）实现条件判断来提供语言的流控制，通过for/in实现循环迭代。</p>
<p>而LESS中没有上述复杂的语法，只通过guarded mixins代替if/else实现简单的条件判断。举例如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.mixin</span> (@<span class="keyword">a</span>) when (lightness(@a) &gt;= <span class="number">50%</span>) &#123;</div><div class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.mixin</span> (@<span class="keyword">a</span>) when (lightness(@a) &lt; <span class="number">50%</span>) &#123;</div><div class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">white</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.mixin</span> (@<span class="keyword">a</span>) &#123;</div><div class="line">    <span class="selector-tag">color</span>: @<span class="keyword">a</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是三种CSS预处理器的主要区别，实际项目中使用哪种CSS预处理器还需要自己斟酌，多踩坑才能体会到哪种预处理器最适合你当前的项目。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写CSS的时候我们会发现，为了兼容浏览器等原因，我们往往需要写很多冗余的代码，CSS预处理器就是为了解决CSS的这些问题，简化CSS代码的编写。&lt;/p&gt;
&lt;p&gt;目前最主流的CSS预处理器是LESS、SASS和Stylus，最近花了几天时间学习并使用了它们，于是就想对这三个
    
    </summary>
    
      <category term="CSS" scheme="http://yuhan.com/categories/CSS/"/>
    
    
      <category term="前端工具" scheme="http://yuhan.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="CSS预处理" scheme="http://yuhan.com/tags/CSS%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型学习笔记</title>
    <link href="http://yuhan.com/2016/08/28/JavaScript-prototype/"/>
    <id>http://yuhan.com/2016/08/28/JavaScript-prototype/</id>
    <published>2016-08-28T06:02:42.000Z</published>
    <updated>2016-08-29T00:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>要想理解JavaScript中的原型，首先要从对象说起。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>JavaScript中一切都是对象，相信这句话大家都不陌生，但是其实在JavaScript中这句话并不准确。JavaScript中的typeof函数可以返回变量的类型。总共有两大类型，<strong>值类型</strong>（包括undefined、number、string、boolean）和<strong>引用类型</strong>（包括function、object）。只有引用类型的变量才能算是对象。函数、数组、对象、null、new Number(10)都是对象，他们都是引用类型。</p>
<p>JavaScript中对象是若干属性的集合，只有属性没有方法，方法也是一种属性。下面是一个常见的对象的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">	<span class="attr">a</span>: <span class="number">10</span>,</div><div class="line">	<span class="attr">b</span>: &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'hieeyh'</span>,</div><div class="line">	<span class="attr">year</span>: <span class="number">1993</span></div><div class="line">	&#125;</div><div class="line">	c: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a + x);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>属性a是一个数值，属性b是一个对象，属性c是一个函数。</p>
<h1 id="函数和对象的关系"><a href="#函数和对象的关系" class="headerlink" title="函数和对象的关系"></a>函数和对象的关系</h1><p>上面讲到函数也是一种对象，但是函数和对象之间的关系比较复杂，因为对象不仅可以通过上述方式创建还可以通过函数创建，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'hieeyh'</span>;</div><div class="line">	<span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line">	<span class="keyword">this</span>.sex = <span class="string">'女'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>其实对象那一节所讲的对象创建方式的本质是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//var obj = &#123; a: 10, b: 20&#125;;</span></div><div class="line"><span class="comment">//var arr = [5, 6];</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.a = <span class="number">10</span>;</div><div class="line">obj.b = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">5</span>;</div><div class="line">arr[<span class="number">1</span>] = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<p><em>其中Object和Array都是函数。</em></p>
<p>到此我们得到一个很玄乎的概念，对象是由函数创建的，而函数却又是一种对象。想要搞清他们之间的关系就要进入我们的正题原型的概念了。</p>
<h1 id="prototype原型"><a href="#prototype原型" class="headerlink" title="prototype原型"></a>prototype原型</h1><p>函数是一种对象，对象是若干属性的集合，所以函数一定有属性。每一个函数都有一个prototype属性，该属性的值又是一个对象。默认的只有一个叫做constructor的属性，指向这个函数本身。</p>
<p><img src="/img/prototype.png" alt="prototype"></p>
<p>如上图，myFunction是一个函数，右侧方框是它的原型。原型可以自定义增多很多属性，例如Object函数的原型中有hasOwnProperty、isPrototypeOf等属性。所以，我们可以在自定义的函数的prototype中增加自己的属性。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Person.prototype.name = <span class="string">'hieeyh'</span>;</div><div class="line">Person.prototype.getYear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">1993</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>上述代码中，Person是一个函数，person是从Person函数中new出来的，person对象就可以调用Person.prototype中的属性。因为每个对象都有一个隐藏的属性“__proto__”，这个属性引用了创建这个对象的函数的prototype。即：person.__proto__ === Person.prototype。这里的”__proto__“称为隐式原型。</p>
<p>__proto__是一个隐藏的属性，开发者用不到这个属性值。既然每个对象都有一个__proto__属性，那么Object.prototype也是一个对象，它的prototype是什么呢？Object.prototype是一个特例，它的__proto__指向null。</p>
<p>函数也是一种对象，函数当然也有__proto__。函数的__proto__指向Function.prototype，因为函数对象都是由Function创建的。</p>
<p>当然Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以Function是被自身创建的。所以它的__proto__指向了自身的Prototype。（有点晕，哈哈）</p>
<p>最后，Function.prototype指向对象，它的__proto__也指向Object.prototype。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。</p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>typeof函数可以很清楚判断一个值类型变量的类型，但是对于引用类型的变量它只能判断出是object还是function，不能判断他具体是通过那个函数new出来的。这只就需要用到instanceof了。</p>
<p>instanceof运算符的第一个变量是一个对象，称为VAR；第二个变量一般是一个函数，称为FN。<br>instanceof的判断队则是：沿着VAR的__proto__这条线来找，同时沿着FN的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。通过下面的例子进行进一步理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>有过面向对象变成经验的同学应该可以想到，instanceof表示的就是一种继承关系，在js中也可以说是一种原型链的结构。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line">foo.a = <span class="number">10</span>;</div><div class="line">Foo.prototype.a = <span class="number">100</span>;</div><div class="line">Foo.prototype.b = <span class="number">200</span>;</div><div class="line"><span class="built_in">console</span>.log(foo.a);  <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(foo.b);  <span class="comment">//200</span></div></pre></td></tr></table></figure>
<p>以上代码中，foo是Foo函数new出来的对象，foo.a是foo对象的基本属性，foo.b是从Foo.prototype得来，因为foo.__proto__指向的是Foo.prototype。</p>
<p>访问一个对象的属性时，先在其基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。访问foo.b时，f1的基本属性中没有b，于是沿着__proto__找到了Foo.prototype.b。</p>
<p><strong>另外</strong>，所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的<strong>继承</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要想理解JavaScript中的原型，首先要从对象说起。&lt;/p&gt;
&lt;h1 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h1&gt;&lt;p&gt;JavaScript中一切都是对象，相信这句话大家都不陌生，但是其实
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://yuhan.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域学习笔记</title>
    <link href="http://yuhan.com/2016/08/27/Scoping/"/>
    <id>http://yuhan.com/2016/08/27/Scoping/</id>
    <published>2016-08-27T11:29:06.000Z</published>
    <updated>2016-08-29T01:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>作用域和作用域链是JavaScript开发中经常遇到的问题，面试中也是常见问题。</p>
<h1 id="JavaScript作用域"><a href="#JavaScript作用域" class="headerlink" title="JavaScript作用域"></a>JavaScript作用域</h1><p>JavaScript作用域是变量与函数的可访问范围，作用域控制着变量与函数的可见性和生命周期。</p>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>全局作用域中的对象在代码中的任何地方都可以被访问到，有以下几种情况：</p>
<ol>
<li>最外层函数</li>
<li>最外层函数外面定义的变量</li>
<li>所有未定义直接赋值的变量（即没有用var定义的变量）</li>
<li>所有window对象的内置属性（window.document、window.location等）</li>
</ol>
<h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><p>局部作用域中的对象只在固定的代码片段中可访问到，最常见的就是函数内部，在JS中，局部作用域也可以被称为函数作用域。</p>
<h2 id="无块级作用域"><a href="#无块级作用域" class="headerlink" title="无块级作用域"></a>无块级作用域</h2><p>上面说到JS中局部作用域也被称为函数作用域也许就会有人疑惑，块级作用域不也是局部的么？然而，JS中并没有块级作用域。即由花括号封闭的代码块没有自己的作用域，导致在运用for循环的时候会出现一些意想不到的事情，之后关于<a href="">闭包</a>的学习笔记会详细说明。</p>
<h1 id="JavaScript作用域链"><a href="#JavaScript作用域链" class="headerlink" title="JavaScript作用域链"></a>JavaScript作用域链</h1><p>JS中一切都是对象，对象不仅拥有可以通过代码访问的属性还有一系列仅供JavaScript引擎访问的内部属性。</p>
<h2 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>（variable object），环境中定义的所有变量和函数都保存在这个对象中。该对象代码无法访问，但JavaScript引擎会在后台使用它。</p>
<p>全局执行环境是最外围的一个执行环境。某个执行环境中所有的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也随之销毁。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时（该函数被执行时），该函数的环境就会被推入一个环境栈中。函数执行完成后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（activation object）作为变量对象。该对象包含了函数的所有局部变量、命名参数、参数集合以及this。</p>
<p>作用域链中的下一个变量则来自下一个包含环境，这样，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>程序执行时，标识符的解析始终是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终是从作用域链的前端开始，然后逐级向后回溯，知道找到标识符为止。</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>从作用域链的结构可以看出，在执行环境的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个全局对象被用了一次以上，则先把它存储到局部再使用。</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>虽然执行环境的类型只有全局和局部两种，但是有些情况会延长作用域链，因为这些语句会在作用域的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。两种情况下会发生这种现象。就是当执行流进入下列任何一个语句时，作用域链会得到加长：</p>
<ol>
<li>try-catch语句的catch块</li>
<li>with语句</li>
</ol>
<p>with语句会将指定的对象添加到作用域链中，catch会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<p>所以要尽量避免使用with语句，由于try-catch语句在代码调试和异常处理中非常有用，不建议完全避免使用它。可以通过优化代码来减少catch语句对性能的影响。一个很好的方法是将错误委托给一个函数处理，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    doSomething();</div><div class="line">&#125; <span class="keyword">catch</span>(ex)&#123;</div><div class="line">    handleError(ex); <span class="comment">//委托给处理器方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作用域和作用域链是JavaScript开发中经常遇到的问题，面试中也是常见问题。&lt;/p&gt;
&lt;h1 id=&quot;JavaScript作用域&quot;&gt;&lt;a href=&quot;#JavaScript作用域&quot; class=&quot;headerlink&quot; title=&quot;JavaScript作用域&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="JavaScript" scheme="http://yuhan.com/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://yuhan.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://yuhan.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS水平垂直居中总结</title>
    <link href="http://yuhan.com/2016/08/23/something-about-center/"/>
    <id>http://yuhan.com/2016/08/23/something-about-center/</id>
    <published>2016-08-23T07:31:31.000Z</published>
    <updated>2017-03-04T03:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做百度ife上2015春季的html,css练习，印象最深的就是各种情况下的水平垂直居中了，在这里总结一下，以后要用的时候如果忘了就可以直接在自己的博客里找啦。</p>
<h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><p>首先，居中肯定是子元素在一个父元素中居中，设置水平居中的前提是父元素必须是块级元素，且宽度已经设定。</p>
<h2 id="子元素为行内元素"><a href="#子元素为行内元素" class="headerlink" title="子元素为行内元素"></a>子元素为行内元素</h2><p>当子元素为行内元素时，子元素的宽度是由其内容撑开的，对父元素设定“text-align:center;”，就可实现子元素在父元素中水平居中。</p>
<h2 id="子元素为宽度设定的块级元素"><a href="#子元素为宽度设定的块级元素" class="headerlink" title="子元素为宽度设定的块级元素"></a>子元素为宽度设定的块级元素</h2><p>这种情况最简单的方法就是给子元素设定“margin:0 auto;”，相同的原理，也可以通过父元素和子元素的宽度计算出父元素的padding-left/padding-right或者计算出子元素的margin-left/margin-right，然后设置即可。</p>
<p><strong>注意：</strong>如果子元素相对父元素绝对定位（此时父元素需要设置定位方式为相对定位，即position:relative;），对子元素样式设置如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.child</span> &#123;</div><div class="line">	<span class="attribute">position</span>: absolute;</div><div class="line">	<span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">	<span class="attribute">margin-left</span>: -<span class="number">50px</span>;</div><div class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>margin-left大小设置为子元素长度的一般，符号为负。</em></p>
<h2 id="子元素为宽度未设定的块级元素"><a href="#子元素为宽度未设定的块级元素" class="headerlink" title="子元素为宽度未设定的块级元素"></a>子元素为宽度未设定的块级元素</h2><p>这种情况下，子元素宽度没有设定，那么子元素的水平方向上就会充满整个父元素的宽度，那么子元素就是水平居中的，其实这种情况下谈水平居中也没有意义。</p>
<h2 id="子元素为宽度设定的浮动元素"><a href="#子元素为宽度设定的浮动元素" class="headerlink" title="子元素为宽度设定的浮动元素"></a>子元素为宽度设定的浮动元素</h2><p>当子元素为宽度设定的浮动元素时，设置其“margin:0 auto;”就无法实现水平居中了。可以通过父元素和子元素的宽度计算出父元素的padding-left/padding-right或者计算出子元素的margin-left/margin-right，然后设置，使浮动子元素水平居中。</p>
<h2 id="子元素为宽度未设定的浮动元素"><a href="#子元素为宽度未设定的浮动元素" class="headerlink" title="子元素为宽度未设定的浮动元素"></a>子元素为宽度未设定的浮动元素</h2><p>当浮动的子元素宽度未设定时，就无法通过计算padding和margin来使其水平居中了，这时可以用下面的方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">	<span class="attribute">float</span>:left;</div><div class="line"> 	<span class="attribute">position</span>:relative;</div><div class="line"> 	<span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.child</span> &#123;</div><div class="line">	<span class="attribute">float</span>:left;</div><div class="line"> 	<span class="attribute">position</span>:relative;</div><div class="line"> 	<span class="attribute">right</span>:<span class="number">50%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><p>显然，设置垂直居中的前提是父元素的高度已经设定。</p>
<h2 id="子元素为行内元素-1"><a href="#子元素为行内元素-1" class="headerlink" title="子元素为行内元素"></a>子元素为行内元素</h2><p>此时，子元素高度由其内容撑开。设置父元素的line-height等于父元素的height即可。</p>
<h2 id="子元素为高度设定的块级元素"><a href="#子元素为高度设定的块级元素" class="headerlink" title="子元素为高度设定的块级元素"></a>子元素为高度设定的块级元素</h2><p>和水平定位一样，根据父元素子元素高度算出父元素的padding-top/padding-bottom或者子元素的margin-top/margin-bottom即可。</p>
<p>同样，也可以利用子元素相对父元素绝对定位实现垂直居中（此时父元素需要设置定位方式为相对定位，即position:relative;）。对子元素样式设置如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.child</span> &#123;</div><div class="line">	<span class="attribute">position</span>: absolute;</div><div class="line">	<span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">	<span class="attribute">margin-top</span>: -<span class="number">50px</span>;</div><div class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>margin-left大小设置为子元素高度的一般，符号为负。</em></p>
<h2 id="子元素为高度未设定的块级元素"><a href="#子元素为高度未设定的块级元素" class="headerlink" title="子元素为高度未设定的块级元素"></a>子元素为高度未设定的块级元素</h2><p>这种情况下，给父元素设定“display:table-cell;vertical-align:middle;”即可。</p>
<p><em>其实，对于水平和垂直居中，如果父元素个、宽度或者高度没有设定，设置父元素的padding-left与padding-right相等，或者padding-top与padding-bottom相等就可以让子元素看起来是居中的，但这样谈论没什么意义。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做百度ife上2015春季的html,css练习，印象最深的就是各种情况下的水平垂直居中了，在这里总结一下，以后要用的时候如果忘了就可以直接在自己的博客里找啦。&lt;/p&gt;
&lt;h1 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水平居中&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="CSS" scheme="http://yuhan.com/categories/CSS/"/>
    
    
      <category term="总结" scheme="http://yuhan.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="css" scheme="http://yuhan.com/tags/css/"/>
    
      <category term="居中" scheme="http://yuhan.com/tags/%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>怎么用github+hexo搭建博客--优化篇</title>
    <link href="http://yuhan.com/2016/08/11/how-to-build-a-personalwebsite2/"/>
    <id>http://yuhan.com/2016/08/11/how-to-build-a-personalwebsite2/</id>
    <published>2016-08-11T04:07:05.000Z</published>
    <updated>2017-03-04T03:32:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照github+hexo博客搭建基础篇已经可以搭建一个基本的博客了，但那还不能满足我的一些需求。hexo给我们提供了很多的主题，我挑选了一款叫<a href="https://github.com/forsigner/fexo" target="_blank" rel="external">fexo</a>的主题，下面以fexo主题为例，来看看怎么安装配置主题。</p>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>在你的博客目录(<em>D:\hexo</em>)下右键，选择Git Bash Here，输入以下命令：</p>
<p>&#124;&nbsp;&nbsp;<code>git clone https://github.com/forsigner/fexo.git themes/fexo</code></p>
<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>修改博客整站配置文件(<em>D:\hexo_config.yml</em>)中的theme属性，如下：</p>
<p>&#124;&nbsp;&nbsp;theme: fexo</p>
<h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><p>输入如下命令，就可以对主题进行更新了：</p>
<p>&#124;&nbsp;&nbsp;cd themes/fexo<br>&#124;&nbsp;&nbsp;git pull origin master</p>
<p>现在就可以将最新的博客部署到github上，然后就可以看到更换主题后的博客啦。</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>在主题目录下的配置文件（<em>D:\hexo\themes_config.yml</em>）中可以对主题进行配置，fexo主题的<a href="http://forsigner.com/2016/03/10/fexo-doc-zh-cn/" target="_blank" rel="external">配置文档</a>已经说明的很清楚了，这里只做一些补充。</p>
<h3 id="设置面包屑"><a href="#设置面包屑" class="headerlink" title="设置面包屑"></a>设置面包屑</h3><p>面包屑就是Archives，分类等页面最上面的一部分，如下图：</p>
<p><img src="/img/head.png" alt="head"></p>
<p>若将breadcrumb的isShow属性，则上图中的部分就不会在博客在显示。</p>
<h3 id="启用分类页面"><a href="#启用分类页面" class="headerlink" title="启用分类页面"></a>启用分类页面</h3><p>刚开始启用完分类页面之后我很疑惑，分类的那些类名是从哪儿来的，然后看fexo主题的源码，发现就是在每一篇博客的开头设置的，博客开头的categories属性就是用来设置该博客的分类的，在生成分类标签的时候会自动遍历每一篇博客的开头，获取所有的分类，重复的分类不再重复获取。标签页面的实现也是这个道理，设置博客开头的tags属性，多个标签用数组的形式表示，如下：</p>
<p>&#124;&nbsp;&nbsp;tags:[总结,前端]</p>
<h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h2><p>fexo主题中有RSS导航，但是只是在配置文件中只说了怎么在页面导航中添加RSS选项，并没有说怎么生成RSS文件。</p>
<p>hexo提供了RSS的生成插件，但是是需要手动安装的。安装RSS插件到博客根目录：</p>
<p>&#124;&nbsp;&nbsp;npm install hexo-generator-feed  –save</p>
<p>由于fexo主题中已经给RSS添加了连接，这里就不需要收到添加了。将代码部署到github，访问博客，点击导航栏中RSS，就可以看到博客的RSS文件了。</p>
<p><strong>说明：</strong>最新版本的hexo是不需要在博客整站配置文件中（<em>D:\hexo_config.yml</em>）添加plugins属性的。</p>
<h2 id="添加“多说”"><a href="#添加“多说”" class="headerlink" title="添加“多说”"></a>添加“多说”</h2><p>hexo默认使用国外比较流行的disqus评论系统，我的博客还是使用了国内的“多说”评论系统。</p>
<ol>
<li>在<a href="">多说</a>进行注册，社交账号就能登陆，fexo主题中已经帮我们写好了代码，就不需要获取通用代码了。</li>
<li>在多说首页点击我要安装，创建站点。</li>
<li>设置fexo主题配置文件（<em>D:\hexo\themes_config.yml</em>）中的duoshuo_shortname值为你刚刚创建站点时设置的多说域名的二级域名。</li>
</ol>
<p>将代码部署，访问博客，就可以看到文章下有多说评论框啦。</p>
<h2 id="更换域名"><a href="#更换域名" class="headerlink" title="更换域名"></a>更换域名</h2><p>首先要去购买一个域名，然后设置DNS，网上很多教程，这里不细说了。但要注意，需要在本地博客根目录的source文件夹中新建一个CNAME文件，内容就是你购买的域名，没有其他多余的内容，我的是hyuhan.com。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照github+hexo博客搭建基础篇已经可以搭建一个基本的博客了，但那还不能满足我的一些需求。hexo给我们提供了很多的主题，我挑选了一款叫&lt;a href=&quot;https://github.com/forsigner/fexo&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
      <category term="博客搭建" scheme="http://yuhan.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="博客搭建" scheme="http://yuhan.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>怎么用github+hexo搭建博客--基础篇</title>
    <link href="http://yuhan.com/2016/08/10/How-to-build-a-personalwebsite1/"/>
    <id>http://yuhan.com/2016/08/10/How-to-build-a-personalwebsite1/</id>
    <published>2016-08-10T11:51:02.000Z</published>
    <updated>2016-08-11T06:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上已经有很多github+hexo搭建个人博客的教程，但在我搭建个人博客的过程中遇到了一些问题查了很多资料才解决，所以在这里细致地分享一下我搭建网站的整个过程。（本人用的Windows系统所以本教程暂时只针对Windows用户。）</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>到<a href="https://git-scm.com/" target="_blank" rel="external">git</a>官网下载相应版本,安装即可。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>到<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>官网下载相应版本，安装即可。</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开Git Bash，输入<br>&#124;&nbsp;&nbsp;npm install -g hexo</p>
<p> (<em>npm是Node自带的包管理工具</em>)</p>
<h2 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h2><p>在想要创建hexo的地方新建hexo文件夹（如：<em>D:\hexo</em>）,在hexo文件夹中，右键选择Git Bash Here（若右键没出现Git Bash可以直接进入开始菜单找到git bash，再进入相应目录），执行以下命令：</p>
<p>&#124;&nbsp;&nbsp;hexo init</p>
<p>hexo会自动在你的hexo文件夹下创建搭建网站需要的所有文件，再执行以下命令安装所需的依赖包：</p>
<p>&#124;&nbsp;&nbsp;npm install</p>
<h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><p>目前为止已经搭建好本地的hexo博客了，在Git Bash中执行如下命令：</p>
<p>&#124;&nbsp;&nbsp;hexo generate （或者hexo g）</p>
<p>&#124;&nbsp;&nbsp;hexo server （或者hexo s）</p>
<p>然后打开浏览器，在地址栏输入localhost:4000，就可以看到我们搭建好的本地博客了。到此只是搭建好了本地博客，还需要将博客部署到github上，显然，需要注册一个github账号。</p>
<h2 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h2><p>进入<a href="https://github.com/" target="_blank" rel="external">github</a>官网注册就好了，记住不要忘了验证邮件。我的github的名字是hieeyh。</p>
<h2 id="新建repository"><a href="#新建repository" class="headerlink" title="新建repository"></a>新建repository</h2><p>新建一个repository，名字是yourgithubname.github.io，比如我的是hieeyh.github.io。</p>
<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>进入你的hexo文件夹根目录下，用编辑器打开_config.yml，修改deploy项，如下（根据你的github进行相应更改）：</p>
<p>&#124;&nbsp;&nbsp;deploy:</p>
<p>&#124;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&nbsp;git</p>
<p>&#124;&nbsp;&nbsp;&nbsp;&nbsp;repo:&nbsp;&nbsp;<code>https://github.com/hieeyh/hieeyh.github.io.git</code></p>
<p>&#124;&nbsp;&nbsp;&nbsp;&nbsp;branch:&nbsp;&nbsp;master</p>
<p>然后执行以下命令：</p>
<p>&#124;&nbsp;&nbsp;hexo generate （或者hexo g）</p>
<p>&#124;&nbsp;&nbsp;hexo deploy （或者hexo d）</p>
<p>此时就完成部署了，用浏览器访问hieeyh.github.io即可。</p>
<p>每次修改完本地的文件后要执行以下命令，重新部署到github上：</p>
<p>&#124;&nbsp;&nbsp;hexo clean </p>
<p>&#124;&nbsp;&nbsp;hexo generate （或者hexo g）</p>
<p>&#124;&nbsp;&nbsp;hexo deploy （或者hexo d）</p>
<p><strong>注意：</strong>如果是第一次使用github，则需要设置ssh,可以参考<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661821&amp;idx=1&amp;sn=c6116ed82bff2d083bb152fbd8cbc38d&amp;scene=1&amp;srcid=0621l9okMDolnRp9zG9xHx9E#wechat_redirect" target="_blank" rel="external">教程</a>。</p>
<h2 id="整站配置"><a href="#整站配置" class="headerlink" title="整站配置"></a>整站配置</h2><p>hexo根目录下的_config.yml（<em>D:\hexo_config.yml</em>）中是对整个站点的基本配置。除了之前配置的deploy项和默认的以外，我目前还配置了以下项：</p>
<p>&#124;&nbsp;&nbsp;# Site</p>
<p>&#124;&nbsp;&nbsp;title: Hieeyh’s blog</p>
<p>&#124;&nbsp;&nbsp;subtitle:  一只前端小菜鸟的成长日记</p>
<p>&#124;&nbsp;&nbsp;description: 前端博客</p>
<p>&#124;&nbsp;&nbsp;author: hieeyh</p>
<p>&#124;&nbsp;&nbsp;language: zh-CN</p>
<p>分别是站点名，站点副标题，对站点的描述，作者名字，语言。</p>
<p>当然主题也可以做相应的配置，这里先不细说。</p>
<h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>首先在命令行中输入：</p>
<p>&#124;&nbsp;&nbsp;hexo new “your article name”</p>
<p>然后打开这个文件（在D:\hexo\source_posts下），就可以编辑你的博客了。</p>
<p>首先要配置开头：</p>
<p>&#124;&nbsp;&nbsp;—</p>
<p>&#124;&nbsp;&nbsp;title: your article name</p>
<p>&#124;&nbsp;&nbsp;date: 2016-08-10 19:51:02</p>
<p>&#124;&nbsp;&nbsp;categories: blog</p>
<p>&#124;&nbsp;&nbsp;tags: [博客，前端]</p>
<p>&#124;&nbsp;&nbsp;—</p>
<p><strong>其中</strong>，catogories之后引入文章分类会用到，tags之后引入标签会用到。在开头后面就可以接着写我们博客的内容了，博客内容是用markdown写的。可以去网上找些教程学一学，并不难。</p>
<p>然后，将博客部署到github上，就能看见我们写的博客啦。</p>
<p>这篇文章就先写到这吧，之后再分享关于主题配置修改，RSS，多说插件使用和域名相关的一些经验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上已经有很多github+hexo搭建个人博客的教程，但在我搭建个人博客的过程中遇到了一些问题查了很多资料才解决，所以在这里细致地分享一下我搭建网站的整个过程。（本人用的Windows系统所以本教程暂时只针对Windows用户。）&lt;/p&gt;
&lt;h2 id=&quot;安装Git&quot;&gt;&lt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://yuhan.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="博客搭建" scheme="http://yuhan.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>http请求方式总结</title>
    <link href="http://yuhan.com/2016/08/09/http-request-method/"/>
    <id>http://yuhan.com/2016/08/09/http-request-method/</id>
    <published>2016-08-09T08:06:32.000Z</published>
    <updated>2016-08-09T08:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间同学帮我内推了腾讯的实习，那时我学前端还没多久，基本上是啥也不知道，但是面试官问我http有哪些请求报文的方式的时候，我竟然只答出了get和post，不管怎样我也是学过计算机网络的，居然只能想起这两个来，所以我决定要好好总结一下http的请求方式了，说不定下次面试又遇到这个问题了呢。</p>
<p><em>下面是谢希仁著计算机网络(第5版)中的定义</em></p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>请求读取由URL所标志的信息。</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>给服务器添加信息（例如，注释）。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>请求读取由URL所标志的信息的首部。</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>在指明的URL下存储一个文档。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除指明的URL所标志的资源。</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>用来进行环回测试的请求报文。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>用于代理服务器。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>请求查询服务器的性能，或者查询与资源相关的选项和需求。</p>
<p>还有一些我们平时不怎么接触到的，比如PATCH，MOVE，COPY，LINK，UNLINK这些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间同学帮我内推了腾讯的实习，那时我学前端还没多久，基本上是啥也不知道，但是面试官问我http有哪些请求报文的方式的时候，我竟然只答出了get和post，不管怎样我也是学过计算机网络的，居然只能想起这两个来，所以我决定要好好总结一下http的请求方式了，说不定下次面试又
    
    </summary>
    
      <category term="计算机网络" scheme="http://yuhan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="总结" scheme="http://yuhan.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="http" scheme="http://yuhan.com/tags/http/"/>
    
      <category term="面试" scheme="http://yuhan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
