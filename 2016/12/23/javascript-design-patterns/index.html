<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>《JavaScript设计模式》读后感 觉很复杂 | Hieeyh&#39;s blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="学习笔记,设计模式," />
  

  <meta name="description" content="接触前端两三个月的时候，那时候只是听一些人说设计模式很重要，然后我就去读了一本设计模式的书，读得我心情很复杂，因为根本看不懂，也不知道这些设计模式到底设计出来干嘛的，看了一部分就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有一些启发。于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript设计模式》读后感 觉很复杂">
<meta property="og:url" content="http://yuhan.com/2016/12/23/javascript-design-patterns/index.html">
<meta property="og:site_name" content="Hieeyh's blog">
<meta property="og:description" content="接触前端两三个月的时候，那时候只是听一些人说设计模式很重要，然后我就去读了一本设计模式的书，读得我心情很复杂，因为根本看不懂，也不知道这些设计模式到底设计出来干嘛的，看了一部分就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有一些启发。于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事">
<meta property="og:updated_time" content="2016-12-23T01:37:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《JavaScript设计模式》读后感 觉很复杂">
<meta name="twitter:description" content="接触前端两三个月的时候，那时候只是听一些人说设计模式很重要，然后我就去读了一本设计模式的书，读得我心情很复杂，因为根本看不懂，也不知道这些设计模式到底设计出来干嘛的，看了一部分就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有一些启发。于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/project/"
            target="_self"
            >
            项目
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于我
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是设计模式"><span class="toc-text">什么是设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建型设计模式"><span class="toc-text">创建型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单工厂模式"><span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂方法模式"><span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-1"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-1"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象工厂模式"><span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-2"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-2"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-2"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建造者模式"><span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-3"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-3"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-4"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-3"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-4"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-5"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-4"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-5"><span class="toc-text">收获与总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结构型设计模式"><span class="toc-text">结构型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#外观模式"><span class="toc-text">外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-6"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-5"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-6"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适配器模式"><span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-7"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-6"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-7"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式"><span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-8"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-7"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-8"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰者模式"><span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-9"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-8"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-9"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桥接模式"><span class="toc-text">桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-10"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-9"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-10"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合模式"><span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-11"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-10"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-11"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#享元模式"><span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-12"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-11"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-12"><span class="toc-text">收获与总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#行为型设计模式"><span class="toc-text">行为型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模板方法模式"><span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-13"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-12"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-13"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观察者模式"><span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-14"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-13"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-14"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态模式"><span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-15"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-14"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-15"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#策略模式"><span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-16"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-15"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-16"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#职责链模式"><span class="toc-text">职责链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-17"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-16"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-17"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令模式"><span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-18"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-17"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-18"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问者模式"><span class="toc-text">访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-19"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-18"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-19"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中介者模式"><span class="toc-text">中介者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-20"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-19"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-20"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备忘录模式"><span class="toc-text">备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-21"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-20"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-21"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器模式"><span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-22"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-21"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-22"><span class="toc-text">收获与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释器模式"><span class="toc-text">解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-23"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-22"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收获与总结-23"><span class="toc-text">收获与总结</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-javascript-design-patterns" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">《JavaScript设计模式》读后感 觉很复杂</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.12.23</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>hieeyh</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </span>



      

    </div>
  </header>

  <div class="article-content">
    
      <p>接触前端两三个月的时候，那时候只是听一些人说设计模式很重要，然后我就去读了一本设计模式的书，读得我心情很复杂，因为根本看不懂，也不知道这些设计模式到底设计出来干嘛的，看了一部分就没再看了。后来就自己做一些小项目也觉着好像不需要用到设计模式这个东西呀。现在，接触前端有半年了，决定再重新看看设计模式，说不定会有一些启发。于是发现了一本好书——《JavaScript设计模式》，写的通俗易懂，用一个个故事串起了一整本书，看了一部分发现原来我平时写代码的时候无意之中就用到了一些设计模式，然后就忍不住都看完了。看完整本书，让我完全改变了以前对设计模式的看法，也学到了很多在实际项目开发中的经验。这里就简单总结下这本书，也算是做个笔记，供自己以后参考。<br>先给个书的链接: <a href="https://www.amazon.cn/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%A0%E5%AE%B9%E9%93%AD/dp/B013HO6DNS/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1482324196&amp;sr=1-2&amp;keywords=javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">JavaScript设计模式-张容铭</a></p>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是代码设计经验的总结，为了可重用代码，保证代码的可靠性等。设计模式主要分为三大类型，创建型模式，结构型模式和行为型模式，本书还额外写了另两类设计模式，技巧型模式和架构型模式。JavaScript设计模式是以面向对象编程为基础的，JavaScript的面向对象编程和传统的C++、Java的面向对象编程有些差别，这让我一开始接触JavaScript的时候感到十分痛苦，但是这只能靠自己慢慢积累慢慢思考。想继续了解JavaScript设计模式必须要先搞懂JavaScript面向对象编程，否则只会让你自己很痛苦。</p>
<h1 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h1><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。创建型设计模式主要有简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式和单例模式，下面一一道来。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>作者把简单工厂模式比如成一个神奇的魔术师。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>看完上面的定义一定很不解，说的到底是啥，现在就举个例子来解释一下。比如体育商品店卖体育器材，里面有很多体育用品及其相关介绍。当你来到体育用品店买一个篮球，只需问售货员，他会帮你找到你所要的东西。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 篮球基类</span></div><div class="line"><span class="keyword">var</span> Basketball = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intro = <span class="string">'篮球盛行于美国'</span>;</div><div class="line">&#125;;</div><div class="line">Basketball.prototype = &#123;</div><div class="line">    <span class="attr">getMember</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'每个队伍需要5名队员'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getBallSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'篮球很大'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 足球基类</span></div><div class="line"><span class="keyword">var</span> Football = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.intro = <span class="string">'足球盛行于美国'</span>;</div><div class="line">&#125;;</div><div class="line">Football.prototype = &#123;</div><div class="line">    <span class="attr">getMember</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'每个队伍需要11名队员'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getBallSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'篮球很大'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 运动工厂</span></div><div class="line"><span class="keyword">var</span> SportsFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(name) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'NBA'</span>: </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Basketball();</div><div class="line">        <span class="keyword">case</span> <span class="string">'wordCup'</span>: </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Football();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当你使用这个运动工厂时只需要记住SportsFactory这个工厂对象就好了，它会帮你找到你想要的。<br>简单工厂模式的理念是创建对象，上面例子是将不同的类实例化，但是简单工厂模式还可以创建相似对象，将相似的东西提取，不相似的针对性处理即可。这样只需创建一个对象就可以替代多个类了。</p>
<h3 id="收获与总结"><a href="#收获与总结" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>团队开发不同于个人，对全局变量的限制很大，要尽量少得创建全局变量。如果有同一类对象在不同需求中重复使用，那么大部分是不需要重复创建的，要学会代码复用。用简单工厂来创建对象，可以减少全局变量创建提高代码复用率，它的使用场合限制在创建单一对象。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>作者把工厂方法模式比喻成一张名片。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际开发中，需求的变更是很正常的，开始需求简单可以直接创建对象，类似的需求多了可以用简单工厂方法重构，但是如果需求不停变化，那么不仅要修改工厂函数还要添加类，这样就没完了。而工厂方法模式本意是将实际创建对象的工作推迟到子类中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 工厂类</span></div><div class="line"><span class="keyword">var</span> Factory = <span class="function"><span class="keyword">function</span>(<span class="params">type, content</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Factory) &#123;</div><div class="line">        <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="keyword">this</span>[type](content);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 防止使用者不知道这是一个类，忘了加new操作符创建，导致全局变量污染</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Factory(type, content);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Factory.prototype = &#123;</div><div class="line">    <span class="attr">Java</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">JavaScript</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">php</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样以后如果想添加其他类，只需要在Factory的原型里添加就可以了。</p>
<h3 id="收获与总结-1"><a href="#收获与总结-1" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>对于创建很多类的对象，简单工厂模式就不适合了，通过工厂模式可以轻松创建多个类的实例对象，而且避免了使用者与对象类之间的耦合，用户不必关心创建该对象的具体类，只需调用工厂方法即可。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式让你感觉出现的都是幻觉。</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责某一类产品的实例。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种声明但不能使用的类，当你使用的时候就会报错。JavaScript中的抽象类不能像传统面向对象语言那样轻松地创建，我们可以在类的方法中手动抛出错误来模拟抽象类。你可能会想，这样的类什么都不能做能有什么用？其实它在继承上是很有用的。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>抽象工厂模式不能用来创建具体对象，一般用它作为父类类创建一些子类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抽象工厂方法</span></div><div class="line"><span class="keyword">var</span> VehicleFactory = <span class="function"><span class="keyword">function</span>(<span class="params">subType, superType</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断抽象工厂中是否有该抽象类</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> VehicleFactory[superType] === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="comment">// 缓存类</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">        <span class="comment">// 继承父类属性和方法</span></div><div class="line">        F.prototype = <span class="keyword">new</span> VehicleFactory[superType]();</div><div class="line">        <span class="comment">// 将子类构造函数指向子类</span></div><div class="line">        subType.constructor = subType;</div><div class="line">        <span class="comment">// 子类原型继承父类</span></div><div class="line">        subType.prototype = <span class="keyword">new</span> F();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不存在该抽象类抛出错误</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'未创建该抽象类'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 小汽车抽象类</span></div><div class="line">VehicleFactory.Car = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">'car'</span>;</div><div class="line">&#125;;</div><div class="line">VehicleFactory.Car.prototype = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 公交车抽象类</span></div><div class="line">VehicleFactory.Bus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">'bus'</span>;</div><div class="line">&#125;;</div><div class="line">VehicleFactory.Bus.prototype = &#123;</div><div class="line">    <span class="attr">getPrice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>抽象工厂实际上是一个子类继承父类的方法，在该方法中需要通过传递子类以及继承父类的名称。</p>
<h3 id="收获与总结-2"><a href="#收获与总结-2" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>抽象工厂模式是设计模式中最抽象的一种，也是创建模式中唯一一种抽象化创建模式。该模式创建出的结果不是一个真实的对象实例，而是一个类簇，指定了类的结构。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式告诉我们分即是合。</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>现在有一个发布简历的需求，就是帮别人在公司网站上发布简历，但是这些简历有一个需求，除了将兴趣爱好以及一些特长发布在页面里，其他信息如联系方式等不要发布在网站上，而且每个人想找的工作是可以分类的。这样一些需求我们需要创建的东西就多了，这时候前面的三种工厂模式都不适合了，这里就可以用建造者模式。<br>建造者模式和只关心创建结果的工厂模式不同，虽然其目的也是创建一个对象，但是更多关心的是创建这个对象的整个过程。在本例中，我们需要的不仅仅是应聘者的实例还要在创建过程中注意这位应聘者有哪些兴趣爱好等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一位人类</span></div><div class="line"><span class="keyword">var</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="comment">// 技能</span></div><div class="line">    <span class="keyword">this</span>.skill = param &amp;&amp; param.skill || <span class="string">'保密'</span>;</div><div class="line">    <span class="comment">// 兴趣爱好</span></div><div class="line">    <span class="keyword">this</span>.hobby = param &amp;&amp; param.hobby || <span class="string">'保密'</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 类人原型方法</span></div><div class="line">Human.prototype = &#123;</div><div class="line">    <span class="attr">getSkill</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.skill;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getHobby</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例化姓名类</span></div><div class="line"><span class="keyword">var</span> Named = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 构造器，解析姓名的姓与名</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">name, that</span>) </span>&#123;</div><div class="line">        that.wholeName = name;</div><div class="line">        <span class="keyword">if</span>(name.indexOf(<span class="string">' '</span>) &gt; <span class="number">-1</span>) &#123;</div><div class="line">            that.FirstName = name.slice(<span class="number">0</span>, name.indexOf(<span class="string">' '</span>));</div><div class="line">            that.FirstName = name.slice(name.indexOf(<span class="string">' '</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;)(name, that);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例化职位类</span></div><div class="line"><span class="keyword">var</span> Work = <span class="function"><span class="keyword">function</span>(<span class="params">work</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 构造器，通过传入的职位特征来设置相应职位及描述</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">work, that</span>) </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(work) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'code'</span>:</div><div class="line">                that.work = <span class="string">'工程师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'UI'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'UE'</span>:</div><div class="line">                that.work = <span class="string">'设计师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'teach'</span>:</div><div class="line">                that.work = <span class="string">'教师'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                that.work = work;</div><div class="line">        &#125;</div><div class="line">    &#125;)(work, that);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 更换期望的职位</span></div><div class="line">Work.prototype.changeWork = <span class="function"><span class="keyword">function</span>(<span class="params">work</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.work = work;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面来创建以为应聘者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 应聘者创建类</span></div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, work</span>) </span>&#123;</div><div class="line">    <span class="comment">// 创建应聘者缓存对象</span></div><div class="line">    <span class="keyword">var</span> _person = <span class="keyword">new</span> Human();</div><div class="line">    <span class="comment">// 创建应聘者姓名解析对象</span></div><div class="line">    _person.name = <span class="keyword">new</span> Named(name);</div><div class="line">    <span class="comment">// 创建应聘者期望职位</span></div><div class="line">    _person.work = <span class="keyword">new</span> Work(work);</div><div class="line">    <span class="comment">// 返回创建的应聘者对象</span></div><div class="line">    <span class="keyword">return</span> _person;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-3"><a href="#收获与总结-3" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>建造者模式和前面几种创建型设计模式不同，它关心对象的整个创建过程，因此通常将创建对象的类模块化，这样使创建类的每一个模块都可以得到灵活的运用与高质量的复用。这种方式对于整个对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低，不建议使用建造者模式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是JavaScript语言之魂。</p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。</p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>还是关于子类继承父类的问题，为了提高性能，对于每次创建的一些简单的而又有差异化的属性可以放在构造函数中，将一些消耗资源比较大的方法放在基类的原型中，这样就可以避免不必要的消耗，这就是原型模式的雏形。<br>原型模式更多的是用在对象的创建上，比如创建一个实例对象的构造函数比较复杂或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，可以通过对这些对象属性或者方法进行复制来实现创建。首先要有一个原型对象的复制方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型对象复制方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototypeExtend</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        args = <span class="built_in">arguments</span>,</div><div class="line">        i = <span class="number">0</span>,</div><div class="line">        len = args.length;</div><div class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</div><div class="line">        <span class="comment">// 遍历每个模板对象中的属性</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">in</span> args[i]) &#123;</div><div class="line">            F.prototype[j] = args[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回缓存类实例</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>企鹅游戏中创建一个企鹅对象，如果没有企鹅基类，只提供了一些动作模板对象，可以通过实现这些模板对象的继承来创建一个企鹅实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> penguin = prototypeExtend(&#123;</div><div class="line">    <span class="attr">speed</span>: <span class="number">20</span>,</div><div class="line">    <span class="attr">swim</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'游泳速度'</span> + <span class="keyword">this</span>.speed);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">run</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'奔跑速度'</span> + <span class="keyword">this</span>.speed);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样通过prototypeExtend创建的就是一个对象，不用再用new去创建一个新的实例对象。</p>
<h3 id="收获与总结-4"><a href="#收获与总结-4" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>原型模式实际上也是一种继承，可以让多个对象分享同一个原型对象的属性和方法，这种继承的实现是不需要创建的，而是将原型对象分享给那些继承的对象。原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>哈哈，让你感受下一个人的寂寞。</p>
<h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>又被称为单体模式，只允许实例化一次的对象类。有时也可以用一个对象来规划一个命名空间，井井有条地管理对象上的属性和方法。</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><p>单例模式应该是JavaScript中最常见的一种设计模式了，经常为我们提供一个命名空间，来防止不同的人命名变量的冲突。还可以用它来创建一个小型的代码库。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = &#123;</div><div class="line">    <span class="attr">Util</span>: &#123;</div><div class="line">        <span class="attr">util_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">util_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Tool</span>: &#123;</div><div class="line">        <span class="attr">tool_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">tool_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Ajax</span>: &#123;</div><div class="line">        <span class="attr">ajax_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">ajax_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想使用这个代码库，像下面这样访问即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.Util.util_method1();</div><div class="line">A.Tool.tool_method2();</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-5"><a href="#收获与总结-5" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>单例模式有时也被称为单体模式，它是只允许实例化一次的对象类，有时这么做也是为了节省系统资源。JavaScript中单例模式经常作为命名空间对象来实现，通过单例对象，我们可以将各个模块的代码井井有条地梳理在一起。</p>
<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><p>结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计。主要有外观模式，适配器模式，代理模式，装饰者模式，桥接模式，组合模式和享元模式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>作者把这种模式比喻成一种套餐服务。</p>
<h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更加容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用。</p>
<h3 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h3><p>为页面文档document对象添加点击事件时，如果直接用onclick来绑定事件，那么如果团队中再有人要为document绑定click事件时，就会把之前绑定的那个时间覆盖，因为这是DOM0级事件。我们应该用DOM2级事件处理程序提供的addEventListener来实现，然而老版本IE是不支持这个方法的，必须用attachEvent，这样如果我们写一个能兼容所有浏览器的方式操作起来就会更方便，这时候就可以用到外观模式。为功能统一但方法不统一的接口提供一个统一的接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 外观模式实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">dom, type, fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// 对于支持DOM2级事件处理程序的浏览器</span></div><div class="line">    <span class="keyword">if</span>(dom.addEventListener) &#123;</div><div class="line">        dom.addEventListener(type, fn, <span class="literal">false</span>);</div><div class="line">    <span class="comment">// 对于不支持addEventListener但支持attachEvent的浏览器</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dom.attachEvent) &#123;</div><div class="line">        dom.attachEvent(<span class="string">'on'</span> + type, fn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dom[<span class="string">'on'</span> + type] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解决浏览器兼容问题只是外观模式应用的一部分，很多代码库中都是通过外观模式来封装多个功能，简化底层造作方法的。</p>
<h3 id="收获与总结-6"><a href="#收获与总结-6" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用及其复杂。通过外观模式，对接口进行二次封装可以隐藏其复杂性。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>听到这个是的名字，有没有想到水管弯弯的场景呢？</p>
<h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>将一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p>
<h3 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h3><p>公司有个活动页面正在使用公司内部开发的A框架，可是很多新来的同事使用A框架开发新的功能需求时总是感觉很吃力，而且能用的方法有限，为了让新同事尽快融入项目的开发，可以引入jQuery框架，由于A框架和jQuery框架很像，这样就可以写一个适配器而不需要将之前的代码全用jQuery写一遍。<br>适配器模式不仅在编程中很常见，在生活中这种模式也很常见，比如三角插头充电器对于两项插头是不能用的，此时就需要一个三项转两项插头电源适配器，这就是一种适配器模式，其实它就是为了两个代码库所写的代码兼容运行而书写的额外代码。<br>JavaScript中适配器模式还能适配两个代码库，适配参数，适配数据，适配服务端数据等。以参数适配为例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">name, title, age, color, size, prize</span>)</span>&#123;&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">记住这些参数的顺序是很困难的，所以我们经常是以一个参数对象方式传入的，如下所示：</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>obj.name: name</li>
<li>obj.title: title</li>
<li>obj.age: age</li>
<li>obj.color: color</li>
<li>obj.size: size</li>
<li>obj.prize: prize<br><em>*</em>/<br>function doSomeThing(obj){}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">然而当调用的时候也不能确定传递的参数是否完整，如有一些必须得参数没有传入，一些参数有默认值等，这个时候就可以用适配器来适配传入的参数对象。</div><div class="line">```javascript</div><div class="line">function doSomeThing(obj) &#123;</div><div class="line">    var _adapter = &#123;</div><div class="line">        name: &apos;雨夜清荷&apos;,</div><div class="line">        title: &apos;设计模式&apos;,</div><div class="line">        age: 24,</div><div class="line">        color: &apos;pink&apos;,</div><div class="line">        size: 100,</div><div class="line">        prize: 50</div><div class="line">    &#125;;</div><div class="line">    for(var i in _adapter) &#123;</div><div class="line">        _adapter[i] = obj[i] || _adapter[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="收获与总结-7"><a href="#收获与总结-7" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>JavaScript中的适配器更多应用在对象之间，为了使对象可用，通常会将对象拆分并重新包装，这样就要了解适配器对象的内部结构，这也是与外观模式的区别所在。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>有没有想到牛郎织女鹊桥相会的场景？</p>
<h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。</p>
<h3 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h3><p>跨域问题应该是使用代理模式解决的一个最典型的问题。由于用户模块上传的照片量越来越大，导致服务器需要将上传模块重新部署到另外一个域中，这就导致了跨域问题。我们可以将相册页面和上传模块所在的服务器抽象成两个对象，想让跨域两端的对象之间实现通信，就需要找个代理对象来实现他们之间的通信。<br>代理对象有很多种，简单一点的如img之类的标签通过src可以向其他域下的服务器发送请求。不过这类请求是get请求，是单向的，不会有响应数据。另外一种代理对象的形式是通过script标签。而我们需要的代理对象，是对页面与浏览器间通信的，JSONP就实现了一种代理模式。我们知道src属性可以实现get请求，因此可以在src指向的url地址上添加一些字段信息，服务器获取这些字段信息，相应生成一分内容。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 前端浏览器页面</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">// 回调函数</div><div class="line">function jsonpCallBack(res,req) &#123;</div><div class="line">    console.log(res,req);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript" src="http://localhost/test/jsonp.php?callback=jsonp CallBack&amp;data=getJsonPData"&gt;&lt;/script&gt;</div><div class="line">// 另一个域下的服务器请求接口</div><div class="line">&lt;?php</div><div class="line">/* 后端获取请求字段数据，并生成返回内容 */</div><div class="line">$data = $_GET["data"];</div><div class="line">$callback = $_GET["callback"];</div><div class="line">echo $callback."('success', '".$data."')";</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>这种方式可以想象成合理的一只小船，通过小船将你的请求发送给对岸，然后对岸的人们将数据放在小船里为你带回来。</p>
<h3 id="收获与总结-8"><a href="#收获与总结-8" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>代理模式除了在跨域问题中有很多应用外，有时对对象的实例化对资源的开销很大，如页面加载初期加载文件有很多，此时能够延迟加载一些图片对页面首屏加载时间收益是很大的，通过代理可以先加载预览图片然后再加载开销大的图片。<br>由此可见，代理模式可以解决系统之间耦合度以及系统资源开销大的问题，通过代理对象可以保护被代理对象，使被代理对象不受外界的影响。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>显然房子装修就是一种典型的装饰者模式。</p>
<h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>在不改变原对象的基础上，通过对其进行包装扩展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。</p>
<h3 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h3><p>静止是相对的，运动是绝对的，所以没有一成不变的需求。在实际项目开发中需求总在不断变化，当原有的功能已经不能满足用户的需求时，我们要做的就是在这个基础上添砖加瓦，设置新功能和属性来满足用户提出的需求，这就是装饰者模式要做的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 装饰者</span></div><div class="line"><span class="keyword">var</span> decorator = <span class="function"><span class="keyword">function</span>(<span class="params">input, fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// 获取事件源</span></div><div class="line">    <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(input);</div><div class="line">    <span class="comment">// 若事件源已经绑定事件</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> input.onclick === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="comment">// 缓存事件源原有回调函数</span></div><div class="line">        <span class="keyword">var</span> oldClickFn = input.onclick;</div><div class="line">        <span class="comment">// 为事件源定义新的事件</span></div><div class="line">        input.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 事件源原有回调函数</span></div><div class="line">            oldClickFn();</div><div class="line">            <span class="comment">// 执行事件源新增回调函数</span></div><div class="line">            fn();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        input.onclick = fn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-9"><a href="#收获与总结-9" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>除了装饰者模式，适配器模式也可以对原有对象进行扩展，所不同的是适配器进行扩展很多时候是对对象内部结构的重组，因此了解其自身结构是必须的。而装饰者模式对对象的扩展是一种良性扩展，不用了解其具体实现，只是在外部进行了一次封装扩展。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>作者把这种模式比喻成城市间的公路。</p>
<h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>
<h3 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h3><p>有时候，页面中一些小小细节的改变常常因逻辑相似而导致大片臃肿的代码，让页面苦涩不堪。现在项目有一个需求，是要把页面上部的用户信息添加一些鼠标划过的特效，但是用户信息由很多小组件组成，对于用户名，鼠标划过直接改变背景色，但是像用户等级、用户消息这类部件只能改变里面的数字内容，处理逻辑不太一样。这样就需要写不少代码，但是又会感觉很冗余。这时候，我们首先要提取共同点，对想的抽象逻辑做抽象提取处理。<br>对于用户信息模块的每一部分鼠标滑过与鼠标离开两个事件的执行函数有很大一部分是相似的，比如它们都处理每个部件中的某个元素，它们都是处理元素的字体颜色和背景颜色。可以创建下面这样一个函数，解除this耦合。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">dom, color, bg</span>) </span>&#123;</div><div class="line">    <span class="comment">// 设置元素的字体颜色</span></div><div class="line">    dom.style.color = color;</div><div class="line">    <span class="comment">// 设置元素的背景颜色</span></div><div class="line">    dom.style.background = bg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是对具体元素绑定时间了，但是仅仅知道元素事件绑定与抽象提取的设置样式方法changeColor是不够的，需要用一个方法将他们链接起来，这个方法就是桥接方法，这种模式就是桥接模式。就像你开着车去沈阳，那么你就需要找到一条连接北京与沈阳的公路，才能顺利往返两地。<br>对于事件的桥接方法，可以用一个匿名函数来代替。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spans = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</div><div class="line">spans[<span class="number">0</span>].onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    changeColor(<span class="keyword">this</span>, <span class="string">'red'</span>, <span class="string">'#ddd'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-10"><a href="#收获与总结-10" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>桥接模式最主要的特点是将实现层（如元素绑定事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，桥接模式主要是对结构之间的解耦。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>作者把组合模式比喻成超值午餐，感觉很形象。</p>
<h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层级结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h3 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h3><p>为强化首页用户体验，项目经理准备在用户首页添加一个新闻模块，当然新闻的内容是根据用户平时关注的内容挖掘的，因此有的人可能会显示文字新闻，有的人可能会是图片新闻等等。<br>我们先来仔细分析下这个需求，需求中的这些新闻大致可以分为相互独立的几种类型，对某类新闻做修改时不会影响到其他类的新闻，这样可以将每一类新闻抽象成面向对象编程中的一个类，然后在这些新闻类中挑选一些组合成需要的模块，这时候就可以用组合模式了。<br>在页面中，组合模式更常用在创建表单上，比如注册页面可能有不同的表单提交模块。对于这些需求，我们只需要有一个基本的个体，然后通过一定的组合即可实现。</p>
<h3 id="收获与总结-11"><a href="#收获与总结-11" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>组合模式能够给我们提供一个清晰的组成结构，组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了统一管理与使用。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>作者把享元模式比喻成城市公交车，可以仔细思考一番。</p>
<h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</p>
<h3 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h3><p>现在有新闻的内容太多，我们有了一个分页显示所有新闻的需求。一个简单直观的做法就是页面加载后异步请求新闻数据，然后创建所有条新闻插入页面中，需要显示哪一页就显示哪一页。但是这样做有一个很大的问题，这样一下子创建几百条新闻同时插入页面会造成多页的开销严重影响网页的性能。这里的所有新闻都有相似的结构，只是内容不同罢了，对于这种相同结构造成多余开销的问题，可以用享元模式来解决。<br><strong>享元模式</strong> 主要是对其数据、方法共享分离，将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或共有的数据和方法，所以将其提取出来减少开销。上面例子中，所有新闻个体都有共同的结构，应该作为内部数据，而下一页按钮绑定的事件则是外部方法。同时为了使用内部数据还需要提供一个操作方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Flyweight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 已创建的元素</span></div><div class="line">    <span class="keyword">var</span> created = [];</div><div class="line">    <span class="comment">// 创建一个新闻包装容器</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">        <span class="comment">// 将容器插入新闻列表容器中</span></div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).appendChild(dom);</div><div class="line">        <span class="comment">// 缓存新创建的元素</span></div><div class="line">        created.push(dom);</div><div class="line">        <span class="comment">// 返回创建的新元素</span></div><div class="line">        <span class="keyword">return</span> dom;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 获取创建新闻元素方法</span></div><div class="line">        getDiv: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果已创建的元素小于当前页元素总个数(5个)，则创建</span></div><div class="line">            <span class="keyword">if</span>(created.length &lt; <span class="number">5</span>) &#123;</div><div class="line">                <span class="keyword">return</span> created();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 获取第一个元素，并插入去后面</span></div><div class="line">                <span class="keyword">var</span> div = created.shift();</div><div class="line">                created.push(div);</div><div class="line">                <span class="keyword">return</span> div;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面创建一个享元类，由于每页只能显示5条新闻，所以创建5个元素，保存在享元类内部，可以通过getDiv方法来获取创建的元素。下面就要实现外部数据和外部方法，外部数据就是我们要显示的所有新闻内容，由于每个内容都不一样肯定不能共享。首先，我们要根据新闻内容实例化页面，然后，对下一页绑定一个点击事件，显示下一页。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> paper = <span class="number">0</span>,</div><div class="line">    num = <span class="number">5</span>,</div><div class="line">    len = article.length;</div><div class="line"><span class="comment">// 添加五条新闻</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(article[i])</div><div class="line">        <span class="comment">// 通过享元类获取创建的元素并写入新闻内容</span></div><div class="line">        Flyweight.getDiv().innerHTML = article[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下一页按钮绑定事件</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'next_page'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果新闻内容不足5条则返回</span></div><div class="line">    <span class="keyword">if</span>(article.length &lt; <span class="number">5</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> n = ++paper * num % len,  <span class="comment">// 获取当前页的第一条新闻索引</span></div><div class="line">        j = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 插入5条新闻</span></div><div class="line">    <span class="keyword">for</span>(; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">        <span class="comment">// 如果存在n+j条则插入</span></div><div class="line">        <span class="keyword">if</span>(article[n + j]) &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = article[n + j];</div><div class="line">        <span class="comment">// 否则插入起始位置第n+j-len条</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(article[n + j - len]) &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = article[n + j - len];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Flyweight.getDiv().innerHTML = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样用享元模式对页面重构之后每次操作只需要操作5个元素，这样性能可以提高很多。</p>
<h3 id="收获与总结-12"><a href="#收获与总结-12" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>享元模式的应用是为了提高程序的执行效率与系统性能，因此在大型系统开发中应用比较广泛，可以避免程序中的数据重复。应用时一定要找准内部状态与外部状态，这样才能更合理地提取分离。</p>
<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><p>行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现。行为型设计模式主要有模板方法模式，观察者模式，状态模式，策略模式，职责链模式，命令模式，访问者模式，中介者模式，备忘录模式，迭代器模式和解释器模式，这么多的模式真得好好消化一阵子了。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>作者把这种模式比喻成照猫画虎。</p>
<h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类，使得子类可以不改变父类算法结构的同时可重新定义算法中某些实现步骤。</p>
<h3 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h3><p>提示框归一化，一个网站有很多页面，如果每个页面的弹出框样式不太一致就会显得不是很和谐，需要将他们的样式统一。新手最直观的想法就是去每个页面一个个修改，当然这样的代价是很大的，我们需要写一个弹出框插件，将这些弹出框封装好，然后再各个页面调用即可。这是在这个插件中就可以使用模板方法模式了，不需要重复写多个样式。<br>模板方法模式就是将多个模型抽象画归一，从中抽象出一个最基本的模板，这个模板可以作为实体也可以作为抽象对象，其他模块只需要继承这个模板方法，也可以扩展某些方法。<br>打个比方，我们生活中用蛋糕做模具做蛋糕，做出的蛋糕是外形相同的，因为他们都用同一个模具。然而商店里面卖的蛋糕是各式各样的，这都是对蛋糕的二次加工。我们的需求中基本提示框就是我们抽象出来的模具，其他提示框比这个提示框要多一些功能，我们只需要对他们做一些二次加工就能满足需求了。<br>模板方法不仅在归一化组件时使用，有时候创建页面时也是很常用的，比如创建三类导航，第一类是基础的，第二类是多了消息提醒功能的，第三类多了后面显示网址功能。这也可以用模板方法实现，此时抽象出来的基类是最简单的基础导航类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式化字符串方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formateString</span>(<span class="params">str, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/\&#123;#(\w+)#\&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> data[key] === <span class="literal">undefined</span> ? <span class="string">''</span>: data[key]</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 基础导航</span></div><div class="line"><span class="keyword">var</span> Nav = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 基础导航样式模板</span></div><div class="line">    <span class="keyword">this</span>.item = <span class="string">'&lt;a href="&#123;#href#&#125;" title="&#123;#title#&#125;"&gt;&#123;#name#&#125;&lt;/a&gt;'</span>;</div><div class="line">    <span class="comment">// 创建字符串</span></div><div class="line">    <span class="keyword">this</span>.html = <span class="string">''</span>;</div><div class="line">    <span class="comment">// 格式化数据</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">this</span>.html += formateString(<span class="keyword">this</span>.item, data[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回字符串数据</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于消息提醒导航类，只需额外添加消息提醒组件模板，并与消息提醒组件模板对传入的网址数据进行装饰，得到所需的字符串，在调用从基类继承的方法处理这些字符串即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> NumNav = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 消息提醒信息组件模板</span></div><div class="line">    <span class="keyword">var</span> tpl = <span class="string">'&lt;b&gt;&#123;#num#&#125;&lt;/b&gt;'</span>;</div><div class="line">    <span class="comment">// 装饰数据</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        data[i].name += data[i].name + formateString(tpl, data[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 继承基础导航类</span></div><div class="line">    <span class="keyword">return</span> Nav.call(<span class="keyword">this</span>, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收获与总结-13"><a href="#收获与总结-13" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>模板方法的核心在于对方法的重用，将核心方法封装在基类中，让子类继承基类的方法，实现基类方法的共享，达到方法共用。子类继承的方法是可扩展的，这就需要对基类继承的方法进行重写。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>作者把这种模式比喻成通信卫星。</p>
<h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>又被称作发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。</p>
<h3 id="使用场景-13"><a href="#使用场景-13" class="headerlink" title="使用场景"></a>使用场景</h3><p>在团队开发中，经常是一个人负责一个模块，那么每人负责的模块之间要如何进行沟通呢？比如你实现一些需求需要添加一些代码，但是这个需求需要其他模块配合，但是每个模块都是不同人写的，你不想因为新添加的代码影响到他人实现的功能，这个时候就需要用到观察者模式了。<br>观察者模式就是为了解决主体对象与观察者之间的耦合。打个比方，目前每个国家都在研发并发射卫星，发射这些卫星是为了监控一些信息，那么它就可以被看做一个观察者或者说是一个消息系统，如果让这颗卫星为飞机导航，那么这架飞机就是一个被观察者或者说是一个主体对象。那么如果地面上的中转站或者其他飞机需要知道这架飞机的信息，于是每当飞机到达一个地方时就会向卫星发出位子信息，然后卫星又将信息广播到已经订阅这架飞机的中转站，这样就可以避免一些飞机事故发生。<br>这时候，观察者至少需要有两个方法，一个是接收某架飞机发来的消息，一个是向订阅的中转站发送响应消息。但是，并不是每个中转站都要时刻监控飞机状态的，所以还需要一个取消注册的方法。当然这些消息还需要保存，就需要一个保存消息的容器。这时候观察者雏形就出来了，他有一个消息容器和三个方法，订阅消息方法，取消订阅消息方法，发送订阅消息方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Observer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 防止消息队列暴露而被篡改，故将消息容器作为静态私有变量保存</span></div><div class="line">    <span class="keyword">var</span> __messages = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 注册信息接口</span></div><div class="line">        regist: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 发布信息接口</span></div><div class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="comment">// 移除信息接口</span></div><div class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>下面就是可以自己具体实现这些接口了。</p>
<h3 id="收获与总结-14"><a href="#收获与总结-14" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>观察者模式最主要是解决类或对象之间的耦合，解耦两个互相依赖的对象，使其依赖于观察者的消息机制。这样对于任何一个订阅者来说，其他订阅者对象的改变不会影响到自身，其自身既可以是消息的发出者也可以是消息的执行者，这都依赖于调用观察者对象中的三种方法（订阅，注销，发布消息）中的哪一种。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>作者把这种模式比喻成超级玛丽。</p>
<h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对像。</p>
<h3 id="使用场景-14"><a href="#使用场景-14" class="headerlink" title="使用场景"></a>使用场景</h3><p>平时写代码的时候经常会遇到要写很多条件判断语句的情况，那么怎么减少代码中的条件判断语句呢？对于这类分支条件内部独立结果的管理，可以使用状态模式，每一种条件作为对象的一种状态，面对不同的判断结果，其实就是选择对象内的一种状态。<br>将不同的判断结果封装在状态对象内，然后该状态对象返回一个可被调用的接口方法，用于调用状态对象内部的某种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 投票结果状态对象</span></div><div class="line"><span class="keyword">var</span> ResultState = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断结果保存在内部状态中</span></div><div class="line">    <span class="keyword">var</span> States = &#123;</div><div class="line">        <span class="comment">// 每种状态作为一种独立方法保存</span></div><div class="line">        state0: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第一种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第二种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第三种情况'</span>)：</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">state3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'这是第四种情况'</span>)：</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取某种状态并执行对应方法</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">        States[<span class="string">'state'</span> + result] &amp;&amp; States[<span class="string">'state'</span> + result]();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 返回调用状态方法接口</span></div><div class="line">        show: show</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>想调用第三种结果就可以如下调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResultState.show(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>对于状态模式，主要目的就是将条件判断的不同结果转化为状态对象的内部状态，这个内部状态一般作为状态对象的私有变量，然后提供一个能够调用状态对象内部状态的接口方法对象即可。</p>
<h3 id="收获与总结-15"><a href="#收获与总结-15" class="headerlink" title="收获与总结"></a>收获与总结</h3><p>状态模式既是解决程序中臃肿的分支判断语句问题，将每一个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次只需时遍历所有分支。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>作者把这种模式比喻成活诸葛。</p>
<h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-15"><a href="#使用场景-15" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-16"><a href="#收获与总结-16" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>作者把这种模式比喻成一个有序车站。</p>
<h3 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-16"><a href="#使用场景-16" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-17"><a href="#收获与总结-17" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-17"><a href="#使用场景-17" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-18"><a href="#收获与总结-18" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>作者把这种模式比喻成驻华大使。</p>
<h3 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-18"><a href="#使用场景-18" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-19"><a href="#收获与总结-19" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>作者把这种模式比喻成媒婆，好吧，我笑了这里。</p>
<h3 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-19"><a href="#使用场景-19" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-20"><a href="#收获与总结-20" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-20"><a href="#使用场景-20" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-21"><a href="#收获与总结-21" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>作者把这种模式比喻成一个点钞机。</p>
<h3 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-21"><a href="#使用场景-21" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-22"><a href="#收获与总结-22" class="headerlink" title="收获与总结"></a>收获与总结</h3><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>这种模式相当于一种语言翻译。</p>
<h3 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h3><h3 id="使用场景-22"><a href="#使用场景-22" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="收获与总结-23"><a href="#收获与总结-23" class="headerlink" title="收获与总结"></a>收获与总结</h3><p># </p>

    
  </div>
</article>

</div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/project/"
              target="_self"
              >
              项目
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于我
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="" data-title="《JavaScript设计模式》读后感 觉很复杂" data-url="http://yuhan.com/2016/12/23/javascript-design-patterns/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"hyuhan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
